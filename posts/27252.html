<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.css" integrity="sha256-vQkngPS8jiHHH0I6ABTZroZk8NPZ7b+MUReOFE9UsXQ=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"rjyblog.gitee.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文基于Android 8.0源码分析。以mediaserver为例剖析binder addService的流程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android binder剖析之addService">
<meta property="og:url" content="https://rjyblog.gitee.io/posts/27252.html">
<meta property="og:site_name" content="任建勇的博客">
<meta property="og:description" content="本文基于Android 8.0源码分析。以mediaserver为例剖析binder addService的流程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rjyblog.gitee.io/assert/puml/9536509db57575a74802a716e96ed871515553ee964304a65ee5c21bf070a93b.svg">
<meta property="og:image" content="https://rjyblog.gitee.io/assert/puml/cf204ed7275591267993baa6056c8137797c121f37a24d68fedc25ac3e08d835.svg">
<meta property="og:image" content="https://rjyblog.gitee.io/assert/puml/c054fe59ca58b09b8f8f34c4a16657160b23d71ea24643b525f4c5a6f1cff570.svg">
<meta property="article:published_time" content="2020-11-23T03:16:04.000Z">
<meta property="article:modified_time" content="2023-08-17T01:46:48.258Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="binder">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rjyblog.gitee.io/assert/puml/9536509db57575a74802a716e96ed871515553ee964304a65ee5c21bf070a93b.svg">


<link rel="canonical" href="https://rjyblog.gitee.io/posts/27252.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://rjyblog.gitee.io/posts/27252.html","path":"posts/27252.html","title":"Android binder剖析之addService"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android binder剖析之addService | 任建勇的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">任建勇的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ProcessState%E6%89%93%E5%BC%80binder%E8%AE%BE%E5%A4%87"><span class="nav-text">1. ProcessState打开binder设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%8E%B7%E5%8F%96-IServiceManager"><span class="nav-text">2. 获取 IServiceManager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DECLARE-META-INTERFACE%E5%AE%8F"><span class="nav-text">DECLARE_META_INTERFACE宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMPLEMENT-META-INTERFACE%E5%AE%8F"><span class="nav-text">IMPLEMENT_META_INTERFACE宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96IServiceManager%E5%B0%8F%E7%BB%93"><span class="nav-text">获取IServiceManager小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-addService%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">3. addService流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BpServiceManager%E7%B1%BB"><span class="nav-text">BpServiceManager类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MediaPlayerService%E7%B1%BB"><span class="nav-text">MediaPlayerService类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BpServiceManager-addService"><span class="nav-text">BpServiceManager::addService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPCThreadState-transact"><span class="nav-text">IPCThreadState::transact()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parcel%E7%AD%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="nav-text">Parcel等数据结构分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPCThreadState-waitForResponse"><span class="nav-text">IPCThreadState::waitForResponse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPCThreadState-talkWithDriver"><span class="nav-text">IPCThreadState::talkWithDriver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ServiceManager%E5%88%86%E6%9E%90"><span class="nav-text">4. ServiceManager分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0-main"><span class="nav-text">入口函数 main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceManager%E6%89%93%E5%BC%80binder%E8%AE%BE%E5%A4%87"><span class="nav-text">ServiceManager打开binder设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E4%B8%BAcontext-manager"><span class="nav-text">成为context_manager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binder-loop%E5%BE%AA%E7%8E%AF"><span class="nav-text">binder_loop循环</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jason"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rjyblog.gitee.io/posts/27252.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jason">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="任建勇的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android binder剖析之addService | 任建勇的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android binder剖析之addService
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-23 11:16:04" itemprop="dateCreated datePublished" datetime="2020-11-23T11:16:04+08:00">2020-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-17 09:46:48" itemprop="dateModified" datetime="2023-08-17T09:46:48+08:00">2023-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文基于Android 8.0源码分析。以mediaserver为例剖析binder addService的流程。</p>
<span id="more"></span>

<p>先来看下addService的时序图：</p>
<img src="\assert\puml\9536509db57575a74802a716e96ed871515553ee964304a65ee5c21bf070a93b.svg"/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\av\media\mediaserver\main_mediaserver.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;  <span class="comment">// 1. ProcessState是个单例，每个进程只有一个实例，binder设备的打开操作就是在此</span></span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;  <span class="comment">//2. 获取IServiceManager</span></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">InitializeIcuOrDie</span>();</span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-ProcessState打开binder设备"><a href="#1-ProcessState打开binder设备" class="headerlink" title="1. ProcessState打开binder设备"></a>1. ProcessState打开binder设备</h2><p>ProcessState是一个进程相关的对象，一个对象只有一个ProcessState。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\ProcessState.cpp</span></span><br><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);  <span class="comment">//采用单例模式，每个进程保证只有一个ProcessState</span></span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> <span class="built_in">ProcessState</span>(<span class="string">&quot;/dev/binder&quot;</span>);   <span class="comment">//构造函数传入了binder设备的路径</span></span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))  <span class="comment">//打开binder设备, mDriverFD成员变量就是binder设备的文件描述符</span></span><br><span class="line">    ......</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using /dev/binder failed: unable to mmap transaction memory.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState构造函数中，调用mmap把binder设备内核空间的一段内存映射到用户空间。mmap的具体作用跟设备的实现有关系。<br>关于mmap的介绍可以参考这篇文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/DLUTBruceZhang/article/details/9080173">Linux 内存映射函数 mmap（）函数详解
</a></p>
<p>现在看下open_driver是如何打开binder设备的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span>  <span class="comment">//driver参数指的就是&quot;/dev/binder&quot;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);  <span class="comment">//系统调用open打开binder设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//通过ioctl获取binder设备的协议版本号。</span></span><br><span class="line">        <span class="type">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="type">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较应用端和binder内核驱动的版本号是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">//设置支持的最大线程数15</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以看出打开binder设备的操作还是很简单的。</p>
<h2 id="2-获取-IServiceManager"><a href="#2-获取-IServiceManager" class="headerlink" title="2. 获取 IServiceManager"></a>2. 获取 IServiceManager</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IServiceManager.cpp</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//依然是单例模式</span></span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = <span class="built_in">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()-&gt;getContextObject(NULL)最终返回的是 new BpBinder(0); ，其中0表示的就是ServiceManager在binder系统中的标识。</p>
<p>interface_cast的定义如下，是一个模板函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IInterface.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换模板参数后就是如下形式：</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最终调用的是IServiceManager::asInterface(new BpBinder(0))，所以需要再分析一下IServiceManager::asInterface函数。</p>
<p>看一下IServiceManager的定义，非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IServiceManager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IServiceManager</span> : <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DECLARE_META_INTERFACE</span>(ServiceManager)</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>    <span class="title">addService</span><span class="params">( <span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt;    <span class="title">listServices</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DECLARE-META-INTERFACE宏"><a href="#DECLARE-META-INTERFACE宏" class="headerlink" title="DECLARE_META_INTERFACE宏"></a>DECLARE_META_INTERFACE宏</h3><p>其中DECLARE_META_INTERFACE是个宏定义，与IMPLEMENT_META_INTERFACE宏配合使用，是谷歌提供的用于native service层对接binder的两个模板宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IInterface.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line"><span class="meta">    static const ::android::String16 descriptor;                        \</span></span><br><span class="line"><span class="meta">    static ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> asInterface(                     \</span></span><br><span class="line"><span class="meta">            const ::android::sp<span class="string">&lt;::android::IBinder&gt;</span>&amp; obj);              \</span></span><br><span class="line"><span class="meta">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \</span></span><br><span class="line"><span class="meta">    I##INTERFACE();                                                     \</span></span><br><span class="line"><span class="meta">    virtual ~I##INTERFACE();                                            \</span></span><br></pre></td></tr></table></figure>

<p>宏的参数替换成 ServiceManager 后，可以得到IServiceManager类的头文件声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IServiceManager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IServiceManager</span> : <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//DECLARE_META_INTERFACE(INTERFACE) 宏定义展开如下</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> ::android::String16 descriptor;</span><br><span class="line">    <span class="type">static</span> ::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">asInterface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">const</span> ::<span class="function">android::String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="built_in">IServiceManager</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IServiceManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>    <span class="title">addService</span><span class="params">( <span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt;    <span class="title">listServices</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IMPLEMENT-META-INTERFACE宏"><a href="#IMPLEMENT-META-INTERFACE宏" class="headerlink" title="IMPLEMENT_META_INTERFACE宏"></a>IMPLEMENT_META_INTERFACE宏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IInterface.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line"><span class="meta">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span></span><br><span class="line"><span class="meta">    const ::android::String16&amp;                                          \</span></span><br><span class="line"><span class="meta">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span></span><br><span class="line"><span class="meta">        return I##INTERFACE::descriptor;                                \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> I##INTERFACE::asInterface(              \</span></span><br><span class="line"><span class="meta">            const ::android::sp<span class="string">&lt;::android::IBinder&gt;</span>&amp; obj)               \</span></span><br><span class="line"><span class="meta">    &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> intr;                               \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span></span><br><span class="line"><span class="meta">            intr = static_cast<span class="string">&lt;I##INTERFACE*&gt;</span>(                          \</span></span><br><span class="line"><span class="meta">                obj-&gt;queryLocalInterface(                               \</span></span><br><span class="line"><span class="meta">                        I##INTERFACE::descriptor).get());               \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span></span><br><span class="line"><span class="meta">                intr = new Bp##INTERFACE(obj);                          \</span></span><br><span class="line"><span class="meta">            &#125;                                                           \</span></span><br><span class="line"><span class="meta">        &#125;                                                               \</span></span><br><span class="line"><span class="meta">        return intr;                                                    \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span></span><br><span class="line"><span class="meta">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span></span><br></pre></td></tr></table></figure>

<p>再看下IServiceManager.cpp中IMPLEMENT_META_INTERFACE宏的使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IServiceManager.cpp</span></span><br><span class="line"><span class="built_in">IMPLEMENT_META_INTERFACE</span>(ServiceManager, <span class="string">&quot;android.os.IServiceManager&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>把宏定义展开后，IServiceManager.cpp源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMPLEMENT_META_INTERFACE(INTERFACE, NAME)宏定义展开代码如下：</span></span><br><span class="line">    <span class="type">const</span> ::<span class="function">android::String16 <span class="title">IServiceManager::descriptor</span><span class="params">(<span class="string">&quot;android.os.IServiceManager&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> ::<span class="function">android::String16&amp; <span class="title">IServiceManager::getInterfaceDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">IServiceManager::asInterface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ::android::sp&lt;IServiceManager&gt; intr;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            intr = <span class="built_in">static_cast</span>&lt;IServiceManager*&gt;(</span><br><span class="line">                obj-&gt;<span class="built_in">queryLocalInterface</span>(IServiceManagerE::descriptor).<span class="built_in">get</span>());</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                intr = <span class="keyword">new</span> <span class="built_in">BpServiceManager</span>(obj);  <span class="comment">//最终是创建了一个BpServiceManager对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intr;</span><br><span class="line">    &#125;</span><br><span class="line">    IServiceManager::<span class="built_in">IServiceManager</span>() &#123; &#125;</span><br><span class="line">    IServiceManager::~<span class="built_in">IServiceManager</span>() &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取IServiceManager小结"><a href="#获取IServiceManager小结" class="headerlink" title="获取IServiceManager小结"></a>获取IServiceManager小结</h3><p>获取IServiceManager的代码可以使用如下代码来等价的表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化版代码</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = <span class="keyword">new</span> <span class="built_in">BpServiceManager</span>(<span class="keyword">new</span> <span class="built_in">BpBinder</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出获取的IServiceManager就是BpServiceManager对象，BpServiceManager的构造函数需要一个BpBinder对象。这两个类的作用我们在后面详细介绍。</p>
<h2 id="3-addService流程分析"><a href="#3-addService流程分析" class="headerlink" title="3. addService流程分析"></a>3. addService流程分析</h2><p>再回顾下上面两个章节内容：</p>
<ol>
<li>mediaserver进程首先创建了一个ProcessState，在ProcessState的构造函数中打开了binder设备；</li>
<li>获取IServiceManager（就是BpServiceManager对象），然后就可以与ServiceManager进行binder通信了。</li>
</ol>
<p>通过上面介绍的两点，我们就可以推测出来，BpServiceManager肯定要使用ProcessState才能进行binder通信。实际情况也的确如此，BpServiceManager通过BpBinder对象来使用ProcessState。</p>
<p>首先看下MediaServer是怎么调用addService把多媒体服务添加到ServiceManager中的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\av\media\mediaserver\main_mediaserver.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">InitializeIcuOrDie</span>();</span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();  <span class="comment">//初始化MediaPlayerService</span></span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks\av\media\libmediaplayerservice\MediaPlayerService.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaPlayerService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//defaultServiceManager返回的就是BpServiceManager，就是上面的分析过程。</span></span><br><span class="line">    <span class="comment">//new了一个MediaPlayerService，然后通过addService添加binder服务</span></span><br><span class="line">    <span class="built_in">defaultServiceManager</span>()-&gt;<span class="built_in">addService</span>(</span><br><span class="line">            <span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> <span class="built_in">MediaPlayerService</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BpServiceManager类"><a href="#BpServiceManager类" class="headerlink" title="BpServiceManager类"></a>BpServiceManager类</h3><p>BpServiceManager就是binder跨进程通信机制的C/S架构的client端，属于业务层，定义在frameworks\native\libs\binder\IServiceManager.cpp文件中。首先看下BpServiceManager相关联的binder家族类图：</p>
<img src="\assert\puml\cf204ed7275591267993baa6056c8137797c121f37a24d68fedc25ac3e08d835.svg"/>

<p>BpServiceManager的父类BpRefBase持有了BpBinder对象，BpBinder会使用IPCThreadState，而IPCThreadState又使用ProcessState。通过这张图，BpServiceManager到ProcessState的脉络就清楚了。</p>
<p>BpInterface是个模板类，会继承它的模板参数，比如在此处继承了IServiceManager。从上面的类图中可以看出BpServiceManager并没有继承IBinder，而是通过父类BpInterface的mRemote成员变量持有了BpBinder（继承自IBinder）。BpServiceManager与ServiceManager服务端的交互都是通过BpBinder来进行的。</p>
<h3 id="MediaPlayerService类"><a href="#MediaPlayerService类" class="headerlink" title="MediaPlayerService类"></a>MediaPlayerService类</h3><p>熟悉了BpServiceManager的脉络，再先看下通过addService添加的MediaPlayerService类的脉络，然后再继续分析ServiceManager的addService的流程：</p>
<img src="\assert\puml\c054fe59ca58b09b8f8f34c4a16657160b23d71ea24643b525f4c5a6f1cff570.svg"/>

<p>可以看到MediaPlayerService继承自BBinder，就是binder C/S架构的服务端，是媒体服务(“media.player”)的提供者。通过ServiceManager系统把MediaPlayerService注册到binder系统中。</p>
<p>MediaPlayerService类并不是我们的主角，这里介绍MediaPlayerService的目的是来熟悉一下服务和BBinder的关系。addService的服务端的主角是service_manager（定义在service_manager.c中，会面会详细介绍），但是service_manager并没有接入BBinder框架，而是通过直接打开binder设备来通信。作为binder服务的管理者，service_manager在实现上就和普通的binder服务不同。</p>
<h3 id="BpServiceManager-addService"><a href="#BpServiceManager-addService" class="headerlink" title="BpServiceManager::addService"></a>BpServiceManager::addService</h3><p>来看下BpServiceManager的addService是如何实现的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IServiceManager.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpServiceManager</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; impl)</span>  <span class="comment">//impl参数就是BpBinder(0)</span></span></span><br><span class="line"><span class="function">        : BpInterface&lt;IServiceManager&gt;(impl)  &#123;</span>&#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">bool</span> allowIsolated)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        <span class="comment">//IServiceManager::getInterfaceDescriptor()返回&quot;android.os.IServiceManager&quot;</span></span><br><span class="line">        data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">        data.<span class="built_in">writeString16</span>(name);  <span class="comment">//name就是&quot;media.player&quot;</span></span><br><span class="line">        data.<span class="built_in">writeStrongBinder</span>(service);  <span class="comment">//service就是MediaPlayerService类对象</span></span><br><span class="line">        data.<span class="built_in">writeInt32</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);  <span class="comment">//allowIsolated默认是false，所以此处为0</span></span><br><span class="line">        <span class="comment">//remote()返回mRemote（就是BpBinder），此处就是调用BpBinder的transact</span></span><br><span class="line">        <span class="type">status_t</span> err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> err == NO_ERROR ? reply.<span class="built_in">readExceptionCode</span>() : err;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BpServiceManager的构造函数没有任何自定义实现，直接把参数（BpBinder）交给了父类。addService函数首先把service信息填充到Parcel中，然后调用BpBinder的transact。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span>  <span class="comment">//flags默认是0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BpBinder的transact啥也没干，直接把请求交给了IPCThreadState的transact。首先看下IPCThreadState::self()的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IPCThreadState.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> gHaveTLS = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> gTLS = <span class="number">0</span>; <span class="comment">//pthread_key_t是一个TheadLocal变量的key。</span></span><br><span class="line"></span><br><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123; <span class="comment">//首次调用gHavsTLS是false</span></span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;  <span class="comment">//IPCThreadState的构造函数会把自己加到ThreadLocal变量中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS) &#123;</span><br><span class="line">        <span class="comment">//创建一个ThreadLocal变量，key存放到gTLS全局标量中</span></span><br><span class="line">        <span class="type">int</span> key_create_value = <span class="built_in">pthread_key_create</span>(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;</span>, <span class="built_in">strerror</span>(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState::self()的作用就是创建了一个特定线程（TheadLocal数据）的IPCThreadState，所以每个线程维护一个IPCThreadState对象。关于native层ThreadLocal介绍可以参考 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://linux.die.net/man/3/pthread_key_create">https://linux.die.net/man/3/pthread_key_create</a>。再看下IPCThreadState构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">    : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),  <span class="comment">//ProcessState又出现了，ProcessState会打开binder设备</span></span><br><span class="line">      <span class="built_in">mStrictModePolicy</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLastTransactionBinderFlags</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_setspecific</span>(gTLS, <span class="keyword">this</span>);  <span class="comment">//把自己放到ThreadLocal中</span></span><br><span class="line">    <span class="built_in">clearCaller</span>();</span><br><span class="line">    mIn.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);  <span class="comment">//mIn是个Parcel对象，用于存储从binder接收的数据</span></span><br><span class="line">    mOut.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>); <span class="comment">//mOut也是Parcel对象，用于存储向binder发送的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState和ProcessState的关系就清楚了，通过mProcess变量持有了ProcessState对象的引用。</p>
<h3 id="IPCThreadState-transact"><a href="#IPCThreadState-transact" class="headerlink" title="IPCThreadState::transact()"></a>IPCThreadState::transact()</h3><p>看一下IPCThreadState::transact的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//handle = 0，就是ServiceManager在binder系统中的标识</span></span><br><span class="line"><span class="comment">//code = ADD_SERVICE_TRANSACTION</span></span><br><span class="line"><span class="comment">//data 就是BpServiceManager.addService中组装的要通过binder发送出去的Parcel数据</span></span><br><span class="line"><span class="comment">//flags = 0</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">LOG_ONEWAY</span>(<span class="string">&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getuid</span>(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">&quot;READ REPLY&quot;</span> : <span class="string">&quot;ONE WAY&quot;</span>);</span><br><span class="line">        err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;  <span class="comment">//flags初始值是0，走该分支</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123; <span class="comment">//replay不为空，走if分支</span></span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState::transact有两个重点函数调用：writeTransactionData和waitForResponse。分别看下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;  <span class="comment">//target表示发送给谁，此处handle为0就代表ServiceManager</span></span><br><span class="line">    tr.code = code;  <span class="comment">//code值为ADD_SERVICE_TRANSACTION，addService</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>(); <span class="comment">//Parcel数据大小</span></span><br><span class="line">        <span class="comment">//ptr.buffer就是Parcel的mData的地址</span></span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        <span class="comment">//ptr.offsets指向Parcel的mObjects</span></span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是把数据写到mOut中，并没有发送出去</span></span><br><span class="line">    <span class="comment">//需要注意下数据结构的转换：把输入的Parcel转换成binder_transaction_data</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);  <span class="comment">//cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>writeTransactionData把要通过binder传输的数据写入mOut。这里需要注意下数据结构的变更，首先把原始的Parcel(data)转换成binder_transaction_data结构体，然后又写入到mOut中，而mOut也是个Parcel对象。</p>
<h3 id="Parcel等数据结构分析"><a href="#Parcel等数据结构分析" class="headerlink" title="Parcel等数据结构分析"></a>Parcel等数据结构分析</h3><p>我们有必要分析一下传输数据在这个过程中的转换过程。我们都知道，binder通信都是使用Parcel作为数据载体的，Parcel在传输基本数据类型（比如int、string）时，都直接写到成员变量mData指针指向的内存中。Parcel对象构建时，mData并没有指向任何内存，当真正写入数据时才通过memcpy来按需申请内存。mDataSize表示已经写入的数据大小，mDataPos指针指向下次要写入数据的位置。</p>
<p>再回顾一下<code>BpServiceManager::addService</code>拼装初始Parcel数据的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class BpServiceManager</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> allowIsolated)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">    data.<span class="built_in">writeString16</span>(name);</span><br><span class="line">    data.<span class="built_in">writeStrongBinder</span>(service);</span><br><span class="line">    data.<span class="built_in">writeInt32</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.<span class="built_in">readExceptionCode</span>() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行后，Parcel中mData和mObjects两个成员变量可以用下图来表示：</p>
<!--  -->

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: parcel_data Pages: 1 -->
<svg width="532pt" height="116pt"
 viewBox="0.00 0.00 531.50 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>parcel_data</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-112 527.5,-112 527.5,4 -4,4"/>
<!-- mData -->
<g id="node1" class="node">
<title>mData</title>
<polygon fill="none" stroke="#000000" points="6,-79 6,-101 49,-101 49,-79 6,-79"/>
<text text-anchor="start" x="8.8415" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">mData</text>
</g>
<!-- data -->
<g id="node2" class="node">
<title>data</title>
<polygon fill="none" stroke="#000000" points="73,-79 73,-101 96,-101 96,-79 73,-79"/>
<text text-anchor="start" x="75.9474" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">len</text>
<polygon fill="none" stroke="#000000" points="96,-79 96,-101 281,-101 281,-79 96,-79"/>
<text text-anchor="start" x="98.7012" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">“android.os.IServiceManager”</text>
<polygon fill="none" stroke="#000000" points="281,-79 281,-101 304,-101 304,-79 281,-79"/>
<text text-anchor="start" x="283.9474" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">len</text>
<polygon fill="none" stroke="#000000" points="304,-79 304,-101 403,-101 403,-79 304,-79"/>
<text text-anchor="start" x="306.6546" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">“media.player”</text>
<polygon fill="none" stroke="#000000" points="403,-79 403,-101 511,-101 511,-79 403,-79"/>
<text text-anchor="start" x="405.6837" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">flat_binder_object</text>
<polygon fill="none" stroke="#000000" points="511,-79 511,-101 524,-101 524,-79 511,-79"/>
<text text-anchor="start" x="514" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">0</text>
</g>
<!-- mData&#45;&gt;data -->
<g id="edge1" class="edge">
<title>mData:p0&#45;&gt;data:p0</title>
<path fill="none" stroke="#000000" d="M49.1823,-90C53.9239,-90 58.7438,-90 62.7958,-90"/>
<polygon fill="#000000" stroke="#000000" points="63,-93.5001 73,-90 63,-86.5001 63,-93.5001"/>
</g>
<!-- mObjects -->
<g id="node3" class="node">
<title>mObjects</title>
<polygon fill="none" stroke="#000000" points="7,-7 7,-29 66,-29 66,-7 7,-7"/>
<text text-anchor="start" x="9.6739" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">mObjects</text>
</g>
<!-- mData&#45;&gt;mObjects -->
<!-- objects -->
<g id="node4" class="node">
<title>objects</title>
<polygon fill="none" stroke="#000000" points="397,-7 397,-29 410,-29 410,-7 397,-7"/>
<text text-anchor="start" x="400" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">0</text>
<polygon fill="none" stroke="#000000" points="410,-7 410,-29 423,-29 423,-7 410,-7"/>
<text text-anchor="start" x="413" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">1</text>
<polygon fill="none" stroke="#000000" points="423,-7 423,-29 436,-29 436,-7 423,-7"/>
<text text-anchor="start" x="426" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">2</text>
<polygon fill="none" stroke="#000000" points="436,-7 436,-29 449,-29 449,-7 436,-7"/>
<text text-anchor="start" x="439" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">3</text>
</g>
<!-- mObjects&#45;&gt;objects -->
<g id="edge2" class="edge">
<title>mObjects&#45;&gt;objects</title>
<path fill="none" stroke="#000000" d="M65.8564,-18C172.3993,-18 278.9422,-18 385.4851,-18"/>
<polygon fill="#000000" stroke="#000000" points="385.7957,-21.5001 395.7957,-18 385.7957,-14.5001 385.7957,-21.5001"/>
</g>
<!-- objects&#45;&gt;data -->
<g id="edge3" class="edge">
<title>objects:n&#45;&gt;data:sw</title>
<path fill="none" stroke="#000000" d="M403,-29C403,-29 403,-54.2716 403,-68.8818"/>
<polygon fill="#000000" stroke="#000000" points="399.5001,-69 403,-79 406.5001,-69 399.5001,-69"/>
</g>
</g>
</svg>


<p>可以看到有个flat_binder_object结构体，这个结构体就是通过调用<code>Parcel::writeStrongBinder</code>写入的<code>sp&lt;IBinder&gt;</code>(本例中就是MediaPlayerService)。writeStrongBinder的实现与基本数据结构的写入是有区别的，专门用于承载IBinder对象的传输任务。来看下代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flatten_binder</span>(ProcessState::<span class="built_in">self</span>(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">flatten_binder</span><span class="params">(<span class="type">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">backgroundSchedulingDisabled</span>()) &#123;</span><br><span class="line">        <span class="comment">/* minimum priority for all nodes is nice 0 */</span></span><br><span class="line">        obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* minimum priority for all nodes is MAX_NICE(19) */</span></span><br><span class="line">        obj.flags = <span class="number">0x13</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是Bn端的BBinder，则localBinder会返回对象指针；</span></span><br><span class="line">        <span class="comment">//Bp端的BpBinder没有重写localBinder，所以会返回NULL；</span></span><br><span class="line">        <span class="comment">//此处写入的是MediaPlayerService，是Bn端，所以local返回的就是MediaPlayerService对象</span></span><br><span class="line">        IBinder *local = binder-&gt;<span class="built_in">localBinder</span>();  </span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            <span class="comment">//BpBinder实现了remoteBinder，返回this指针</span></span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//我们向Parcel中写入的是服务端IBinder，走else分支</span></span><br><span class="line">            <span class="comment">//只关重要的3句赋值代码，后面会介绍哪里会用</span></span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">finish_flatten_binder</span>(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flatten_binder函数把IBinder封装成flat_binder_object结构体，然后调用<code>finish_flatten_binder</code>。先看下flat_binder_object结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flat_binder_object结构体定义比较简单，不多介绍。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> &#123;</span><br><span class="line">  __u32 type;  <span class="comment">//在add MediaPlayerService时type=BINDER_TYPE_BINDER</span></span><br><span class="line">  __u32 flags;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">binder_uintptr_t</span> binder;</span><br><span class="line">    __u32 handle;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">binder_uintptr_t</span> cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进入<code>finish_flatten_binder</code>函数看下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\Parcel.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出传入的binder参数没有用到，所以flat_binder_object就是用于传输的数据结构。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">status_t</span> <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*binder*/</span>, <span class="type">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;<span class="built_in">writeObject</span>(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeObject</span><span class="params">(<span class="type">const</span> flat_binder_object&amp; val, <span class="type">bool</span> nullMetaData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enoughData = (mDataPos+<span class="built_in">sizeof</span>(val)) &lt;= mDataCapacity;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enoughObjects = mObjectsSize &lt; mObjectsCapacity;</span><br><span class="line">    <span class="keyword">if</span> (enoughData &amp;&amp; enoughObjects) &#123;</span><br><span class="line">restart_write: <span class="comment">//注意这个goto跳转标记，在Parcel内存不足以保存要写入的数据时，会先去申请内存，然后再跳转回来</span></span><br><span class="line">        <span class="comment">//把刚才的flat_binder_object数据结构保存到mData所指向内存的mDataPos位置</span></span><br><span class="line">        *<span class="built_in">reinterpret_cast</span>&lt;flat_binder_object*&gt;(mData+mDataPos) = val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remember if it&#x27;s a file descriptor</span></span><br><span class="line">        <span class="keyword">if</span> (val.type == BINDER_TYPE_FD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mAllowFds) &#123;</span><br><span class="line">                <span class="comment">// fail before modifying our object index</span></span><br><span class="line">                <span class="keyword">return</span> FDS_NOT_ALLOWED;</span><br><span class="line">            &#125;</span><br><span class="line">            mHasFds = mFdsKnown = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to write meta-data?</span></span><br><span class="line">        <span class="keyword">if</span> (nullMetaData || val.binder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//除了把数据写到mData，还会在mObjects中再记录一下数据的偏移地址mDataPos</span></span><br><span class="line">            mObjects[mObjectsSize] = mDataPos;</span><br><span class="line">            <span class="comment">//也是非常重要的一句代码，会调用cookie-&gt;incStrong，这样对象就不会被释放了</span></span><br><span class="line">            <span class="built_in">acquire_object</span>(ProcessState::<span class="built_in">self</span>(), val, <span class="keyword">this</span>, &amp;mOpenAshmemSize);</span><br><span class="line">            mObjectsSize++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成写入操作，把mDataPos指向新的可写位置，并更新数据大小mDataSize</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">finishWrite</span>(<span class="built_in">sizeof</span>(flat_binder_object));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的代码是在内存不足以存放要写入的数据时来增加内存的</span></span><br><span class="line">    <span class="keyword">if</span> (!enoughData) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> err = <span class="built_in">growData</span>(<span class="built_in">sizeof</span>(val));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!enoughObjects) &#123;</span><br><span class="line">        <span class="type">size_t</span> newSize = ((mObjectsSize+<span class="number">2</span>)*<span class="number">3</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newSize*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>) &lt; mObjectsSize) <span class="keyword">return</span> NO_MEMORY;   <span class="comment">// overflow</span></span><br><span class="line">        <span class="type">binder_size_t</span>* objects = (<span class="type">binder_size_t</span>*)<span class="built_in">realloc</span>(mObjects, newSize*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (objects == <span class="literal">NULL</span>) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        mObjects = objects;</span><br><span class="line">        mObjectsCapacity = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> restart_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Parcel数据结构的拼装就分析完了。但是作为binder传输的数据载体，Parcel的任务还没有结束。继续沿着传输链条向后分析。先来回忆一下数据传输链条：</p>
<ol>
<li><code>BpServiceManager::addService</code>中拼装完Parcel数据结构后，就调用了<code>remote()-&gt;transact</code>，<code>remote()</code>函数返回的就是BpBinder；</li>
<li>BpBinder::transact接收到Parcel后，原封不动的传给了<code>IPCThreadState::self()-&gt;transact</code>;</li>
<li><code>IPCThreadState::self()-&gt;transact</code>会调用<code>IPCThreadState::writeTransactionData</code>把原Parcel数据写入变量名为mOut的Parcel对象中。</li>
</ol>
<p>现在我们再把<code>IPCThreadState::writeTransactionData</code>函数贴出来看下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;  <span class="comment">//target表示发送给谁，handle为0就代表ServiceManager</span></span><br><span class="line">    tr.code = code;  <span class="comment">//code值为ADD_SERVICE_TRANSACTION，就是我们分析的addService</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>(); <span class="comment">//Parcel数据大小</span></span><br><span class="line">        <span class="comment">//ptr.buffer就是Parcel的mData的地址，addService瓶装的Parcel数据都放在以mData为首地址的内存中</span></span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();  <span class="comment">//指向Parcel.mData</span></span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        <span class="comment">//ptr.offsets会指向Parcel的mObjects数组的首地址，数组中存放着flat_binder_object结构体在mData中的偏移</span></span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是把数据写到mOut中，并没有发送出去</span></span><br><span class="line">    <span class="comment">//需要注意下数据结构的转换：把输入的Parcel转换成binder_transaction_data.</span></span><br><span class="line">    <span class="comment">//在IPCThreadState构造函数中mOut设置存储大小是256，binder_transaction_data的大小肯定不会大于256</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);  <span class="comment">//cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传输数据已经写入到mOut表示Parcel类中，我们看下此时的mOut数据：</p>
<!--  -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: parcel_data Pages: 1 -->
<svg width="268pt" height="44pt"
 viewBox="0.00 0.00 268.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>parcel_data</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-40 264,-40 264,4 -4,4"/>
<!-- mData -->
<g id="node1" class="node">
<title>mData</title>
<polygon fill="none" stroke="#000000" points="6,-7 6,-29 49,-29 49,-7 6,-7"/>
<text text-anchor="start" x="8.8415" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">mData</text>
</g>
<!-- data -->
<g id="node2" class="node">
<title>data</title>
<polygon fill="none" stroke="#000000" points="90,-7 90,-29 120,-29 120,-7 90,-7"/>
<text text-anchor="start" x="92.9474" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">cmd</text>
<polygon fill="none" stroke="#000000" points="120,-7 120,-29 260,-29 260,-7 120,-7"/>
<text text-anchor="start" x="122.7468" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">binder_transaction_data</text>
</g>
<!-- mData&#45;&gt;data -->
<g id="edge1" class="edge">
<title>mData:0&#45;&gt;data:0</title>
<path fill="none" stroke="#000000" d="M49.2343,-18C58.3067,-18 69.251,-18 79.9224,-18"/>
<polygon fill="#000000" stroke="#000000" points="80,-21.5001 90,-18 80,-14.5001 80,-21.5001"/>
</g>
</g>
</svg>


<p>来看下<code>binder_transaction_data</code>结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//binder.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_transaction_data</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    __u32 handle; <span class="comment">//handle为0就代表ServiceManager</span></span><br><span class="line">    <span class="type">binder_uintptr_t</span> ptr;</span><br><span class="line">  &#125; target;  <span class="comment">//target表示数据传输的目标</span></span><br><span class="line">  <span class="type">binder_uintptr_t</span> cookie;  <span class="comment">//addService流程设置该值为无效值0</span></span><br><span class="line">  __u32 code;  <span class="comment">//code值为ADD_SERVICE_TRANSACTION，就是我们分析的addService</span></span><br><span class="line">  __u32 flags;</span><br><span class="line">  <span class="type">pid_t</span> sender_pid;</span><br><span class="line">  <span class="type">uid_t</span> sender_euid;</span><br><span class="line">  <span class="type">binder_size_t</span> data_size;  <span class="comment">//Parcel的mData的有效数据大小</span></span><br><span class="line">  <span class="type">binder_size_t</span> offsets_size;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="comment">//buffer指向Parcel的mData所指向的内存地址，注意这里只是内存首地址，</span></span><br><span class="line">      <span class="comment">//并没有进行内存拷贝，当binder驱动收到数据后再通过copy_from_user</span></span><br><span class="line">      <span class="comment">//把用户态的内存拷贝到内核态。这样就减少了一次内存的拷贝，因为即使先拷贝了一次，</span></span><br><span class="line">      <span class="comment">//在驱动中依然要通过copy_from_user进行一次拷贝。</span></span><br><span class="line">      <span class="type">binder_uintptr_t</span> buffer;  </span><br><span class="line">      <span class="type">binder_uintptr_t</span> offsets; <span class="comment">//指向Parcel的mObjects</span></span><br><span class="line">    &#125; ptr;</span><br><span class="line">    __u8 buf[<span class="number">8</span>];</span><br><span class="line">  &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IPCThreadState-waitForResponse"><a href="#IPCThreadState-waitForResponse" class="headerlink" title="IPCThreadState::waitForResponse"></a>IPCThreadState::waitForResponse</h3><p>现在要发送的数据已经写到IPCThreadState::mOut中了，怎么发送出去的呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>; <span class="comment">//talkWithDriver需要重点分析</span></span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:  <span class="comment">//addService成功会收到BR_TRANSACTION_COMPLETE</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IPCThreadState-talkWithDriver"><a href="#IPCThreadState-talkWithDriver" class="headerlink" title="IPCThreadState::talkWithDriver"></a>IPCThreadState::talkWithDriver</h3><p>无比关键的talkWithDriver</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    binder_write_read bwr;  <span class="comment">//又把数据封装成binder_write_read</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();  <span class="comment">//mOut是一个Parcel，write_buffer指向mOut.mData所指向的内存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we&#x27;ll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">//mIn在IPCThreadState构造函数中设置内存大小是256</span></span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//通过系统调用ioctl把addService的请求发送给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.<span class="built_in">dataSize</span>())</span><br><span class="line">                mOut.<span class="built_in">remove</span>(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.<span class="built_in">setDataSize</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addService的客户端的流程就分析到这里。关于binder驱动里面的处理可以分析内核源码，从binder.c的<code>binder_ioctl</code>函数开始分析。<code>binder_ioctl</code>就是系统调用<code>ioctl</code>的执行函数。后续会持续补充…</p>
<h2 id="4-ServiceManager分析"><a href="#4-ServiceManager分析" class="headerlink" title="4. ServiceManager分析"></a>4. ServiceManager分析</h2><h3 id="入口函数-main"><a href="#入口函数-main" class="headerlink" title="入口函数 main"></a>入口函数 main</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\cmds\servicemanager\service_manager.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">selinux_callback</span> cb;</span><br><span class="line">    <span class="type">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">binder_open</span>(driver, <span class="number">128</span>*<span class="number">1024</span>);  <span class="comment">//打开binder设备</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//把自己设置为context_manager(ServiceManager的服务端)</span></span><br><span class="line">    <span class="comment">//该函数的目的就是通过ioctl把设置handle值为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binder_become_context_manager</span>(bs)) &#123;  </span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//selinux相关的一些操作，此处省略，读者有兴趣可以自行分析</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="built_in">binder_loop</span>(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service_manager的main函数主要有3个重要步骤：</p>
<ol>
<li>binder_open打开binder设备；</li>
<li>成为context_manager，也就是ServiceManager；</li>
<li>进入binder_loop；</li>
</ol>
<p>我们一步步进行分析</p>
<h3 id="ServiceManager打开binder设备"><a href="#ServiceManager打开binder设备" class="headerlink" title="ServiceManager打开binder设备"></a>ServiceManager打开binder设备</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_state</span> *<span class="built_in">binder_open</span>(<span class="type">const</span> <span class="type">char</span>* driver, <span class="type">size_t</span> mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_version</span> vers;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC); <span class="comment">//打开binder设备，就是&quot;/dev/binder&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot open %s (%s)\n&quot;</span>,</span><br><span class="line">                driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取驱动版本号，并对比应用和驱动的版本号是否相同</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                <span class="string">&quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot map device (%s)\n&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    <span class="built_in">close</span>(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成为context-manager"><a href="#成为context-manager" class="headerlink" title="成为context_manager"></a>成为context_manager</h3><p>其实就是ServiceManager。通过系统调用ioctl的BINDER_SET_CONTEXT_MGR命令来设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_become_context_manager</span><span class="params">(<span class="keyword">struct</span> binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder驱动中的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux-4.9.243\drivers\android\binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">binder_node</span> *binder_context_mgr_node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        ...</span><br><span class="line">        ret = <span class="built_in">binder_ioctl_set_ctx_mgr</span>(filp);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_ioctl_set_ctx_mgr</span><span class="params">(<span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="type">kuid_t</span> curr_euid = <span class="built_in">current_euid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;BINDER_SET_CONTEXT_MGR already set\n&quot;</span>);</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">security_binder_set_context_mgr</span>(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">uid_valid</span>(binder_context_mgr_uid)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(binder_context_mgr_uid, curr_euid)) &#123;</span><br><span class="line">            <span class="built_in">pr_err</span>(<span class="string">&quot;BINDER_SET_CONTEXT_MGR bad uid %d != %d\n&quot;</span>,</span><br><span class="line">                   <span class="built_in">from_kuid</span>(&amp;init_user_ns, curr_euid),</span><br><span class="line">                   <span class="built_in">from_kuid</span>(&amp;init_user_ns,</span><br><span class="line">                    binder_context_mgr_uid));</span><br><span class="line">            ret = -EPERM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        binder_context_mgr_uid = curr_euid;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_context_mgr_node = <span class="built_in">binder_new_node</span>(proc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成为context_manager就是把ServiceManager进程的信息保存到了binder驱动的binder_context_mgr_node结构体中。想要更深入分析需要了解内核编程，这里暂时就不详细分析了。</p>
<h3 id="binder-loop循环"><a href="#binder-loop循环" class="headerlink" title="binder_loop循环"></a>binder_loop循环</h3><p>然后就进入了<code>binder_loop</code>,该函数的第二个参数非常重要，接收到消息后都是在改函数中进行处理的。先看下<code>binder_loop</code>函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binder_loop</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line">    <span class="type">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//binder主线程？</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="built_in">binder_write</span>(bs, readbuf, <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="built_in">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: ioctl failed (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">binder_parse</span>(bs, <span class="number">0</span>, (<span class="type">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: unexpected reply?!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: io error %d %s\n&quot;</span>, res, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/binder/" rel="tag"># binder</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/31280.html" rel="prev" title="Android Java虚拟机创建过程">
                  <i class="fa fa-angle-left"></i> Android Java虚拟机创建过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/27579.html" rel="next" title="Hexo User Manual">
                  Hexo User Manual <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Jason</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener external nofollow noreferrer" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.24/fancybox/fancybox.umd.js" integrity="sha256-oyhjPiYRWGXaAt+ny/mTMWOnN1GBoZDUQnzzgC7FRI4=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.5.0/mermaid.min.js","integrity":"sha256-K7oJiQlDulzl24ZUFOywuYme1JqBBvQzK6m8qHjt9Gk="}}</script>
  <script type="module" src="/js/zenuml-definition-074a43fa.js"></script>
  <script type="module" src="/js/mermaid-zenuml.esm.min.mjs"></script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
