<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo User Manual</title>
    <url>/posts/27579.html</url>
    <content><![CDATA[<h2 id="VSCode-Hexo"><a href="#VSCode-Hexo" class="headerlink" title="VSCode + Hexo"></a>VSCode + Hexo</h2><h3 id="安装Paste-Image插件"><a href="#安装Paste-Image插件" class="headerlink" title="安装Paste Image插件"></a>安装<a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image">Paste Image</a>插件</h3><p>安装完插件后，通过 <code>Ctrl + Shift + P</code> 快捷键打开setting.json<br><img src="/images/Hexo-User-Manual_2023-08-17-13-48-48.png" alt="Open Settings(JSON)"></p>
<p>然后，在setting.json文件中添加两行配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;pasteImage.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;currentFileNameWithoutExt&#125;/&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;pasteImage.insertPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;% asset_img $&#123;imageFileName&#125; %&#125;&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>然后就可以使用<code>Ctrl + Alt + V</code>快捷键就可以粘贴图片到markdown文档中了。但是这个快捷键不一定好使。也可以通过<code>Ctrl + Shift + P</code>然后输入<code>past image</code>来粘贴。<br>插入的图片采用<code>asset_img</code>语法，关于asset_img详细信息可参考：<a href="https://hexo.io/docs/asset-folders">https://hexo.io/docs/asset-folders</a>。插入的图片将会放到markdown文件同名的文件夹中。</p>
<h3 id="安装Markdown-Preview-Enhanced插件"><a href="#安装Markdown-Preview-Enhanced插件" class="headerlink" title="安装Markdown Preview Enhanced插件"></a>安装<a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">Markdown Preview Enhanced</a>插件</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">Markdown Preview Enhanced</a>插件无法展示使用<code>asset_img</code>插入的图片，需要修改插件的<code>parser.js</code>。通过快捷键<code>Ctrl+Shift+P</code>打开<code>parser.js</code>:<br><img src="/images/Hexo-User-Manual_2023-08-17-13-52-11.png" alt="Extent Parser"><br>然后修改onWillParseMarkdown函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">onWillParseMarkdown</span>: <span class="keyword">function</span>(<span class="params">markdown</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> vscode = <span class="built_in">require</span>(<span class="string">&quot;vscode&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    markdown = markdown.<span class="title function_">replace</span>(</span><br><span class="line">      <span class="regexp">/\&#123;%\s*asset_img\s*(\S+)\s*\S*\s*%\&#125;/g</span>,</span><br><span class="line">      <span class="function">(<span class="params">whole, content</span>) =&gt;</span> &#123;</span><br><span class="line">        abs_filename = vscode.<span class="property">window</span>.<span class="property">activeTextEditor</span>.<span class="property">document</span>.<span class="property">fileName</span></span><br><span class="line">        filename = path.<span class="title function_">basename</span>(abs_filename);</span><br><span class="line">        filename = filename.<span class="title function_">substring</span>(<span class="number">0</span>,filename.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`![](<span class="subst">$&#123;filename + <span class="string">&quot;/&quot;</span>+ content&#125;</span>)`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolve</span>(markdown)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<ul>
<li><a href="https://maple-leaf-0219.github.io/2020/vscode-hexo-markdown%E5%AE%9A%E5%88%B6%E6%80%9D%E8%B7%AF/">vscode hexo markdown定制思路</a></li>
<li><a href="https://yichengsu.github.io/2019/07/Hexo-with-VSCode/">Hexo with VSCode</a></li>
</ul>
<h2 id="主页配置显示文章摘抄"><a href="#主页配置显示文章摘抄" class="headerlink" title="主页配置显示文章摘抄"></a>主页配置显示文章摘抄</h2><p>默认情况下，在主页中会把整个文章都显示了，导致主页特别乱。可以通过在文章中插入下面代码来截取摘抄：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>也可以通过description字段来单独撰写摘抄。</p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>可以通过代码段标签<code>raw</code>来禁止Markdown引擎渲染标签内的内容。</p>
<h2 id="VSCode中预览hexo的图片"><a href="#VSCode中预览hexo的图片" class="headerlink" title="VSCode中预览hexo的图片"></a>VSCode中预览hexo的图片</h2><h2 id="支持-plantuml-画图"><a href="#支持-plantuml-画图" class="headerlink" title="支持 plantuml 画图"></a>支持 plantuml 画图</h2><p><a href="https://github.com/miao1007/hexo-filter-plantuml">hexo-filter-plantuml</a><br>示例：</p>
<img src="\assert\puml\1d53824bd7fa0b3d17aac8c76458f982f27073724b65122619003355855bc71e.svg"/>

<h2 id="支持-GraphViz-画图"><a href="#支持-GraphViz-画图" class="headerlink" title="支持 GraphViz 画图"></a>支持 GraphViz 画图</h2><p>使用<a href="https://github.com/rjyblog/hexo-tag-viz.git">hexo-tag-viz</a>插件来绘制。支持把<code>dot</code>或<code>viz</code>代码块渲染成graphviz图形。<br>可以通过 <code>engine=xxx</code> 来选择不同的渲染引擎。支持的引擎包括 <code>circo</code>，<code>dot</code>，<code>neato</code>，<code>osage</code>，或者 <code>twopi</code>。默认使用 <code>dot</code> 引擎。</p>
<div style="border:1px dotted black; background-color: #F2F3F4; padding: 5px;">
    &#96;&#96;&#96; viz <br>
    digraph { <br>
        A -> {B; C; D} <br>
    } <br>
    &#96;&#96;&#96;
</div>

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %0 Pages: 1 -->
<svg width="206pt" height="116pt"
 viewBox="0.00 0.00 206.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>%0</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-112 202,-112 202,4 -4,4"/>
<!-- A -->
<g id="node1" class="node">
<title>A</title>
<ellipse fill="none" stroke="#000000" cx="99" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="99" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text>
</g>
<!-- B -->
<g id="node2" class="node">
<title>B</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text>
</g>
<!-- A&#45;&gt;B -->
<g id="edge1" class="edge">
<title>A&#45;&gt;B</title>
<path fill="none" stroke="#000000" d="M83.7307,-74.7307C73.803,-64.803 60.6847,-51.6847 49.5637,-40.5637"/>
<polygon fill="#000000" stroke="#000000" points="51.7933,-37.8436 42.2473,-33.2473 46.8436,-42.7933 51.7933,-37.8436"/>
</g>
<!-- C -->
<g id="node3" class="node">
<title>C</title>
<ellipse fill="none" stroke="#000000" cx="99" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="99" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text>
</g>
<!-- A&#45;&gt;C -->
<g id="edge2" class="edge">
<title>A&#45;&gt;C</title>
<path fill="none" stroke="#000000" d="M99,-71.8314C99,-64.131 99,-54.9743 99,-46.4166"/>
<polygon fill="#000000" stroke="#000000" points="102.5001,-46.4132 99,-36.4133 95.5001,-46.4133 102.5001,-46.4132"/>
</g>
<!-- D -->
<g id="node4" class="node">
<title>D</title>
<ellipse fill="none" stroke="#000000" cx="171" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="171" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">D</text>
</g>
<!-- A&#45;&gt;D -->
<g id="edge3" class="edge">
<title>A&#45;&gt;D</title>
<path fill="none" stroke="#000000" d="M114.2693,-74.7307C124.197,-64.803 137.3153,-51.6847 148.4363,-40.5637"/>
<polygon fill="#000000" stroke="#000000" points="151.1564,-42.7933 155.7527,-33.2473 146.2067,-37.8436 151.1564,-42.7933"/>
</g>
</g>
</svg>


<p>通过engine参数指定引擎：</p>
<div style="border:1px dotted black; background-color: #F2F3F4; padding: 5px;">
    &#96;&#96;&#96; viz engine=neato<br>
    digraph { <br>
        A -> {B; C; D} <br>
    } <br>
    &#96;&#96;&#96;
</div>

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %0 Pages: 1 -->
<svg width="186pt" height="176pt"
 viewBox="0.00 0.00 185.76 175.70" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 171.7004)">
<title>%0</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-171.7004 181.7629,-171.7004 181.7629,4 -4,4"/>
<!-- A -->
<g id="node1" class="node">
<title>A</title>
<ellipse fill="none" stroke="#000000" cx="74.8817" cy="-89.712" rx="27" ry="18"/>
<text text-anchor="middle" x="74.8817" y="-85.512" font-family="Times,serif" font-size="14.00" fill="#000000">A</text>
</g>
<!-- B -->
<g id="node2" class="node">
<title>B</title>
<ellipse fill="none" stroke="#000000" cx="150.7629" cy="-101.4894" rx="27" ry="18"/>
<text text-anchor="middle" x="150.7629" y="-97.2894" font-family="Times,serif" font-size="14.00" fill="#000000">B</text>
</g>
<!-- A&#45;&gt;B -->
<g id="edge1" class="edge">
<title>A&#45;&gt;B</title>
<path fill="none" stroke="#000000" d="M101.4213,-93.8312C105.6043,-94.4804 109.9911,-95.1613 114.3509,-95.838"/>
<polygon fill="#000000" stroke="#000000" points="113.9479,-99.3172 124.3664,-97.3925 115.0216,-92.4001 113.9479,-99.3172"/>
</g>
<!-- C -->
<g id="node3" class="node">
<title>C</title>
<ellipse fill="none" stroke="#000000" cx="47.5051" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="47.5051" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text>
</g>
<!-- A&#45;&gt;C -->
<g id="edge2" class="edge">
<title>A&#45;&gt;C</title>
<path fill="none" stroke="#000000" d="M68.1145,-71.9854C64.9982,-63.8223 61.2324,-53.958 57.7769,-44.9065"/>
<polygon fill="#000000" stroke="#000000" points="61.031,-43.6167 54.1945,-35.5227 54.4913,-46.1133 61.031,-43.6167"/>
</g>
<!-- D -->
<g id="node4" class="node">
<title>D</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-149.7004" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-145.5004" font-family="Times,serif" font-size="14.00" fill="#000000">D</text>
</g>
<!-- A&#45;&gt;D -->
<g id="edge3" class="edge">
<title>A&#45;&gt;D</title>
<path fill="none" stroke="#000000" d="M62.0503,-105.7878C57.2199,-111.8396 51.6141,-118.8627 46.3215,-125.4936"/>
<polygon fill="#000000" stroke="#000000" points="43.3697,-123.5812 39.8668,-133.5802 48.8406,-127.948 43.3697,-123.5812"/>
</g>
</g>
</svg>


<!-- 参考：<https://shd101wyy.github.io/markdown-preview-enhanced/#/diagrams?id=graphviz> -->

<h2 id="链接本站文章"><a href="#链接本站文章" class="headerlink" title="链接本站文章"></a>链接本站文章</h2><p>官方介绍：<a href="https://hexo.io/zh-cn/docs/tag-plugins#%E5%BC%95%E7%94%A8%E6%96%87%E7%AB%A0">引用文章</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% post_link android/Android-Activity启动流程 %&#125;</span><br></pre></td></tr></table></figure>

<p>对应的完整路径是：<code>source/_posts/android/Android-Activity启动流程.md</code>。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphViz dot</title>
    <url>/posts/34020.html</url>
    <content><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>在线编译工具：<a href="http://viz-js.com/">http://viz-js.com</a><br>VSCode安装插件：<a href="https://marketplace.visualstudio.com/items?itemName=joaompinto.vscode-graphviz">Graphviz (dot) language support for Visual Studio Code</a><br>命令行：dot，比如，<code>dot -Tpng -ofile.png file.dot</code>可以导出图片。在Ubuntu系统中，通过<code>sudo apt install graphviz</code>安装即可使用。</p>
<p>添加系统环境变量：</p>
<p>GRAPHVIZ_DOT = D:\Program Files\Graphviz\bin\dot.exe</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="http://www.graphviz.org/doc/info/shapes.html">Node Shapes</a><br><a href="https://renenyffenegger.ch/notes/tools/Graphviz/examples/index">Graphviz (dot) examples</a><br><a href="http://www.graphviz.org/doc/info/attrs.html">Node, Edge and Graph Attributes</a></p>
<h2 id="常用属性介绍"><a href="#常用属性介绍" class="headerlink" title="常用属性介绍"></a>常用属性介绍</h2><h3 id="节点（node）属性"><a href="#节点（node）属性" class="headerlink" title="节点（node）属性"></a>节点（node）属性</h3><p>节点的形状主要有三种：<a href="http://www.graphviz.org/doc/info/shapes.html#polygon">Polygon-based Nodes</a>, <a href="http://www.graphviz.org/doc/info/shapes.html#record">Record-based Nodes</a>, <a href="http://www.graphviz.org/doc/info/shapes.html#epsf">User-defined Nodes</a>。点击链接可看到详细介绍。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:shape">shape</a></td>
<td>节点形状，box长方形、circle圆形等，参考<a href="http://www.graphviz.org/doc/info/shapes.html">Node Shapes</a></td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#k:color">color</a></td>
<td>边框颜色</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:style">style</a></td>
<td>节点样式，filled, invisible, diagonals等，参考<a href="http://www.graphviz.org/doc/info/shapes.html#d:style">Styles for Nodes</a></td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:fillcolor">fillcolor</a></td>
<td>填充颜色, 只有在style=filled时才生效</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:fontcolor">fontcolor</a></td>
<td>文字颜色</td>
</tr>
</tbody></table>
<h3 id="边（edge）属性"><a href="#边（edge）属性" class="headerlink" title="边（edge）属性"></a>边（edge）属性</h3><p>边也可以认为就是节点之间的连接线</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:label">label</a></td>
<td>文字描述</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:headlabel">headlabel</a></td>
<td>连接线头部文字描述，比如A -&gt; B, A端是尾部，B端是头部</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:taillabel">taillabel</a></td>
<td>连接线尾部文字描述</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:headport">headport</a></td>
<td>连接线头部指向节点的位置，n(north), s(south), w(west), e(east)</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#a:tailport">tailport</a></td>
<td>连接线尾部指向节点的位置</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#k:color">color</a></td>
<td>连接线颜色</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:fontcolor">labelfontcolor</a></td>
<td>文字颜色，还有fontname和</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:arrowhead">arrowhead</a></td>
<td>箭头样式</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:splines">splines</a></td>
<td>连接线样式，直线、曲线、折线等，splines=false设置为直线。</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:dir">dir</a></td>
<td>连接线方向</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:headclip">headclip</a></td>
<td>连接线头部指向节点边缘或节点中心，默认是边缘</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:tailclip">tailclip</a></td>
<td>连接线尾部指向节点边缘或节点中心，默认是边缘</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:weight">weight</a></td>
<td>连接线布局系数，值越大则线越短、越直、越垂直</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:constraint">constraint</a></td>
<td>为false时，该连接线不用于节点布局的计算</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:decorate">decorate</a></td>
<td>为true时，连接线标签通过下划线附着到连接线上</td>
</tr>
</tbody></table>
<h3 id="图（graph）属性"><a href="#图（graph）属性" class="headerlink" title="图（graph）属性"></a>图（graph）属性</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:rankdir">rankdir</a></td>
<td>图形布局方向，默认TB，表示top -&gt; bottom。值为LR表示left -&gt; right。</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:ranksep">ranksep</a></td>
<td>最小间隔</td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:group">group</a></td>
<td>对节点有效，同组节点的连接线将保持在一个直线方向。<a href="https://stackoverflow.com/questions/19308847/graphviz-vertical-ordering">示例</a></td>
</tr>
<tr>
<td><a href="http://www.graphviz.org/doc/info/attrs.html#d:compound">compound</a></td>
<td>如果为ture，则允许clusters集群之间留出边。默认不允许。</td>
</tr>
</tbody></table>
<h3 id="设置node和edge的默认属性"><a href="#设置node和edge的默认属性" class="headerlink" title="设置node和edge的默认属性"></a>设置node和edge的默认属性</h3><p>node和edge是两个特殊关键字，用于设置默认属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    node [attr=value, ...]</span><br><span class="line">    edge [attr=value, ...]</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多点连线"><a href="#多点连线" class="headerlink" title="多点连线"></a>多点连线</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    node [shape=box]</span><br><span class="line">    A -&gt; &#123;B, C, D&#125; -&gt; E</span><br><span class="line">    node [shape=&quot;&quot;]</span><br><span class="line">    &#123;P, Q&#125; -&gt; &#123;M, N&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %0 Pages: 1 -->
<svg width="350pt" height="188pt"
 viewBox="0.00 0.00 350.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>%0</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 346,-184 346,4 -4,4"/>
<!-- A -->
<g id="node1" class="node">
<title>A</title>
<polygon fill="none" stroke="#000000" points="126,-180 72,-180 72,-144 126,-144 126,-180"/>
<text text-anchor="middle" x="99" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text>
</g>
<!-- B -->
<g id="node2" class="node">
<title>B</title>
<polygon fill="none" stroke="#000000" points="54,-108 0,-108 0,-72 54,-72 54,-108"/>
<text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text>
</g>
<!-- A&#45;&gt;B -->
<g id="edge1" class="edge">
<title>A&#45;&gt;B</title>
<path fill="none" stroke="#000000" d="M80.8314,-143.8314C72.2848,-135.2848 61.9443,-124.9443 52.6198,-115.6198"/>
<polygon fill="#000000" stroke="#000000" points="54.9592,-113.0095 45.4133,-108.4133 50.0095,-117.9592 54.9592,-113.0095"/>
</g>
<!-- C -->
<g id="node3" class="node">
<title>C</title>
<polygon fill="none" stroke="#000000" points="126,-108 72,-108 72,-72 126,-72 126,-108"/>
<text text-anchor="middle" x="99" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text>
</g>
<!-- A&#45;&gt;C -->
<g id="edge2" class="edge">
<title>A&#45;&gt;C</title>
<path fill="none" stroke="#000000" d="M99,-143.8314C99,-136.131 99,-126.9743 99,-118.4166"/>
<polygon fill="#000000" stroke="#000000" points="102.5001,-118.4132 99,-108.4133 95.5001,-118.4133 102.5001,-118.4132"/>
</g>
<!-- D -->
<g id="node4" class="node">
<title>D</title>
<polygon fill="none" stroke="#000000" points="198,-108 144,-108 144,-72 198,-72 198,-108"/>
<text text-anchor="middle" x="171" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">D</text>
</g>
<!-- A&#45;&gt;D -->
<g id="edge3" class="edge">
<title>A&#45;&gt;D</title>
<path fill="none" stroke="#000000" d="M117.1686,-143.8314C125.7152,-135.2848 136.0557,-124.9443 145.3802,-115.6198"/>
<polygon fill="#000000" stroke="#000000" points="147.9905,-117.9592 152.5867,-108.4133 143.0408,-113.0095 147.9905,-117.9592"/>
</g>
<!-- E -->
<g id="node5" class="node">
<title>E</title>
<polygon fill="none" stroke="#000000" points="126,-36 72,-36 72,0 126,0 126,-36"/>
<text text-anchor="middle" x="99" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">E</text>
</g>
<!-- B&#45;&gt;E -->
<g id="edge4" class="edge">
<title>B&#45;&gt;E</title>
<path fill="none" stroke="#000000" d="M45.1686,-71.8314C53.7152,-63.2848 64.0557,-52.9443 73.3802,-43.6198"/>
<polygon fill="#000000" stroke="#000000" points="75.9905,-45.9592 80.5867,-36.4133 71.0408,-41.0095 75.9905,-45.9592"/>
</g>
<!-- C&#45;&gt;E -->
<g id="edge5" class="edge">
<title>C&#45;&gt;E</title>
<path fill="none" stroke="#000000" d="M99,-71.8314C99,-64.131 99,-54.9743 99,-46.4166"/>
<polygon fill="#000000" stroke="#000000" points="102.5001,-46.4132 99,-36.4133 95.5001,-46.4133 102.5001,-46.4132"/>
</g>
<!-- D&#45;&gt;E -->
<g id="edge6" class="edge">
<title>D&#45;&gt;E</title>
<path fill="none" stroke="#000000" d="M152.8314,-71.8314C144.2848,-63.2848 133.9443,-52.9443 124.6198,-43.6198"/>
<polygon fill="#000000" stroke="#000000" points="126.9592,-41.0095 117.4133,-36.4133 122.0095,-45.9592 126.9592,-41.0095"/>
</g>
<!-- P -->
<g id="node6" class="node">
<title>P</title>
<ellipse fill="none" stroke="#000000" cx="243" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="243" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">P</text>
</g>
<!-- M -->
<g id="node8" class="node">
<title>M</title>
<ellipse fill="none" stroke="#000000" cx="243" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="243" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">M</text>
</g>
<!-- P&#45;&gt;M -->
<g id="edge7" class="edge">
<title>P&#45;&gt;M</title>
<path fill="none" stroke="#000000" d="M243,-143.8314C243,-136.131 243,-126.9743 243,-118.4166"/>
<polygon fill="#000000" stroke="#000000" points="246.5001,-118.4132 243,-108.4133 239.5001,-118.4133 246.5001,-118.4132"/>
</g>
<!-- N -->
<g id="node9" class="node">
<title>N</title>
<ellipse fill="none" stroke="#000000" cx="315" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="315" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">N</text>
</g>
<!-- P&#45;&gt;N -->
<g id="edge8" class="edge">
<title>P&#45;&gt;N</title>
<path fill="none" stroke="#000000" d="M258.2693,-146.7307C268.197,-136.803 281.3153,-123.6847 292.4363,-112.5637"/>
<polygon fill="#000000" stroke="#000000" points="295.1564,-114.7933 299.7527,-105.2473 290.2067,-109.8436 295.1564,-114.7933"/>
</g>
<!-- Q -->
<g id="node7" class="node">
<title>Q</title>
<ellipse fill="none" stroke="#000000" cx="315" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="315" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">Q</text>
</g>
<!-- Q&#45;&gt;M -->
<g id="edge9" class="edge">
<title>Q&#45;&gt;M</title>
<path fill="none" stroke="#000000" d="M299.7307,-146.7307C289.803,-136.803 276.6847,-123.6847 265.5637,-112.5637"/>
<polygon fill="#000000" stroke="#000000" points="267.7933,-109.8436 258.2473,-105.2473 262.8436,-114.7933 267.7933,-109.8436"/>
</g>
<!-- Q&#45;&gt;N -->
<g id="edge10" class="edge">
<title>Q&#45;&gt;N</title>
<path fill="none" stroke="#000000" d="M315,-143.8314C315,-136.131 315,-126.9743 315,-118.4166"/>
<polygon fill="#000000" stroke="#000000" points="318.5001,-118.4132 315,-108.4133 311.5001,-118.4133 318.5001,-118.4132"/>
</g>
</g>
</svg>


<h2 id="垂直方向布局"><a href="#垂直方向布局" class="headerlink" title="垂直方向布局"></a>垂直方向布局</h2><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: g Pages: 1 -->
<svg width="117pt" height="260pt"
 viewBox="0.00 0.00 117.00 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<title>g</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-256 113,-256 113,4 -4,4"/>
<!-- B -->
<g id="node1" class="node">
<title>B</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text>
</g>
<!-- C -->
<g id="node2" class="node">
<title>C</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text>
</g>
<!-- B&#45;&gt;C -->
<!-- D -->
<g id="node3" class="node">
<title>D</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">D</text>
</g>
<!-- C&#45;&gt;D -->
<!-- A -->
<g id="node4" class="node">
<title>A</title>
<ellipse fill="none" stroke="#000000" cx="82" cy="-234" rx="27" ry="18"/>
<text text-anchor="middle" x="82" y="-229.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text>
</g>
<!-- A&#45;&gt;B -->
<g id="edge1" class="edge">
<title>A&#45;&gt;B</title>
<path fill="none" stroke="#000000" d="M69.5196,-217.6621C62.4876,-208.4564 53.5653,-196.7764 45.7117,-186.4953"/>
<polygon fill="#000000" stroke="#000000" points="48.2828,-184.0953 39.431,-178.2733 42.72,-188.3446 48.2828,-184.0953"/>
</g>
<!-- A&#45;&gt;C -->
<g id="edge2" class="edge">
<title>A&#45;&gt;C</title>
<path fill="none" stroke="#000000" d="M80.2095,-215.8083C77.9112,-197.1875 72.9655,-167.7008 63,-144 58.6764,-133.7173 52.313,-123.3119 46.134,-114.4164"/>
<polygon fill="#000000" stroke="#000000" points="48.7998,-112.1301 40.0989,-106.0847 43.1307,-116.2365 48.7998,-112.1301"/>
</g>
<!-- A&#45;&gt;D -->
<g id="edge3" class="edge">
<title>A&#45;&gt;D</title>
<path fill="none" stroke="#000000" d="M83.3568,-215.9827C84.4121,-197.7504 85.2162,-168.7923 82,-144 77.7424,-111.1796 76.5858,-102.1784 63,-72 58.421,-61.8285 51.9997,-51.4482 45.8458,-42.5419"/>
<polygon fill="#000000" stroke="#000000" points="48.5295,-40.2781 39.8592,-34.1891 42.8399,-44.356 48.5295,-40.2781"/>
</g>
</g>
</svg>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph g&#123;</span><br><span class="line"> &#123;node[group=a]; B;C;D;&#125;</span><br><span class="line"> A -&gt; B;</span><br><span class="line"> A -&gt; C;</span><br><span class="line"> A -&gt; D;</span><br><span class="line"> B -&gt;C -&gt;D [style=invis];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: g Pages: 1 -->
<svg width="152pt" height="260pt"
 viewBox="0.00 0.00 152.00 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<title>g</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-256 148,-256 148,4 -4,4"/>
<!-- l1 -->
<!-- l2 -->
<!-- l1&#45;&gt;l2 -->
<g id="edge2" class="edge">
<title>l1&#45;&gt;l2</title>
<path fill="none" stroke="#000000" d="M72,-161.9478C72,-159.8016 72,-92.1637 72,-90.0506"/>
</g>
<!-- B2 -->
<g id="node5" class="node">
<title>B2</title>
<ellipse fill="none" stroke="#000000" cx="117" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="117" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">B2</text>
</g>
<!-- l1&#45;&gt;B2 -->
<g id="edge5" class="edge">
<title>l1&#45;&gt;B2</title>
<path fill="none" stroke="#000000" d="M72.3516,-162C74.8042,-162 77.2568,-162 79.7094,-162"/>
<polygon fill="#000000" stroke="#000000" points="79.7924,-165.5001 89.7924,-162 79.7923,-158.5001 79.7924,-165.5001"/>
</g>
<!-- l3 -->
<!-- l2&#45;&gt;l3 -->
<g id="edge3" class="edge">
<title>l2&#45;&gt;l3</title>
<path fill="none" stroke="#000000" d="M72,-89.9478C72,-87.8016 72,-20.1637 72,-18.0506"/>
</g>
<!-- C2 -->
<g id="node7" class="node">
<title>C2</title>
<ellipse fill="none" stroke="#000000" cx="117" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="117" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">C2</text>
</g>
<!-- l2&#45;&gt;C2 -->
<g id="edge7" class="edge">
<title>l2&#45;&gt;C2</title>
<path fill="none" stroke="#000000" d="M72.3516,-90C74.8042,-90 77.2568,-90 79.7094,-90"/>
<polygon fill="#000000" stroke="#000000" points="79.7924,-93.5001 89.7924,-90 79.7923,-86.5001 79.7924,-93.5001"/>
</g>
<!-- D2 -->
<g id="node9" class="node">
<title>D2</title>
<ellipse fill="none" stroke="#000000" cx="117" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="117" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">D2</text>
</g>
<!-- l3&#45;&gt;D2 -->
<g id="edge9" class="edge">
<title>l3&#45;&gt;D2</title>
<path fill="none" stroke="#000000" d="M72.3516,-18C74.8042,-18 77.2568,-18 79.7094,-18"/>
<polygon fill="#000000" stroke="#000000" points="79.7924,-21.5001 89.7924,-18 79.7923,-14.5001 79.7924,-21.5001"/>
</g>
<!-- B1 -->
<g id="node4" class="node">
<title>B1</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">B1</text>
</g>
<!-- B1&#45;&gt;l1 -->
<g id="edge4" class="edge">
<title>B1&#45;&gt;l1</title>
<path fill="none" stroke="#000000" d="M64.274,-162C66.7559,-162 69.2379,-162 71.7198,-162"/>
<polygon fill="#000000" stroke="#000000" points="64.0703,-158.5001 54.0703,-162 64.0703,-165.5001 64.0703,-158.5001"/>
</g>
<!-- C1 -->
<g id="node6" class="node">
<title>C1</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">C1</text>
</g>
<!-- C1&#45;&gt;l2 -->
<g id="edge6" class="edge">
<title>C1&#45;&gt;l2</title>
<path fill="none" stroke="#000000" d="M64.274,-90C66.7559,-90 69.2379,-90 71.7198,-90"/>
<polygon fill="#000000" stroke="#000000" points="64.0703,-86.5001 54.0703,-90 64.0703,-93.5001 64.0703,-86.5001"/>
</g>
<!-- D1 -->
<g id="node8" class="node">
<title>D1</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">D1</text>
</g>
<!-- D1&#45;&gt;l3 -->
<g id="edge8" class="edge">
<title>D1&#45;&gt;l3</title>
<path fill="none" stroke="#000000" d="M64.274,-18C66.7559,-18 69.2379,-18 71.7198,-18"/>
<polygon fill="#000000" stroke="#000000" points="64.0703,-14.5001 54.0703,-18 64.0703,-21.5001 64.0703,-14.5001"/>
</g>
<!-- A -->
<g id="node10" class="node">
<title>A</title>
<ellipse fill="none" stroke="#000000" cx="72" cy="-234" rx="27" ry="18"/>
<text text-anchor="middle" x="72" y="-229.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text>
</g>
<!-- A&#45;&gt;l1 -->
<g id="edge1" class="edge">
<title>A&#45;&gt;l1</title>
<path fill="none" stroke="#000000" d="M72,-215.8314C72,-195.1685 72,-164.0205 72,-162.0939"/>
</g>
</g>
</svg>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph g&#123;</span><br><span class="line"> &#123;node[style=invis, shape=point, width=0, height=0]; l1; l2; l3&#125;</span><br><span class="line"> &#123;rank=same; l1; B1; B2&#125;</span><br><span class="line"> &#123;rank=same; l2; C1; C2&#125;</span><br><span class="line"> &#123;rank=same; l3; D1; D2&#125;</span><br><span class="line"></span><br><span class="line"> A -&gt; l1 -&gt; l2 -&gt; l3 [dir=none]</span><br><span class="line"> B1 -&gt; l1 [dir=back]</span><br><span class="line"> l1 -&gt; B2</span><br><span class="line"> C1 -&gt; l2 [dir=back]</span><br><span class="line"> l2 -&gt; C2</span><br><span class="line"> D1 -&gt; l3 [dir=back]</span><br><span class="line"> l3 -&gt; D2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/19308847/graphviz-vertical-ordering">Graphviz Vertical Ordering</a></li>
<li><a href="https://renenyffenegger.ch/notes/tools/Graphviz/examples/organization-chart">Graphviz example: organization chart</a></li>
</ul>
<h2 id="横向布局示例"><a href="#横向布局示例" class="headerlink" title="横向布局示例"></a>横向布局示例</h2><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: G Pages: 1 -->
<svg width="332pt" height="247pt"
 viewBox="0.00 0.00 332.00 247.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 243)">
<title>G</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-243 328,-243 328,4 -4,4"/>
<g id="clust1" class="cluster">
<title>clusterCG</title>
<polygon fill="none" stroke="#0000ff" points="172,-46 172,-231 242,-231 242,-46 172,-46"/>
<text text-anchor="middle" x="207" y="-214.4" font-family="Times,serif" font-size="14.00" fill="#000000">C</text>
</g>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">1</text>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<text text-anchor="middle" x="117" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">2</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge1" class="edge">
<title>1&#45;&gt;2</title>
<path fill="none" stroke="#000000" d="M54.003,-18C65.2905,-18 78.3867,-18 89.705,-18"/>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<text text-anchor="middle" x="207" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">3</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge2" class="edge">
<title>2&#45;&gt;3</title>
<path fill="none" stroke="#000000" d="M144.003,-18C155.2905,-18 168.3867,-18 179.705,-18"/>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<text text-anchor="middle" x="297" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">4</text>
</g>
<!-- 3&#45;&gt;4 -->
<g id="edge3" class="edge">
<title>3&#45;&gt;4</title>
<path fill="none" stroke="#000000" d="M234.003,-18C245.2905,-18 258.3867,-18 269.705,-18"/>
</g>
<!-- A -->
<g id="node5" class="node">
<title>A</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-180" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-175.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text>
</g>
<!-- A1 -->
<g id="node6" class="node">
<title>A1</title>
<ellipse fill="none" stroke="#000000" cx="117" cy="-180" rx="27" ry="18"/>
<text text-anchor="middle" x="117" y="-175.8" font-family="Times,serif" font-size="14.00" fill="#000000">A1</text>
</g>
<!-- A&#45;&gt;A1 -->
<g id="edge4" class="edge">
<title>A&#45;&gt;A1</title>
<path fill="none" stroke="#000000" d="M54.003,-180C62.0277,-180 70.9665,-180 79.5309,-180"/>
<polygon fill="#000000" stroke="#000000" points="79.7051,-183.5001 89.705,-180 79.705,-176.5001 79.7051,-183.5001"/>
</g>
<!-- A2 -->
<g id="node7" class="node">
<title>A2</title>
<ellipse fill="none" stroke="#000000" cx="207" cy="-180" rx="27" ry="18"/>
<text text-anchor="middle" x="207" y="-175.8" font-family="Times,serif" font-size="14.00" fill="#000000">A2</text>
</g>
<!-- A1&#45;&gt;A2 -->
<g id="edge5" class="edge">
<title>A1&#45;&gt;A2</title>
<path fill="none" stroke="#000000" d="M144.003,-180C152.0277,-180 160.9665,-180 169.5309,-180"/>
<polygon fill="#000000" stroke="#000000" points="169.7051,-183.5001 179.705,-180 169.705,-176.5001 169.7051,-183.5001"/>
</g>
<!-- A3 -->
<g id="node8" class="node">
<title>A3</title>
<ellipse fill="none" stroke="#000000" cx="297" cy="-180" rx="27" ry="18"/>
<text text-anchor="middle" x="297" y="-175.8" font-family="Times,serif" font-size="14.00" fill="#000000">A3</text>
</g>
<!-- A2&#45;&gt;A3 -->
<g id="edge6" class="edge">
<title>A2&#45;&gt;A3</title>
<path fill="none" stroke="#000000" d="M234.003,-180C242.0277,-180 250.9665,-180 259.5309,-180"/>
<polygon fill="#000000" stroke="#000000" points="259.7051,-183.5001 269.705,-180 259.705,-176.5001 259.7051,-183.5001"/>
</g>
<!-- B -->
<g id="node9" class="node">
<title>B</title>
<ellipse fill="none" stroke="#000000" cx="207" cy="-126" rx="27" ry="18"/>
<text text-anchor="middle" x="207" y="-121.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text>
</g>
<!-- C -->
<g id="node10" class="node">
<title>C</title>
<ellipse fill="none" stroke="#000000" cx="207" cy="-72" rx="27" ry="18"/>
<text text-anchor="middle" x="207" y="-67.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text>
</g>
</g>
</svg>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> digraph G &#123;</span><br><span class="line"> newrank=true</span><br><span class="line"> rankdir = LR;</span><br><span class="line"> node [shape = none]</span><br><span class="line"></span><br><span class="line"> 1-&gt;2-&gt;3-&gt;4[arrowhead=none]</span><br><span class="line"></span><br><span class="line"> node [shape = ellipse]</span><br><span class="line"></span><br><span class="line"> A-&gt;A1-&gt;A2-&gt;A3;</span><br><span class="line"></span><br><span class="line"> subgraph clusterCG&#123;</span><br><span class="line">  shape = rect;</span><br><span class="line">  rank=same;</span><br><span class="line"></span><br><span class="line">  A2;</span><br><span class="line">  B;</span><br><span class="line">  C;</span><br><span class="line">  color=blue;</span><br><span class="line">  label=&quot;C&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#123; rank=same; 1; A;&#125;</span><br><span class="line"> &#123; rank=same; 2; A1&#125;</span><br><span class="line"> &#123; rank=same; 3; A2&#125;</span><br><span class="line"> &#123; rank=same; 4; A3;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://stackoverflow.com/questions/13041728/how-to-change-graphviz-subgraph-rank">How to change Graphviz subgraph rank?</a></p>
]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>GraphViz</tag>
      </tags>
  </entry>
  <entry>
    <title>PlantUML样式指南</title>
    <url>/posts/32780962.html</url>
    <content><![CDATA[<h2 id="连接线样式"><a href="#连接线样式" class="headerlink" title="连接线样式"></a>连接线样式</h2><p>连接线的样式支持：bold, plain, dotted，dashed。设置颜色必须可以使用颜色名称，或者16进制的RGB样式，但是必须使用<code>#</code>开头。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A -[dashed,#green]right-&gt; B</span><br><span class="line">A2 -[bold,#ff00ff]-&gt; B2</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\1d83f0e3aaa0ca31270002111ab650ac92c6bdf5031a1905548c83c37805a31a.svg"/>

<p>也可以使用如下写法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A --&gt; B #blue;line.dashed;text:blue : 连接线</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\5902333313b7eacf3b9fca430358cadc4df46e07ad6d3fca8f267298526ac941.svg"/>

<h2 id="调整布局"><a href="#调整布局" class="headerlink" title="调整布局"></a>调整布局</h2><p>PlantUML绘图会自动布局，但是如果想要手动对布局进行调整就很不方便，只能进行微调，没法做到精细的调整。</p>
<h3 id="改变连接线方向"><a href="#改变连接线方向" class="headerlink" title="改变连接线方向"></a>改变连接线方向</h3><p>连接线的方向支持left, right, up, down。也可以通过缩写表示，比如<code>-d-&gt;</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Center -left-&gt; Left</span><br><span class="line">Center -up-&gt; Up</span><br><span class="line">Center -down-&gt; Down</span><br><span class="line">Center -right-&gt; Right</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\dd1296a7e9fc703f388dcaa51de5c46c1ce6d0e3c786d77e35c8bab5bbbd2cc3.svg"/>

<p>但是，当图形比较复杂时，改变方向有时候也无法达到理想的效果。</p>
<h3 id="使用隐藏连接线"><a href="#使用隐藏连接线" class="headerlink" title="使用隐藏连接线"></a>使用隐藏连接线</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[a]</span><br><span class="line">[b]</span><br><span class="line">[c]</span><br><span class="line">[d]</span><br><span class="line">a - b</span><br><span class="line">c - d</span><br><span class="line">a -[hidden]up- c</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\f7f3185725388f1afba9e8585950936de704523a817e8064e0c4415f3d9119f1.svg"/>

<h3 id="together隐含分组"><a href="#together隐含分组" class="headerlink" title="together隐含分组"></a>together隐含分组</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">together &#123;</span><br><span class="line">  [a]</span><br><span class="line">  [b]</span><br><span class="line">&#125;</span><br><span class="line">[c]</span><br><span class="line">a -- b</span><br><span class="line">a -- c</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\68b48294e2e41acd6ec65a6e3dd904ca2d94afed93e6109ca82091ebe1745d4c.svg"/>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.augmentedmind.de/2021/01/17/plantuml-layout-tutorial-styles/">PlantUML layout and styles tutorial</a></p>
]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>PlantUML</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/posts/18133.html</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown语法的标志可以使用#表示，共支持6级标题</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<p>为了美观，也可以采用下面这种对称形式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题 #</span></span><br><span class="line"><span class="section">## 二级标题 ##</span></span><br><span class="line"><span class="section">### 三级标题 ###</span></span><br><span class="line"><span class="section">#### 四级标题 ####</span></span><br><span class="line"><span class="section">##### 五级标题 #####</span></span><br><span class="line"><span class="section">###### 六级标题 ######</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>无序列表</strong> 使用星号（*）、加号（+）或是减号（-）作为列表标记，三种标记符产生的效果完全相同，比如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> Red</span><br><span class="line"><span class="bullet">*</span> Blue</span><br><span class="line"><span class="bullet">*</span> Green</span><br></pre></td></tr></table></figure>

<p>上述文字产生的列表如下：</p>
<ul>
<li>Red</li>
<li>Blue</li>
<li>Green</li>
</ul>
<p><strong>有序列表</strong> 则使用一个数字+英文句点进行表示，如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Red</span><br><span class="line"><span class="bullet">2.</span> Blue</span><br><span class="line"><span class="bullet">3.</span> Green</span><br><span class="line"><span class="bullet">2.</span> Black</span><br></pre></td></tr></table></figure>

<p>很重要的一点是，列表标记上使用的数字并不会影响输出的结果。上述问题显示效果如下：</p>
<ol>
<li>Red</li>
<li>Blue</li>
<li>Green</li>
<li>Black</li>
</ol>
<hr>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>Markdown的代码块使用反向单引号 ` 来标记。如果代码只有一行，可以使用单个 ` 包起来，比如 ` int a =  b + c ; `，显示效果为：<code>int a = b + c;</code><br>对于多行代码，需要使用 ``` 进行包裹，如下：</p>
<div style="border:1px dotted black; background-color: #F2F3F4; padding: 5px;">
&#96;&#96;&#96; <br>
int a = 1; <br>
a += 1; <br>
&#96;&#96;&#96; <br>
</div>

<p>上述文字的显示效果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">a += 1;</span><br></pre></td></tr></table></figure>

<p>另外，代码段也可以使用4个空格开头进行表示。</p>
<p>为代码高亮指定编程语言，可以在```后面加上编程语言来, ``` cpp</p>
<div style="border:1px dotted black; background-color: #F2F3F4; padding: 5px;">
&#96;&#96;&#96; cpp <br>
void main(int argc, char* argv[]) { <br>
    // do something <br>
} <br>
&#96;&#96;&#96;
</div>

<p>上述代码展示效果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://docs.github.com/en/free-pro-team@latest/github/writing-on-github/creating-and-highlighting-code-blocks#syntax-highlighting">GitHub: Syntax highlighting</a></p>
<hr>
<h2 id="文字格式"><a href="#文字格式" class="headerlink" title="文字格式"></a>文字格式</h2><p><code>*斜体*，**粗体**，***粗斜体***，~~删除线~~</code><br>上述文字的显示效果：<em>斜体</em>，<strong>粗体</strong>，**<em>粗斜体**</em>，<del>删除线</del>。需要注意，符号标记和文字之间不能有空格。</p>
<p>文字上标和下标：<code>&lt;sub&gt;下标文字&lt;/sub&gt;  &lt;sup&gt;上标文字&lt;/sup&gt;</code>。效果：这是<sub>下标文字</sub> ，这是 <sup>上标文字</sup>。</p>
<p><strong>字体大小</strong>可以使用html的语法标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">big</span>&gt;</span>大号字体<span class="tag">&lt;/<span class="name">big</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>小号字体<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>字体大小效果：这是<big>大号字体</big>，这是<small>小号字体</small></p>
<p><strong>字体颜色</strong>可以使用html的font标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>This is some text!<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>字体颜色效果：<font color="red">红色文字</font>。</p>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接的格式为：&#91; text &#93;(<a href="http://example.com/">http://example.com</a> “title”)  。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个 [<span class="string">我的主页</span>](<span class="link">https://www.jianshu.com/u/ee2923f61e8d &quot;主页&quot;</span>) 链接示例。</span><br></pre></td></tr></table></figure>

<p>显示效果：这是一个 <a href="https://rjyblog.github.io/" title="主页">我的主页</a> 链接示例。</p>
<p>如果想创建一个本文中章节的链接，需要使用下面格式：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">本文章节</span>](<span class="link">#章节标题</span>)</span><br></pre></td></tr></table></figure>

<p>备注：如果使用vscode编辑markdown，在输入#时会有章节标题的提示，选择即可。</p>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的格式为： !&#91;Alt text&#93;(/path/to/img.jpg “Optional title”) 。</p>
<p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>
</ul>
<hr>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>可以在一行中用三个及以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。下面每种写法都可以建立分隔线 *** ，--- ，___ 。</p>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用使用 &gt; 进行标识。在引用文字结束时，和后面文字间隔一个空行即可结束引用。在引用区块中也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一段引用文字。</span></span><br><span class="line"><span class="quote">&gt; 引用文字的第二句，呵呵呵！</span></span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<blockquote>
<p>这是一段引用文字。<br>引用文字的第二句，呵呵呵！</p>
</blockquote>
<p>引用也支持嵌套，只需要根据需要加上不同数量的 &gt; 即可。</p>
<hr>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格实例如下。注意其中的冒号 : ，可以用于实现居中、左对齐、右对齐的效果。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| name       |  city                 |   deposit       |</span><br><span class="line">|------------|:---------------------:|----------------:|</span><br><span class="line">| Abbi       | Shanghai              |  $1600          |</span><br><span class="line">| Gabriel    | Guangzhou             | $12             |</span><br><span class="line">| Jason      | Beijing               | $1              |</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<table>
<thead>
<tr>
<th>name</th>
<th align="center">city</th>
<th align="right">deposit</th>
</tr>
</thead>
<tbody><tr>
<td>Abbi</td>
<td align="center">Shanghai</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>Gabriel</td>
<td align="center">Guangzhou</td>
<td align="right">$12</td>
</tr>
<tr>
<td>Jason</td>
<td align="center">Beijing</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<p>注意，表格前面要有一个空行。</p>
<hr>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有特殊意义的符号，也就是把特殊符号显示为普通符号。<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">&lt;&gt;  尖括号</span><br><span class="line">()  圆括号</span><br><span class="line"><span class="section">#   井字号</span></span><br><span class="line"><span class="bullet">+</span>   加号</span><br><span class="line"><span class="bullet">-</span>   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br><span class="line">|   竖线</span><br></pre></td></tr></table></figure>

<h3 id="使用Unicode编码"><a href="#使用Unicode编码" class="headerlink" title="使用Unicode编码"></a>使用Unicode编码</h3><p>如果需要在Markdown文档中使用Markdown的保留字符，比如 &#124; &#96; &#91; &#93; 等具有特殊意义的字符时，就需要进行转义，否则文章的展示就会有问题。一般情况可以使用加反斜杠 \ 来进行转义。但是反斜杠并不是所有情况都好使，最彻底的方式就是使用Unicode编码来解决。</p>
<table>
<thead>
<tr>
<th>原字符</th>
<th>Unicode编码</th>
</tr>
</thead>
<tbody><tr>
<td>&#124;</td>
<td><code>&amp;#124;</code></td>
</tr>
<tr>
<td>&#96;</td>
<td><code>&amp;#96;</code></td>
</tr>
<tr>
<td>&#91;</td>
<td><code>&amp;#91;</code></td>
</tr>
<tr>
<td>&#93;</td>
<td><code>&amp;#93;</code></td>
</tr>
<tr>
<td>&#35;</td>
<td><code>&amp;#35;</code></td>
</tr>
</tbody></table>
<p>另外，如果期望输入额外的空格可以使用<code>&amp;#160;</code>。</p>
<p>=&gt; <a href="https://tool.oschina.net/encode">Unicode在线转码</a></p>
<h3 id="禁止超链接"><a href="#禁止超链接" class="headerlink" title="禁止超链接"></a>禁止超链接</h3><p>如果一个url格式的字符串不想展示为超链接的格式，有两种方式可以做到：</p>
<ol>
<li>使用反引号包裹，比如 &#96;www&#xfeff;.baidu.com&#96; , 展示效果为<code>www.baidu.com</code></li>
<li>通过<code>&amp;#xfeff;</code>（<a href="https://www.codetable.net/hex/feff">Zero Width No-Break Space</a>）Unicode编码来把超链接打断，比如 <code>http&amp;#xfeff;://www.baidu.com</code>，展示效果为 http&#xfeff;://<a href="http://www.baidu.com/">www.baidu.com</a></li>
</ol>
<hr>
<h2 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h2><p>插入表情符号的方式有两种：</p>
<ol>
<li>通过复制粘贴的方式插入，比如从<a href="https://emojipedia.org/">Emojipedia</a>网站复制粘贴过来。</li>
<li>插入表情符号的代码，<a href="https://gist.github.com/rxaviers/7360908">https://gist.github.com/rxaviers/7360908</a>这个网站收录的几乎所有的表情符号代码。通过代码的方式插入的表情符号在不同的应用软件上展示效果会有些差异。</li>
</ol>
<hr>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>数学符号使用美元符来包裹，比如<code>$2^n$</code>，显示效果是$2^n$。如果数学表达式中包含markdown的保留字符，则需要使用 <font color=red>$&#96;数学公式&#96;$</font> 的样式。<br>参考文章：<a href="https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions">Writing mathematical expressions</a>、<a href="https://zhuanlan.zhihu.com/p/441454622">MarkDown数学公式</a></p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>Markdown可以支持所有的HTML的符号，参考<a href="https://www.w3schools.com/html/html_symbols.asp">HTML Symbols</a>。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>样式</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;uarr;</code></td>
<td>&uarr;</td>
<td></td>
</tr>
<tr>
<td><code>&amp;darr;</code></td>
<td>&darr;</td>
<td></td>
</tr>
<tr>
<td><code>&amp;larr;</code></td>
<td>&larr;</td>
<td></td>
</tr>
<tr>
<td><code>&amp;rarr;</code></td>
<td>&rarr;</td>
<td></td>
</tr>
<tr>
<td><code>&amp;harr;</code></td>
<td>&harr;</td>
<td>Double headed arrow</td>
</tr>
</tbody></table>
<hr>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>使用<code>* [ ]</code>或者<code>- [ ]</code>两种格式都可以，推荐使用前者：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> [ ] 未完成任务一</span><br><span class="line"><span class="bullet">*</span> [ ] 未完成任务二</span><br><span class="line"><span class="bullet">*</span> [x] 已完成任务</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [ ] 未完成任务一</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成任务二</span><br><span class="line"><span class="bullet">-</span> [x] 已完成任务</span><br></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<ul>
<li><input disabled="" type="checkbox"> 未完成任务一</li>
<li><input disabled="" type="checkbox"> 未完成任务二</li>
<li><input checked="" disabled="" type="checkbox"> 已完成任务</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.markdownguide.org/basic-syntax/">Markdown Guide-Basic Syntax</a></li>
<li><a href="https://docs.github.com/en/free-pro-team@latest/github/writing-on-github/working-with-advanced-formatting">GitHub: Working with advanced formatting</a></li>
<li><a href="https://www.markdownguide.org/hacks/">Workarounds for things not officially supported by Markdown.</a></li>
<li><a href="https://www.jianshu.com/p/q81RER">献给写作者的 Markdown 新手指南</a></li>
<li><a href="http://wowubuntu.com/markdown/#philosophy">Markdown 语法说明</a></li>
<li><a href="https://www.jianshu.com/p/qqGjLN">为什么作家应该用 Markdown 保存自己的文稿</a></li>
<li><a href="https://reimbar.org/dev/arrows/">How to do arrows in Markdown</a></li>
<li><a href="https://www.jianshu.com/p/d63887d0c706">Markdown箭头的输入方法汇总</a></li>
</ul>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>C++成员函数指针</title>
    <url>/posts/63718.html</url>
    <content><![CDATA[<p>对于类的普通成员函数和静态成员函数，定义函数指针的方法是不同的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_normal</span><span class="params">()</span> </span>&#123;      <span class="comment">//普通成员函数</span></span><br><span class="line">        std::cout &lt;&lt; __func__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func_static</span><span class="params">()</span> </span>&#123;    <span class="comment">//静态成员函数（static）</span></span><br><span class="line">        std::cout &lt;&lt; __func__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//g++ -std=c++11 to enable std::function</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pf</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* normal function pointer */</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*pfunc_n)() = <span class="literal">NULL</span>;</span><br><span class="line">    pfunc_n = &amp;Test::func_normal;</span><br><span class="line">    Test t;</span><br><span class="line">    (t.*pfunc_n)();</span><br><span class="line">    <span class="built_in">foo</span>(std::<span class="built_in">bind</span>(&amp;Test::func_normal, &amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* static function pointer */</span></span><br><span class="line">    <span class="built_in">void</span> (*pfunc_s)() = <span class="literal">NULL</span>;</span><br><span class="line">    pfunc_s = &amp;Test::func_static;</span><br><span class="line">    <span class="built_in">pfunc_s</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个非静态成员函数指针作为函数参数，则只能把对象传入函数中，然后通过对象调用函数指针。在C++11中引入了function，其本质也是把类传入了函数。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 构造函数和初始化成员列表</title>
    <url>/posts/17009.html</url>
    <content><![CDATA[<h2 id="类的初始化顺序"><a href="#类的初始化顺序" class="headerlink" title="类的初始化顺序"></a>类的初始化顺序</h2><p>根据ISO/IEC 14882:1998(E) 中12.6.2一节的介绍。</p>
<blockquote>
<p>Initialization shall proceed in the following order:</p>
<ul>
<li>First, and only for the constructor of the most derived class as described below, virtual base classes shall be initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where “left-to-right” is the order of appearance of the base class names in the derived class base-specifier-list.</li>
<li>Then, direct base classes shall be initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).</li>
<li>Then, nonstatic data members shall be initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).</li>
<li>Finally, the body of the constructor is executed.</li>
</ul>
</blockquote>
<p>上面的引用文字我没有完全看懂。但可以大体解释如下：</p>
<ul>
<li>首先，对基类进行初始化；</li>
<li>然后，初始化非静态数据成员。对于在初始化成员列表中的数据成员，编译器会使用列表中的值对数据成员进行初始化；没有出现在初始化成员列表中的数据成员，编译器会按照默认方式进行初始化（如果是类，就是调用类的默认构造函数）；</li>
<li>最后，构造函数体会被执行。</li>
</ul>
<h2 id="初始化成员列表（member-initializer-list）"><a href="#初始化成员列表（member-initializer-list）" class="headerlink" title="初始化成员列表（member initializer list）"></a>初始化成员列表（member initializer list）</h2><p>执行构造函数时，先执行初始化列表的内容，若初始化里面没有数据，则编译器按照系统默认的方式对成员变量赋值，随后再进行构造函数中花括号内部的指令。</p>
<ul>
<li>对于引用型成员变量和const常量型成员变量，则必须通过初始化列表初始化该成员变量。</li>
<li>如果成员类或者基类没有默认构造函数，则必须通过初始化表初始化该成员变量。</li>
<li>成员变量初始化顺序有声明顺序决定，而与初始化列表的顺序无关。</li>
<li>对于参数列表中所列的成员变量，可以不包含所有的成员变量。</li>
</ul>
<p>出于效率方面的考虑：对于有默认构造函数的成员类，编译器会在构建父类之前调用成员类的默认构造函数，如果在构造函数中又对该成员类进行赋值，则该成员类的构造函数调用了两次。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://en.cppreference.com/w/cpp/language/initializer_list">Constructors and member initializer lists</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言参考网站</title>
    <url>/posts/31550.html</url>
    <content><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><hr>
<ul>
<li><a href="http://www.cplusplus.com/reference/">Standard C++ Library reference</a></li>
<li><a href="https://zh.cppreference.com/">C++ 参考手册</a></li>
<li><a href="https://en.wikibooks.org/wiki/C%2B%2B_Programming/All_Chapters">C++ Programming - Wikibooks</a></li>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">C++ Core Guidelines</a> by Bjarne Stroustrup &amp; Herb Sutter</li>
<li><a href="http://www.stroustrup.com/bs_faq2.html">Bjarne Stroustrup’s C++ Style and Technique FAQ</a></li>
<li><a href="https://www.boost.org/">Boost: C++ libraries</a></li>
<li><a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">The Definitive C++ Book Guide and List</a></li>
</ul>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><hr>
<ul>
<li><a href="https://docs.python.org/3/library/index.html#the-python-standard-library" title="Permalink to this headline">The Python Standard Library</a></li>
<li><a href="https://google.github.io/styleguide/pyguide.html">Google Python Style Guide</a></li>
<li><a href="http://www.runoob.com/python3/python3-tutorial.html">Python 3 教程 - 菜鸟教程</a></li>
<li><a href="http://www.runoob.com/python/python-tutorial.html">Python 2 教程 - 菜鸟教程</a></li>
</ul>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><hr>
<ul>
<li><a href="https://developer.android.google.cn/guide?hl=zh_cn">开发者指南</a></li>
<li><a href="https://developer.android.google.cn/reference/">Android API reference</a></li>
<li><a href="https://developer.android.com/guide/platform/">Android Platform Architecture</a></li>
<li><a href="https://developer.android.google.cn/reference/android/media/MediaCodec">MediaCodec</a></li>
<li><a href="https://developer.android.google.cn/training/articles/perf-jni">JNI tips</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>C++</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc编译过程</title>
    <url>/posts/52729.html</url>
    <content><![CDATA[<!-- ![gcc编译过程](/images/gcc编译过程_2023-08-17-13-45-43.png) -->

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %0 Pages: 1 -->
<svg width="617pt" height="44pt"
 viewBox="0.00 0.00 616.91 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>%0</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-40 612.9124,-40 612.9124,4 -4,4"/>
<!-- c -->
<g id="node1" class="node">
<title>c</title>
<polygon fill="none" stroke="#000000" points="54,-36 0,-36 0,0 54,0 54,-36"/>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">hello.c</text>
</g>
<!-- i -->
<g id="node2" class="node">
<title>i</title>
<polygon fill="none" stroke="#000000" points="201.1564,-36 147.1564,-36 147.1564,0 201.1564,0 201.1564,-36"/>
<text text-anchor="middle" x="174.1564" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">hello.i</text>
</g>
<!-- c&#45;&gt;i -->
<g id="edge1" class="edge">
<title>c&#45;&gt;i</title>
<path fill="none" stroke="#000000" d="M54.3341,-18C77.565,-18 111.1389,-18 136.841,-18"/>
<polygon fill="#000000" stroke="#000000" points="136.9687,-21.5001 146.9687,-18 136.9686,-14.5001 136.9687,-21.5001"/>
<text text-anchor="middle" x="100.5782" y="-22.2" font-family="Times,serif" font-size="14.00" fill="#000000">预处理 &#45;E</text>
</g>
<!-- s -->
<g id="node3" class="node">
<title>s</title>
<polygon fill="none" stroke="#000000" points="347.9348,-36 293.9348,-36 293.9348,0 347.9348,0 347.9348,-36"/>
<text text-anchor="middle" x="320.9348" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">hello.s</text>
</g>
<!-- i&#45;&gt;s -->
<g id="edge2" class="edge">
<title>i&#45;&gt;s</title>
<path fill="none" stroke="#000000" d="M201.4203,-18C224.5915,-18 258.0791,-18 283.7153,-18"/>
<polygon fill="#000000" stroke="#000000" points="283.8169,-21.5001 293.8169,-18 283.8169,-14.5001 283.8169,-21.5001"/>
<text text-anchor="middle" x="247.5456" y="-22.2" font-family="Times,serif" font-size="14.00" fill="#000000">编译 &#45;S</text>
</g>
<!-- o -->
<g id="node4" class="node">
<title>o</title>
<polygon fill="none" stroke="#000000" points="488.056,-36 433.0598,-36 433.0598,0 488.056,0 488.056,-36"/>
<text text-anchor="middle" x="460.5579" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">hello.o</text>
</g>
<!-- s&#45;&gt;o -->
<g id="edge3" class="edge">
<title>s&#45;&gt;o</title>
<path fill="none" stroke="#000000" d="M348.187,-18C369.4793,-18 399.3129,-18 422.8895,-18"/>
<polygon fill="#000000" stroke="#000000" points="422.8973,-21.5001 432.8973,-18 422.8972,-14.5001 422.8973,-21.5001"/>
<text text-anchor="middle" x="390.6224" y="-22.2" font-family="Times,serif" font-size="14.00" fill="#000000">汇编 &#45;c</text>
</g>
<!-- e -->
<g id="node5" class="node">
<title>e</title>
<polygon fill="none" stroke="#000000" points="608.9124,-36 554.9124,-36 554.9124,0 608.9124,0 608.9124,-36"/>
<text text-anchor="middle" x="581.9124" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">hello</text>
</g>
<!-- o&#45;&gt;e -->
<g id="edge4" class="edge">
<title>o&#45;&gt;e</title>
<path fill="none" stroke="#000000" d="M488.0951,-18C504.8922,-18 526.5769,-18 544.8666,-18"/>
<polygon fill="#000000" stroke="#000000" points="544.9022,-21.5001 554.9022,-18 544.9022,-14.5001 544.9022,-21.5001"/>
<text text-anchor="middle" x="521.3591" y="-22.2" font-family="Times,serif" font-size="14.00" fill="#000000">链接</text>
</g>
</g>
</svg>


<h2 id="示例如下："><a href="#示例如下：" class="headerlink" title="示例如下："></a>示例如下：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">gcc hello.s -o hello</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 程序内存分段</title>
    <url>/posts/55021.html</url>
    <content><![CDATA[<p><img src="/images/C%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5_2023-08-17-13-44-16.png" alt="内存分段示意图"></p>
<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><p>栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
<h2 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h2><p>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<h2 id="BSS段（bss-segment）"><a href="#BSS段（bss-segment）" class="headerlink" title="BSS段（bss segment）"></a>BSS段（bss segment）</h2><p>BSS（Block Started by Symbol）属于静态内存分配，通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是可读写。</p>
<p>BSS段在磁盘上不是真的占用变量大小的空间，它仅仅记录了变量所需要的大小（占位符），也就是说，在该段中记录了所有未初始化全局变量与局部静态变量的大小总和，至于每个变量的大小则存储在符号表的size属性中。当可执行文件加载运行前，会为BSS段中的变量分配足够的空间并全部自动清零（因此，才有未初始化的全局变量的值为0的说法）。</p>
<p>BSS段主要是为了节省可执行文件在磁盘上所占的空间，对未初始化的大型数组的节省效率比较明显。</p>
<p>默认情况下，编译器会把初始化值为0的变量（比如static int a = 0）放在BSS段。但可以通过“#pragma explicit_zero_data on”把初始值为零的变量放到data段，而不是bss段。</p>
<h2 id="数据段（data-segment）"><a href="#数据段（data-segment）" class="headerlink" title="数据段（data segment）"></a>数据段（data segment）</h2><p>通常是指用来存放程序中已初始化的全局变量的一块内存区域，会占用磁盘文件空间。数据段属于静态内存分配。</p>
<h2 id="只读数据段（read-only-data-segment）"><a href="#只读数据段（read-only-data-segment）" class="headerlink" title="只读数据段（read only data segment）"></a>只读数据段（read only data segment）</h2><p>rodata用于存储使用const修饰的变量，或者只读类型的字符串等。</p>
<h2 id="代码段（code-segment-text-segment）"><a href="#代码段（code-segment-text-segment）" class="headerlink" title="代码段（code segment/text segment）"></a>代码段（code segment/text segment）</h2><p>通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/virtual_func/article/details/48529249">关于BSS段的大小</a></li>
<li><a href="https://blog.csdn.net/jxhui23/article/details/8064766">数据段、代码段、堆栈段、BSS段的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel常用函数算法</title>
    <url>/posts/62746.html</url>
    <content><![CDATA[<h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><h3 id="IP格式字符串截取前两段"><a href="#IP格式字符串截取前两段" class="headerlink" title="IP格式字符串截取前两段"></a>IP格式字符串截取前两段</h3><p>本算法可以适用于192.178.1.1或者1.20.0.7557等格式字符串</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">=<span class="built_in">LEFT</span>(<span class="symbol">C1</span>,<span class="built_in">IFERROR</span>(<span class="built_in">FIND</span>(<span class="string">&quot;.&quot;</span>,<span class="symbol">C1</span>,<span class="built_in">FIND</span>(<span class="string">&quot;.&quot;</span>,<span class="symbol">C1</span>)+<span class="number">1</span>)-<span class="number">1</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>ANR分析</title>
    <url>/posts/45980.html</url>
    <content><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://developer.android.com/topic/performance/vitals/anr">ANRs (Google)</a></li>
<li><a href="http://zenandroid.io/deadlocks-and-anrs/">Deadlocks and ANRs</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android调试</tag>
      </tags>
  </entry>
  <entry>
    <title>APK 反编译</title>
    <url>/posts/24313.html</url>
    <content><![CDATA[<h2 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h2><ul>
<li><a href="https://ibotpeaches.github.io/Apktool/">apktool</a></li>
<li><a href="https://github.com/pxb1988/dex2jar">dex2jar</a></li>
<li><a href="https://github.com/java-decompiler/jd-gui">JD-GUI</a></li>
</ul>
<h2 id="dex转换为jar"><a href="#dex转换为jar" class="headerlink" title="dex转换为jar"></a>dex转换为jar</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d2j-dex2jar.sh -f ~/path/to/apk_to_decompile.apk</span><br></pre></td></tr></table></figure>

<p>生成jar包后，需要使用<a href="https://github.com/java-decompiler/jd-gui">JD-GUI</a>打开查看</p>
<p>在macos上打开JD-GUI可能会报下面错误：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">No suitable Java version found on your system!</span><br><span class="line">This program requires Java 1.8+</span><br><span class="line">Make sure you install the required Java version.</span><br></pre></td></tr></table></figure>

<p>解决方案：在JD-GUI应用程序右击，然后选择“显示包内容”，然后打开<code>Contents/MacOS/universalJavaApplicationStub.sh</code>文件，找到这个报错的打印位置，把JAVA_HOME赋值为jdk home路径即可。</p>
<h2 id="反编译为Smali"><a href="#反编译为Smali" class="headerlink" title="反编译为Smali"></a>反编译为Smali</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar apktool_2.8.1.jar decode -o apk_smali app.apk</span><br></pre></td></tr></table></figure>

<h2 id="提取APK中的资源文件"><a href="#提取APK中的资源文件" class="headerlink" title="提取APK中的资源文件"></a>提取APK中的资源文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar apktool_2.8.1.jar decode app.apk</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://segmentfault.com/a/1190000004703783">apk包的破解与反编译</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用进程启动流程</title>
    <url>/posts/60405.html</url>
    <content><![CDATA[<p>本文基于Android8.0源码。</p>
<h2 id="启动流程图"><a href="#启动流程图" class="headerlink" title="启动流程图"></a>启动流程图</h2><p>点击可以看大图</p>
<img src="\assert\puml\bceee7f8f98a1f5a87e9585d4db2fefcf02b74c433296d3df894ada43a7b8e44.svg"/>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android Activity启动流程</title>
    <url>/posts/11962.html</url>
    <content><![CDATA[<h2 id="startActivity流程"><a href="#startActivity流程" class="headerlink" title="startActivity流程"></a>startActivity流程</h2><img src="\assert\puml\34dd05df4ed54863846b43ec36d5097ed7c99496711c17b18b965704f888be84.svg"/>

<h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><img src="\assert\puml\10384b35e6b81a9def50e5767fa7c2f2642079d383151b0912d9afacc18a73ec.svg"/>

<img src="\assert\puml\372277996184f5ee2932b0cb04c554ba533d7b20753776dc238d62e08afac1cc.svg"/>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>ARouter源码分析</title>
    <url>/posts/23659d3d.html</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><img src="\assert\puml\14839b5514dff2c0a839d51f68c811292e56bd33b5988c7c6384e5efed0b1125.svg"/>

<p>初始化调用时序</p>
<img src="\assert\puml\8c841c6a106cbce011da43e1304cda634eb07e00eb974b6d4ace6c445b68f853.svg"/>

<h2 id="生成路由表"><a href="#生成路由表" class="headerlink" title="生成路由表"></a>生成路由表</h2><p>ARouter是通过在编译阶段使用<a href="https://kotlinlang.org/docs/kapt.html">kapt</a>解析Route注解，再通过<a href="https://github.com/square/javapoet">javapoet</a>来生成路由表相关代码。注解处理器在<code>arouter-compiler/src/main/java/com/alibaba/android/arouter/compiler/processor/RouteProcessor.java</code>。</p>
<p>比如<code>module-kotlin</code>模块有三个activity，路由分别是：</p>
<ul>
<li>/one/first</li>
<li>/one/second</li>
<li>/two/test</li>
</ul>
<p>生成的路由表如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成目录位于module-kotlin/build/generated/source/kapt/debug/com/alibaba/android/arouter/routes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$$Root$$modulekotlin</span> <span class="keyword">implements</span> <span class="title class_">IRouteRoot</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> &#123;</span><br><span class="line">    routes.put(<span class="string">&quot;one&quot;</span>, ARouter$$Group$$one.class);</span><br><span class="line">    routes.put(<span class="string">&quot;two&quot;</span>, ARouter$$Group$$two.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$$Group$$one</span> <span class="keyword">implements</span> <span class="title class_">IRouteGroup</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class="line">    atlas.put(<span class="string">&quot;/one/first&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, FistActivity.class, <span class="string">&quot;/one/first&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/one/second&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, SecondActivity.class, <span class="string">&quot;/one/second&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$$Group$$two</span> <span class="keyword">implements</span> <span class="title class_">IRouteGroup</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class="line">    atlas.put(<span class="string">&quot;/two/test&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, TestActivity.class, <span class="string">&quot;/two/test&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译自动生成的代码包含一个Root（<code>IRouteRoot</code>）和两个Group（<code>IRouteGroup</code>）。Root是module模块下路由表入口类，使用模块名称命名生成类<code>ARouter$$Root$$modulekotlin</code>。Group是二级路由路径的第一级<small>（/one/first中的one）</small>，本例中分别是one和two，分别对应类<code>ARouter$$Group$$one</code>和<code>ARouter$$Group$$two</code>，每个Group类下面才是真正的路由。</p>
<p>从代码中可以看出来<code>ARouter$$Root$$modulekotlin</code>会把两个Group对应的class添加到group列表中。那么，<code>com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin#loadInto</code>方法什么时候被执行呢？代码中找不到调用的地方，实际上是在<code>LogisticsCenter#loadRouterMap</code>方法中调用，这个方法会在编译期间动态插入代码。见<a href="#asm%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5">下一节</a>介绍。</p>
<p>备注：<a href="https://kotlinlang.org/docs/kapt.html">kapt</a>相当于java apt，kapt同时支持kotlin和java代码的注解。kapt生成的代码在<code>module-kotlin/build/generated/source/kapt</code>目录下，apt生成的代码在<code>module-java/build/generated/ap_generated_sources</code>目录下。</p>
<h2 id="ASM代码注入"><a href="#ASM代码注入" class="headerlink" title="ASM代码注入"></a>ASM代码注入</h2><p>在ARouter初始化流程中会调用<code>com.alibaba.android.arouter.core.LogisticsCenter#loadRouterMap</code>方法，该方法负责填充Group表。原始代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogisticsCenter.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRouterMap</span><span class="params">()</span> &#123;</span><br><span class="line">        registerByPlugin = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// auto generate register code by gradle plugin: arouter-auto-register</span></span><br><span class="line">        <span class="comment">// looks like below:</span></span><br><span class="line">        <span class="comment">// registerRouteRoot(new ARouter..Root..modulejava());</span></span><br><span class="line">        <span class="comment">// registerRouteRoot(new ARouter..Root..modulekotlin());</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法中没有任何注册逻辑。实际上这个方法会在编译期间通过<a href="https://asm.ow2.io/asm4-guide.pdf">ASM</a>来修改方法的实现。ASM注入代码后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogisticsCenter.class</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRouterMap</span><span class="params">()</span> &#123;</span><br><span class="line">    registerByPlugin = <span class="literal">false</span>;</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码注入在arouter-gradle-plugin插件中实现，代码对应在<code>arouter-gradle-plugin/src/main/groovy/com/alibaba/android/arouter/register/launch/PluginLaunch.groovy</code>文件中，插件会注册一个RegisterTransform，这个Transform会在<code>*.class</code>转换成dex文件之前运行。</p>
<p>注入的代码是调用register函数，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogisticsCenter.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                <span class="comment">//1.通过反射调用类构造方法</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getConstructor().newInstance(); </span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IRouteRoot) &#123;</span><br><span class="line">                    registerRouteRoot((IRouteRoot) obj);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IProviderGroup) &#123;</span><br><span class="line">                    registerProvider((IProviderGroup) obj);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IInterceptorGroup) &#123;</span><br><span class="line">                    registerInterceptor((IInterceptorGroup) obj);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;register failed, class name: &quot;</span> + className</span><br><span class="line">                            + <span class="string">&quot; should implements one of IRouteRoot/IProviderGroup/IInterceptorGroup.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(TAG,<span class="string">&quot;register class error:&quot;</span> + className, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerRouteRoot</span><span class="params">(IRouteRoot routeRoot)</span> &#123;</span><br><span class="line">        markRegisteredByPlugin();</span><br><span class="line">        <span class="keyword">if</span> (routeRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.调用loadInto方法</span></span><br><span class="line">            routeRoot.loadInto(Warehouse.groupsIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看到先通过反射方式创建<code>com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin</code>类的实例对象，然后调用它的loadInto方法。最终效果是group被注册到<code>Warehouse.groupsIndex</code>这个map中，相当于下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Warehouse.groupsIndex.put(<span class="string">&quot;kotlin&quot;</span>, ARouter$$Group$$kotlin.class)</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 如果期望编译时打印代码注入相关的日志，可以使用下面命令行进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gradlew clean &amp;&amp; ./gradlew -i :app:assembleDebug | tee build_log.txt</span><br></pre></td></tr></table></figure>

<h2 id="路由查找"><a href="#路由查找" class="headerlink" title="路由查找"></a>路由查找</h2><p>ARouter初始化完成之后，如果没有发生路由跳转，路由表就还是空的，但group表是有数据。当发生路由跳转时，会首先查找路由表，由于是首次跳转，路由表中找不到路由，就会在group表中查找路由对应的group类，把这个group下面的所有路由注册到路由表，然后再进行跳转。当下次再跳转时路由表中就存在对应的路由了。</p>
<img src="\assert\puml\0fa0483c755ccb731d00fdb245db3433900ef3e77be044d71e3e92c8d6fb9bdc.svg"/>

<p>我们通过跳转路由名为<code>/kotlin/test</code>的activity来介绍一下源码实现。使用下面方法打开activity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">&quot;/kotlin/test&quot;</span>).navigation();</span><br></pre></td></tr></table></figure>

<p>navigation有好几个重载方法，最终都会走到下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ARouter</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">navigation</span><span class="params">(Context mContext, Postcard postcard, <span class="type">int</span> requestCode, NavigationCallback callback)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//_ARouter.java</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="type">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Set context to postcard.</span></span><br><span class="line">        postcard.setContext(<span class="literal">null</span> == context ? mContext : context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LogisticsCenter.completion(postcard); <span class="comment">//执行上面流程图的逻辑，代码就不贴了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != callback) &#123;</span><br><span class="line">            callback.onFound(postcard);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">            interceptorService.doInterceptions(postcard, <span class="keyword">new</span> <span class="title class_">InterceptorCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContinue</span><span class="params">(Postcard postcard)</span> &#123;</span><br><span class="line">                    _navigation(postcard, requestCode, callback);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInterrupt</span><span class="params">(Throwable exception)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != callback) &#123;</span><br><span class="line">                        callback.onInterrupt(postcard);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    logger.info(Consts.TAG, <span class="string">&quot;Navigation failed, termination by interceptor : &quot;</span> + exception.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _navigation(postcard, requestCode, callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">_navigation</span><span class="params">(<span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="type">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">currentContext</span> <span class="operator">=</span> postcard.getContext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">                <span class="comment">// Build intent</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(currentContext, postcard.getDestination());</span><br><span class="line">                intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set flags.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> postcard.getFlags();</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != flags) &#123;</span><br><span class="line">                    intent.setFlags(flags);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Non activity, need FLAG_ACTIVITY_NEW_TASK</span></span><br><span class="line">                <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;</span><br><span class="line">                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set Actions</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> postcard.getAction();</span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(action)) &#123;</span><br><span class="line">                    intent.setAction(action);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Navigation in main looper.</span></span><br><span class="line">                runInMainThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        startActivity(requestCode, currentContext, intent, postcard, callback);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>找到路由<code>/kotlin/test</code>对应的group类后（本例中对应<code>ARouter$$Group$$kotlin.class</code>），就会利用反射调用group类的初始化，然后调用其loadInto方法将路由注册到路由表<code>Warehouse#routes</code>中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogisticsCenter</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//本例中groupName=&quot;kotlin&quot;，group=null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addRouteGroupDynamic</span><span class="params">(String groupName, IRouteGroup group)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Warehouse.groupsIndex.containsKey(groupName))&#123;</span><br><span class="line">            <span class="comment">//利用反射调用group类的构造方法，然后调用loadInto方法</span></span><br><span class="line">            Warehouse.groupsIndex.get(groupName).getConstructor().newInstance().loadInto(Warehouse.routes);</span><br><span class="line">            <span class="comment">//将对应的group类在group表中删除，因为路由注册到路由表后，group类就可以回收了</span></span><br><span class="line">            Warehouse.groupsIndex.remove(groupName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cover old group.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != group) &#123;</span><br><span class="line">            group.loadInto(Warehouse.routes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6914485867029463054">一文学会Android Gradle Transform基础使用</a><br><a href="https://cloud.tencent.com/developer/article/1920027">Android APK编译流程</a><br><a href="https://zhuanlan.zhihu.com/p/263806589">AOP 利器 ——ASM 基础入门</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Jni开发指南</title>
    <url>/posts/936e646.html</url>
    <content><![CDATA[<h2 id="现有项目添加C-C-源码"><a href="#现有项目添加C-C-源码" class="headerlink" title="现有项目添加C/C++源码"></a>现有项目添加C/C++源码</h2><p>如果现有项目还不支持C/C++，则可以通过如下步骤来加入C/C++</p>
<p><img src="/images/Android/Android-Jni%E6%8C%87%E5%8D%97_2023-10-19-19-01-13.png" alt="Add C++ to Module"></p>
<p>然后按照步骤操作即可。添加完成后打开<code>app\src\main\cpp\CMakeLists.txt</code>文件，修改项目名称</p>
<h2 id="Java-Kotlin代码声明native函数"><a href="#Java-Kotlin代码声明native函数" class="headerlink" title="Java/Kotlin代码声明native函数"></a>Java/Kotlin代码声明native函数</h2><p>我们在<code>me.rjy.android.demo.MainActivity</code>中定义一个native函数，并加载native库。</p>
<p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">()</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;demo&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义jni函数"><a href="#定义jni函数" class="headerlink" title="定义jni函数"></a>定义jni函数</h2><p>当Java代码中执行native函数时，虚拟机需要找到so库中相对应的函数符号。因此，我们在定义jni函数时，需要将函数注册到虚拟机中。</p>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册会严格限制jni函数的命名。jni函数命名规则：<code>Java_包名_类名_方法名</code>，其中包名中的<code>.</code>要替换为下滑杠<code>_</code>。如果函数名称不符合规范，在运行时就会抛出<code>java.lang.UnsatisfiedLinkError: No implementation found for ...</code>的异常。</p>
<p>因为<code>stringFromJNI</code>函数在<code>me.rjy.android.demo.MainActivity</code>进行声明，所以定义的native函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT </span></span><br><span class="line"><span class="function">jstring JNICALL <span class="title">Java_me_rjy_android_demo_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>JNIEXPORT</code>和<code>JNICALL</code>两个宏定义，虚拟机在加载so库时，就会把该函数与java代码的native函数进行绑定。</p>
<p>静态注册的优点时代码量很少，缺点是要严格遵守命名规范，而且函数命名很长。</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jstring <span class="title">stringFromJNI</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以同时在数组中注册多个jni函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod sMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;stringFromJNI&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *) stringFromJNI&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">registerNativeMethods</span><span class="params">(JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *className,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> JNINativeMethod *gMethods, <span class="type">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    jclass clazz = env-&gt;<span class="built_in">FindClass</span>(className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">RegisterNatives</span>(clazz, gMethods, numMethods) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *jvm, <span class="type">void</span> *)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (jvm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **) &amp;env, JNI_VERSION_1_6)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">registerNativeMethods</span>(env, <span class="string">&quot;me/rjy/android/demo/MainActivity&quot;</span>,</span><br><span class="line">                              sMethods, <span class="built_in">NELEM</span>(sMethods)) == JNI_FALSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态注册的代码要比静态注册多很多，这是动态注册的缺点。动态注册的一个关键点是函数的签名，这个非常容易出错，有一个直观的方法可以直接拿到函数签名：通过<a href="/posts/24313.html" title="APK 反编译">APK 反编译</a>介绍的方法，把apk中的类反编译为smali，然后找到对应的<code>MainActivity.smali</code>，smali文件中就可以找到对应的函数定义：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> final</span> native stringFromJNI()<span class="class">Ljava/lang/String;</span><span class="keyword"></span></span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<p>其中<code>()Ljava/lang/String;</code>就是函数签名，<code>()</code>表示无参函数，<code>Ljava/lang/String;</code>表示返回一个String类型。</p>
<h2 id="Android-JNI打印logcat日志"><a href="#Android-JNI打印logcat日志" class="headerlink" title="Android JNI打印logcat日志"></a>Android JNI打印logcat日志</h2><p>在c/c++文件中引入头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后再需要打印日志的地方通过<code>__android_log_print</code>来打印日志即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__android_log_print(ANDROID_LOG_DEBUG, <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;value=%d&quot;</span>, value);</span><br></pre></td></tr></table></figure>

<p>可以对<code>__android_log_print</code>进行封装，比如<code>Log.d(...)/Log.i(..)</code>形式，在使用的时候会更加便捷。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface Specification Contents</a><br><a href="https://www.baeldung.com/jni">Guide to JNI (Java Native Interface)</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jni</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View Measure源码分析</title>
    <url>/posts/d01e7370.html</url>
    <content><![CDATA[<p>在<a href="/posts/11962.html" title="Android Activity启动流程">Android Activity启动流程</a>文章中已经介绍了，在activity的onResume之后，<code>ViewRootImpl#setView(View view, WindowManager.LayoutParams attrs, ...)</code>，其中view就是DecorView，ViewRootImpl#setView中就会调用<code>requestLayout</code>，然后调用<code>scheduleTraversals</code>。这是首次调用，后续view的改动都会调用到<code>scheduleTraversals</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\java\android\view\ViewRootImpl.java</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//添加同步屏障，主线程的同步消息都会进制执行，保证vsync信号到来时TraversalRunnable能够立刻被执行</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//删除同步屏障</span></span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android UI 绘制流程</title>
    <url>/posts/c09f2087.html</url>
    <content><![CDATA[<h2 id="measure-流程"><a href="#measure-流程" class="headerlink" title="measure 流程"></a>measure 流程</h2><p>measure结果放在<code>mMeasuredWidth</code>和<code>mMeasuredHeight</code>中。</p>
<h2 id="layout-流程"><a href="#layout-流程" class="headerlink" title="layout 流程"></a>layout 流程</h2><p>layout的作用是计算view及其view的大小和位置，</p>
<h2 id="draw-流程"><a href="#draw-流程" class="headerlink" title="draw() 流程"></a>draw() 流程</h2><p>入口：ViewRootImpl#draw</p>
<h3 id="没有开启硬件加速"><a href="#没有开启硬件加速" class="headerlink" title="没有开启硬件加速"></a>没有开启硬件加速</h3><p>执行drawSoftware方法。</p>
<ol>
<li>获取Canvas：canvas = mSurface.lockCanvas(dirty);</li>
<li>执行View#draw：mView.draw(canvas);</li>
<li>surface.unlockCanvasAndPost(canvas);</li>
</ol>
<p>执行<code>android-12.1.0_r27\frameworks\base\core\jni\android_view_Surface.cpp</code>的nativeUnlockCanvasAndPost方法</p>
<h3 id="开启了硬件加速"><a href="#开启了硬件加速" class="headerlink" title="开启了硬件加速"></a>开启了硬件加速</h3><p>最终会通过RenderThread进行渲染<code>ViewRootImpl#draw</code>中调用<code>mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this);</code></p>
<p><img src="/images/Android/RenderThread%E7%B1%BB%E5%9B%BE.drawio.svg" alt="RenderThread类图"></p>
<img src="\assert\puml\a2609f9a24281980efa2d633714b309d2a804e8c5bd095293bf1a8ab4c05d48e.svg"/>

<img src="\assert\puml\34e7821a5de7dca39e750acd8af70d8acd45b77d2ea011476ce5e7163cb3ab8c.svg"/>

<h3 id="RenderThread如何启动运行"><a href="#RenderThread如何启动运行" class="headerlink" title="RenderThread如何启动运行"></a>RenderThread如何启动运行</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">RenderThread&amp; <span class="title">RenderThread::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    [[clang::no_destroy]] <span class="type">static</span> sp&lt;RenderThread&gt; sInstance = []() &#123;</span><br><span class="line">        sp&lt;RenderThread&gt; thread = sp&lt;RenderThread&gt;::<span class="built_in">make</span>();</span><br><span class="line">        thread-&gt;<span class="built_in">start</span>(<span class="string">&quot;RenderThread&quot;</span>);  <span class="comment">//开始执行threadLoop</span></span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;();</span><br><span class="line">    gHasRenderThreadInstance = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> *sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RenderThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</span><br><span class="line">    Looper::<span class="built_in">setForThread</span>(mLooper);</span><br><span class="line">    <span class="keyword">if</span> (gOnStartHook) &#123;</span><br><span class="line">        <span class="built_in">gOnStartHook</span>(<span class="string">&quot;RenderThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">initThreadLocals</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//loop forever</span></span><br><span class="line">        <span class="built_in">waitForWork</span>();</span><br><span class="line">        <span class="built_in">processQueue</span>(); <span class="comment">//执行WorkQueue中的任务</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.<span class="built_in">size</span>() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            mVsyncSource-&gt;<span class="built_in">drainPendingEvents</span>();</span><br><span class="line">            mFrameCallbacks.<span class="built_in">insert</span>(mPendingRegistrationFrameCallbacks.<span class="built_in">begin</span>(),</span><br><span class="line">                                   mPendingRegistrationFrameCallbacks.<span class="built_in">end</span>());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="built_in">requestVsync</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Clean this up. This is working around an issue where a combination</span></span><br><span class="line">            <span class="comment">// of bad timing and slow drawing can result in dropping a stale vsync</span></span><br><span class="line">            <span class="comment">// on the floor (correct!) but fails to schedule to listen for the</span></span><br><span class="line">            <span class="comment">// next vsync (oops), so none of the callbacks are run.</span></span><br><span class="line">            <span class="built_in">requestVsync</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会生成一个RecordingCanvas来记录所有的绘制步骤：</p>
<p><img src="/images/Android/Canvas%E7%B1%BB%E5%9B%BE.drawio.svg" alt="Canvas类图"></p>
<p>在使用硬件加速时，onDraw的canvas实际上是RecordingCanvas。RecordingCanvas最终的产物是DisplayList，然后交给RenderThread去执行真正的绘制流程。</p>
<h2 id="附录一：Canvas-Java层与Native源码对应关系"><a href="#附录一：Canvas-Java层与Native源码对应关系" class="headerlink" title="附录一：Canvas Java层与Native源码对应关系"></a>附录一：Canvas Java层与Native源码对应关系</h2><p>本节从源码角度说明了Java层的Canvas与Native层函数之间的对应关系。</p>
<ol>
<li><p><code>android.graphics.Canvas</code>、<code>android.graphics.BaseCanvas</code>、<code>android.graphics.BaseRecordingCanvas</code>这三个类中的jni方法都在<code>frameworks\base\libs\hwui\jni\android_graphics_Canvas.cpp</code>中定义：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_android_graphics_Canvas</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret |= <span class="built_in">RegisterMethodsOrDie</span>(env, <span class="string">&quot;android/graphics/Canvas&quot;</span>, gMethods, <span class="built_in">NELEM</span>(gMethods));</span><br><span class="line">    ret |= <span class="built_in">RegisterMethodsOrDie</span>(env, <span class="string">&quot;android/graphics/BaseCanvas&quot;</span>, gDrawMethods, <span class="built_in">NELEM</span>(gDrawMethods));</span><br><span class="line">    ret |= <span class="built_in">RegisterMethodsOrDie</span>(env, <span class="string">&quot;android/graphics/BaseRecordingCanvas&quot;</span>, gDrawMethods, <span class="built_in">NELEM</span>(gDrawMethods));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>android.graphics.RecordingCanvas</code>对应的jni方法在<code>frameworks\base\libs\hwui\jni\android_graphics_DisplayListCanvas.cpp</code>中定义;</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kClassPathName = <span class="string">&quot;android/graphics/RecordingCanvas&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_android_view_DisplayListCanvas</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    jclass runnableClass = <span class="built_in">FindClassOrDie</span>(env, <span class="string">&quot;java/lang/Runnable&quot;</span>);</span><br><span class="line">    gRunnableMethodId = <span class="built_in">GetMethodIDOrDie</span>(env, runnableClass, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(env, kClassPathName, gMethods, <span class="built_in">NELEM</span>(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>native Canvas对应的是<code>SkiaRecordingCanvas</code>，创建代码对应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\graphics\java\android\graphics\RecordingCanvas.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">RecordingCanvas</span><span class="params">(<span class="meta">@NonNull</span> RenderNode node, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height));</span><br><span class="line">        mDensity = <span class="number">0</span>; <span class="comment">// disable bitmap density scaling</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@CriticalNative</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nCreateDisplayListCanvas</span><span class="params">(<span class="type">long</span> node, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br></pre></td></tr></table></figure>

<p>RecordingCanvas构造函数中调用了native函数nCreateDisplayListCanvas，并最终将结果赋值给了父类<code>Canvas#mNativeCanvasWrapper</code>变量，这个变量存储的就是native层的Canvas对象指针，对应c++层<code>SkiaRecordingCanvas</code>类。<code>nCreateDisplayListCanvas</code>源码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android\android-12.1.0_r27\frameworks\base\libs\hwui\jni\android_graphics_DisplayListCanvas.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="params">(CRITICAL_JNI_PARAMS_COMMA jlong renderNodePtr,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint width, jint height)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="built_in">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(Canvas::<span class="built_in">create_recording_canvas</span>(width, height, renderNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//android\android-12.1.0_r27\frameworks\base\libs\hwui\hwui\Canvas.cpp</span></span><br><span class="line"><span class="function">Canvas* <span class="title">Canvas::create_recording_canvas</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, uirenderer::RenderNode* renderNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::skiapipeline::<span class="built_in">SkiaRecordingCanvas</span>(renderNode, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例：drawCircle"><a href="#示例：drawCircle" class="headerlink" title="示例：drawCircle"></a>示例：drawCircle</h3><p><strong>Java层drawCircle</strong></p>
<p>比如我们在View的onDraw函数中画一个圆，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">   mPaint.setColor(getResources().getColor(R.color.red));</span><br><span class="line">   canvas.drawCircle(<span class="number">50f</span>, <span class="number">50f</span>, <span class="number">10f</span>, mPaint); <span class="comment">//void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onDraw函数的canvas参数实际上是<code>RecordingCanvas</code>类。因为RecordingCanvas没有重写这个drawCircle函数，所以调用的父类<code>BaseRecordingCanvas</code>的drawCircle函数及其对应的jni函数<code>nDrawCircle</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\graphics\java\android\graphics\BaseRecordingCanvas.java</span></span><br><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nDrawCircle</span><span class="params">(<span class="type">long</span> nativeCanvas, <span class="type">float</span> cx, <span class="type">float</span> cy, <span class="type">float</span> radius, <span class="type">long</span> nativePaint)</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">float</span> cx, <span class="type">float</span> cy, <span class="type">float</span> radius, <span class="meta">@NonNull</span> Paint paint)</span> &#123;</span><br><span class="line">    nDrawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.getNativeInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Native层drawCircle</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\libs\hwui\jni\android_graphics_Canvas.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> Canvas* <span class="title">get_canvas</span><span class="params">(jlong canvasHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Canvas*&gt;(canvasHandle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">drawCircle</span><span class="params">(JNIEnv* env, jobject, jlong canvasHandle, jfloat cx, jfloat cy,</span></span></span><br><span class="line"><span class="params"><span class="function">                       jfloat radius, jlong paintHandle)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Paint* paint = <span class="built_in">reinterpret_cast</span>&lt;Paint*&gt;(paintHandle);</span><br><span class="line">    <span class="built_in">get_canvas</span>(canvasHandle)-&gt;<span class="built_in">drawCircle</span>(cx, cy, radius, *paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>canvasHandle就是mNativeCanvasWrapper，对应C++的<code>SkiaRecordingCanvas</code>类。SkiaRecordingCanvas中并没有复写drawCirle(其实也有一个drawCircle但是参数签名不匹配)，所以调用父类SkiaCanvas的drawCircle函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkiaCanvas::drawCircle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> radius, <span class="type">const</span> Paint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(radius &lt;= <span class="number">0</span> || paint.<span class="built_in">nothingToDraw</span>())) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">applyLooper</span>(&amp;paint, [&amp;](<span class="type">const</span> SkPaint&amp; p) &#123; mCanvas-&gt;<span class="built_in">drawCircle</span>(x, y, radius, p); &#125;); <span class="comment">//调用mCanvas-&gt;drawCircle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SkCanvas* SkiaCanvas::mCanvas</code>成员变量是在子类SkiaRecordingCanvas初始化过程中通过调用<code>SkiaCanvas::reset(&amp;mRecorder);</code>来设置，mCanvas是<code>RecordingCanvas</code>。也就是说RecordingCanvas是SkCanvas的子类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecordingCanvas</span> <span class="keyword">final</span> : <span class="keyword">public</span> SkCanvasVirtualEnforcer&lt;SkNoDrawCanvas&gt; &#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>SkCanvasVirtualEnforcer是一个模板类，在skia库中定义，RecordingCanvas实际上继承自SkNoDrawCanvas，SkNoDrawCanvas以同样的方式继承自SkCanvas。</p>
<p>RecordingCanvas和SkNoDrawCanvas都没有复写SkCanvas::drawCircle</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//external\skia\include\core\SkScalar.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> SkScalar;</span><br><span class="line"><span class="comment">//external\skia\src\core\SkCanvas.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkCanvas::drawCircle</span><span class="params">(SkScalar cx, SkScalar cy, SkScalar radius, <span class="type">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (radius &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        radius = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SkRect  r;</span><br><span class="line">    r.<span class="built_in">setLTRB</span>(cx - radius, cy - radius, cx + radius, cy + radius);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">drawOval</span>(r, paint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkCanvas::drawOval</span><span class="params">(<span class="type">const</span> SkRect&amp; r, <span class="type">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TRACE_EVENT0</span>(<span class="string">&quot;skia&quot;</span>, TRACE_FUNC);</span><br><span class="line">    <span class="comment">// To avoid redundant logic in our culling code and various backends, we always sort rects</span></span><br><span class="line">    <span class="comment">// before passing them along.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">onDrawOval</span>(r.<span class="built_in">makeSorted</span>(), paint); <span class="comment">//最终调用的是子类的onDrawOval函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\libs\hwui\RecordingCanvas.h</span></span><br><span class="line">DisplayListData* RecordingCanvas::fDL;</span><br><span class="line"><span class="comment">//F:\github\android\android-12.1.0_r27\frameworks\base\libs\hwui\RecordingCanvas.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecordingCanvas::onDrawOval</span><span class="params">(<span class="type">const</span> SkRect&amp; oval, <span class="type">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    fDL-&gt;<span class="built_in">drawOval</span>(oval, paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayListData::drawOval</span><span class="params">(<span class="type">const</span> SkRect&amp; oval, <span class="type">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">push</span>&lt;DrawOval&gt;(<span class="number">0</span>, oval, paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DrawOval</span> <span class="keyword">final</span> : Op &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> kType = Type::DrawOval;</span><br><span class="line">    <span class="built_in">DrawOval</span>(<span class="type">const</span> SkRect&amp; oval, <span class="type">const</span> SkPaint&amp; paint) : <span class="built_in">oval</span>(oval), <span class="built_in">paint</span>(paint) &#123;&#125;</span><br><span class="line">    SkRect oval;</span><br><span class="line">    SkPaint paint;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(SkCanvas* c, <span class="type">const</span> SkMatrix&amp;)</span> <span class="type">const</span> </span>&#123; c-&gt;<span class="built_in">drawOval</span>(oval, paint); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="待办"><a href="#待办" class="headerlink" title="待办"></a>待办</h3><ul>
<li><input disabled="" type="checkbox"> <code>View#buildLayer</code>的作用是什么？</li>
<li><input disabled="" type="checkbox"> RenderThread会使用surface.lockHardwareCanvas()吗？</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android binder剖析之addService</title>
    <url>/posts/27252.html</url>
    <content><![CDATA[<p>本文基于Android 8.0源码分析。以mediaserver为例剖析binder addService的流程。</p>
<span id="more"></span>

<p>先来看下addService的时序图：</p>
<img src="\assert\puml\9536509db57575a74802a716e96ed871515553ee964304a65ee5c21bf070a93b.svg"/>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\av\media\mediaserver\main_mediaserver.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;  <span class="comment">// 1. ProcessState是个单例，每个进程只有一个实例，binder设备的打开操作就是在此</span></span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;  <span class="comment">//2. 获取IServiceManager</span></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">InitializeIcuOrDie</span>();</span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-ProcessState打开binder设备"><a href="#1-ProcessState打开binder设备" class="headerlink" title="1. ProcessState打开binder设备"></a>1. ProcessState打开binder设备</h2><p>ProcessState是一个进程相关的对象，一个对象只有一个ProcessState。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\ProcessState.cpp</span></span><br><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);  <span class="comment">//采用单例模式，每个进程保证只有一个ProcessState</span></span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> <span class="built_in">ProcessState</span>(<span class="string">&quot;/dev/binder&quot;</span>);   <span class="comment">//构造函数传入了binder设备的路径</span></span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))  <span class="comment">//打开binder设备, mDriverFD成员变量就是binder设备的文件描述符</span></span><br><span class="line">    ......</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using /dev/binder failed: unable to mmap transaction memory.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState构造函数中，调用mmap把binder设备内核空间的一段内存映射到用户空间。mmap的具体作用跟设备的实现有关系。<br>关于mmap的介绍可以参考这篇文章：<a href="https://blog.csdn.net/DLUTBruceZhang/article/details/9080173">Linux 内存映射函数 mmap（）函数详解
</a></p>
<p>现在看下open_driver是如何打开binder设备的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span>  <span class="comment">//driver参数指的就是&quot;/dev/binder&quot;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);  <span class="comment">//系统调用open打开binder设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//通过ioctl获取binder设备的协议版本号。</span></span><br><span class="line">        <span class="type">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="type">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较应用端和binder内核驱动的版本号是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">//设置支持的最大线程数15</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以看出打开binder设备的操作还是很简单的。</p>
<h2 id="2-获取-IServiceManager"><a href="#2-获取-IServiceManager" class="headerlink" title="2. 获取 IServiceManager"></a>2. 获取 IServiceManager</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IServiceManager.cpp</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//依然是单例模式</span></span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = <span class="built_in">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()-&gt;getContextObject(NULL)最终返回的是 new BpBinder(0); ，其中0表示的就是ServiceManager在binder系统中的标识。</p>
<p>interface_cast的定义如下，是一个模板函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IInterface.h</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换模板参数后就是如下形式：</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最终调用的是IServiceManager::asInterface(new BpBinder(0))，所以需要再分析一下IServiceManager::asInterface函数。</p>
<p>看一下IServiceManager的定义，非常简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IServiceManager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IServiceManager</span> : <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DECLARE_META_INTERFACE</span>(ServiceManager)</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>    <span class="title">addService</span><span class="params">( <span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt;    <span class="title">listServices</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DECLARE-META-INTERFACE宏"><a href="#DECLARE-META-INTERFACE宏" class="headerlink" title="DECLARE_META_INTERFACE宏"></a>DECLARE_META_INTERFACE宏</h3><p>其中DECLARE_META_INTERFACE是个宏定义，与IMPLEMENT_META_INTERFACE宏配合使用，是谷歌提供的用于native service层对接binder的两个模板宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IInterface.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line"><span class="meta">    static const ::android::String16 descriptor;                        \</span></span><br><span class="line"><span class="meta">    static ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> asInterface(                     \</span></span><br><span class="line"><span class="meta">            const ::android::sp<span class="string">&lt;::android::IBinder&gt;</span>&amp; obj);              \</span></span><br><span class="line"><span class="meta">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \</span></span><br><span class="line"><span class="meta">    I##INTERFACE();                                                     \</span></span><br><span class="line"><span class="meta">    virtual ~I##INTERFACE();                                            \</span></span><br></pre></td></tr></table></figure>

<p>宏的参数替换成 ServiceManager 后，可以得到IServiceManager类的头文件声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IServiceManager.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IServiceManager</span> : <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//DECLARE_META_INTERFACE(INTERFACE) 宏定义展开如下</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> ::android::String16 descriptor;</span><br><span class="line">    <span class="type">static</span> ::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">asInterface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">const</span> ::<span class="function">android::String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="built_in">IServiceManager</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IServiceManager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>    <span class="title">addService</span><span class="params">( <span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt;    <span class="title">listServices</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IMPLEMENT-META-INTERFACE宏"><a href="#IMPLEMENT-META-INTERFACE宏" class="headerlink" title="IMPLEMENT_META_INTERFACE宏"></a>IMPLEMENT_META_INTERFACE宏</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\include\binder\IInterface.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line"><span class="meta">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span></span><br><span class="line"><span class="meta">    const ::android::String16&amp;                                          \</span></span><br><span class="line"><span class="meta">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span></span><br><span class="line"><span class="meta">        return I##INTERFACE::descriptor;                                \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> I##INTERFACE::asInterface(              \</span></span><br><span class="line"><span class="meta">            const ::android::sp<span class="string">&lt;::android::IBinder&gt;</span>&amp; obj)               \</span></span><br><span class="line"><span class="meta">    &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        ::android::sp<span class="string">&lt;I##INTERFACE&gt;</span> intr;                               \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span></span><br><span class="line"><span class="meta">            intr = static_cast<span class="string">&lt;I##INTERFACE*&gt;</span>(                          \</span></span><br><span class="line"><span class="meta">                obj-&gt;queryLocalInterface(                               \</span></span><br><span class="line"><span class="meta">                        I##INTERFACE::descriptor).get());               \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span></span><br><span class="line"><span class="meta">                intr = new Bp##INTERFACE(obj);                          \</span></span><br><span class="line"><span class="meta">            &#125;                                                           \</span></span><br><span class="line"><span class="meta">        &#125;                                                               \</span></span><br><span class="line"><span class="meta">        return intr;                                                    \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span></span><br><span class="line"><span class="meta">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span></span><br></pre></td></tr></table></figure>

<p>再看下IServiceManager.cpp中IMPLEMENT_META_INTERFACE宏的使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IServiceManager.cpp</span></span><br><span class="line"><span class="built_in">IMPLEMENT_META_INTERFACE</span>(ServiceManager, <span class="string">&quot;android.os.IServiceManager&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>把宏定义展开后，IServiceManager.cpp源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IMPLEMENT_META_INTERFACE(INTERFACE, NAME)宏定义展开代码如下：</span></span><br><span class="line">    <span class="type">const</span> ::<span class="function">android::String16 <span class="title">IServiceManager::descriptor</span><span class="params">(<span class="string">&quot;android.os.IServiceManager&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> ::<span class="function">android::String16&amp; <span class="title">IServiceManager::getInterfaceDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">IServiceManager::asInterface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ::android::sp&lt;IServiceManager&gt; intr;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            intr = <span class="built_in">static_cast</span>&lt;IServiceManager*&gt;(</span><br><span class="line">                obj-&gt;<span class="built_in">queryLocalInterface</span>(IServiceManagerE::descriptor).<span class="built_in">get</span>());</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                intr = <span class="keyword">new</span> <span class="built_in">BpServiceManager</span>(obj);  <span class="comment">//最终是创建了一个BpServiceManager对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intr;</span><br><span class="line">    &#125;</span><br><span class="line">    IServiceManager::<span class="built_in">IServiceManager</span>() &#123; &#125;</span><br><span class="line">    IServiceManager::~<span class="built_in">IServiceManager</span>() &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取IServiceManager小结"><a href="#获取IServiceManager小结" class="headerlink" title="获取IServiceManager小结"></a>获取IServiceManager小结</h3><p>获取IServiceManager的代码可以使用如下代码来等价的表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化版代码</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = <span class="keyword">new</span> <span class="built_in">BpServiceManager</span>(<span class="keyword">new</span> <span class="built_in">BpBinder</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出获取的IServiceManager就是BpServiceManager对象，BpServiceManager的构造函数需要一个BpBinder对象。这两个类的作用我们在后面详细介绍。</p>
<h2 id="3-addService流程分析"><a href="#3-addService流程分析" class="headerlink" title="3. addService流程分析"></a>3. addService流程分析</h2><p>再回顾下上面两个章节内容：</p>
<ol>
<li>mediaserver进程首先创建了一个ProcessState，在ProcessState的构造函数中打开了binder设备；</li>
<li>获取IServiceManager（就是BpServiceManager对象），然后就可以与ServiceManager进行binder通信了。</li>
</ol>
<p>通过上面介绍的两点，我们就可以推测出来，BpServiceManager肯定要使用ProcessState才能进行binder通信。实际情况也的确如此，BpServiceManager通过BpBinder对象来使用ProcessState。</p>
<p>首先看下MediaServer是怎么调用addService把多媒体服务添加到ServiceManager中的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\av\media\mediaserver\main_mediaserver.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">InitializeIcuOrDie</span>();</span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();  <span class="comment">//初始化MediaPlayerService</span></span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks\av\media\libmediaplayerservice\MediaPlayerService.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaPlayerService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//defaultServiceManager返回的就是BpServiceManager，就是上面的分析过程。</span></span><br><span class="line">    <span class="comment">//new了一个MediaPlayerService，然后通过addService添加binder服务</span></span><br><span class="line">    <span class="built_in">defaultServiceManager</span>()-&gt;<span class="built_in">addService</span>(</span><br><span class="line">            <span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> <span class="built_in">MediaPlayerService</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BpServiceManager类"><a href="#BpServiceManager类" class="headerlink" title="BpServiceManager类"></a>BpServiceManager类</h3><p>BpServiceManager就是binder跨进程通信机制的C/S架构的client端，属于业务层，定义在frameworks\native\libs\binder\IServiceManager.cpp文件中。首先看下BpServiceManager相关联的binder家族类图：</p>
<img src="\assert\puml\cf204ed7275591267993baa6056c8137797c121f37a24d68fedc25ac3e08d835.svg"/>

<p>BpServiceManager的父类BpRefBase持有了BpBinder对象，BpBinder会使用IPCThreadState，而IPCThreadState又使用ProcessState。通过这张图，BpServiceManager到ProcessState的脉络就清楚了。</p>
<p>BpInterface是个模板类，会继承它的模板参数，比如在此处继承了IServiceManager。从上面的类图中可以看出BpServiceManager并没有继承IBinder，而是通过父类BpInterface的mRemote成员变量持有了BpBinder（继承自IBinder）。BpServiceManager与ServiceManager服务端的交互都是通过BpBinder来进行的。</p>
<h3 id="MediaPlayerService类"><a href="#MediaPlayerService类" class="headerlink" title="MediaPlayerService类"></a>MediaPlayerService类</h3><p>熟悉了BpServiceManager的脉络，再先看下通过addService添加的MediaPlayerService类的脉络，然后再继续分析ServiceManager的addService的流程：</p>
<img src="\assert\puml\c054fe59ca58b09b8f8f34c4a16657160b23d71ea24643b525f4c5a6f1cff570.svg"/>

<p>可以看到MediaPlayerService继承自BBinder，就是binder C/S架构的服务端，是媒体服务(“media.player”)的提供者。通过ServiceManager系统把MediaPlayerService注册到binder系统中。</p>
<p>MediaPlayerService类并不是我们的主角，这里介绍MediaPlayerService的目的是来熟悉一下服务和BBinder的关系。addService的服务端的主角是service_manager（定义在service_manager.c中，会面会详细介绍），但是service_manager并没有接入BBinder框架，而是通过直接打开binder设备来通信。作为binder服务的管理者，service_manager在实现上就和普通的binder服务不同。</p>
<h3 id="BpServiceManager-addService"><a href="#BpServiceManager-addService" class="headerlink" title="BpServiceManager::addService"></a>BpServiceManager::addService</h3><p>来看下BpServiceManager的addService是如何实现的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IServiceManager.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpServiceManager</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; impl)</span>  <span class="comment">//impl参数就是BpBinder(0)</span></span></span><br><span class="line"><span class="function">        : BpInterface&lt;IServiceManager&gt;(impl)  &#123;</span>&#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">bool</span> allowIsolated)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        <span class="comment">//IServiceManager::getInterfaceDescriptor()返回&quot;android.os.IServiceManager&quot;</span></span><br><span class="line">        data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">        data.<span class="built_in">writeString16</span>(name);  <span class="comment">//name就是&quot;media.player&quot;</span></span><br><span class="line">        data.<span class="built_in">writeStrongBinder</span>(service);  <span class="comment">//service就是MediaPlayerService类对象</span></span><br><span class="line">        data.<span class="built_in">writeInt32</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);  <span class="comment">//allowIsolated默认是false，所以此处为0</span></span><br><span class="line">        <span class="comment">//remote()返回mRemote（就是BpBinder），此处就是调用BpBinder的transact</span></span><br><span class="line">        <span class="type">status_t</span> err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> err == NO_ERROR ? reply.<span class="built_in">readExceptionCode</span>() : err;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BpServiceManager的构造函数没有任何自定义实现，直接把参数（BpBinder）交给了父类。addService函数首先把service信息填充到Parcel中，然后调用BpBinder的transact。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span>  <span class="comment">//flags默认是0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BpBinder的transact啥也没干，直接把请求交给了IPCThreadState的transact。首先看下IPCThreadState::self()的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\IPCThreadState.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> gHaveTLS = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> gTLS = <span class="number">0</span>; <span class="comment">//pthread_key_t是一个TheadLocal变量的key。</span></span><br><span class="line"></span><br><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123; <span class="comment">//首次调用gHavsTLS是false</span></span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;  <span class="comment">//IPCThreadState的构造函数会把自己加到ThreadLocal变量中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS) &#123;</span><br><span class="line">        <span class="comment">//创建一个ThreadLocal变量，key存放到gTLS全局标量中</span></span><br><span class="line">        <span class="type">int</span> key_create_value = <span class="built_in">pthread_key_create</span>(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;</span>, <span class="built_in">strerror</span>(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState::self()的作用就是创建了一个特定线程（TheadLocal数据）的IPCThreadState，所以每个线程维护一个IPCThreadState对象。关于native层ThreadLocal介绍可以参考 <a href="https://linux.die.net/man/3/pthread_key_create">https://linux.die.net/man/3/pthread_key_create</a>。再看下IPCThreadState构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">    : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),  <span class="comment">//ProcessState又出现了，ProcessState会打开binder设备</span></span><br><span class="line">      <span class="built_in">mStrictModePolicy</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLastTransactionBinderFlags</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_setspecific</span>(gTLS, <span class="keyword">this</span>);  <span class="comment">//把自己放到ThreadLocal中</span></span><br><span class="line">    <span class="built_in">clearCaller</span>();</span><br><span class="line">    mIn.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);  <span class="comment">//mIn是个Parcel对象，用于存储从binder接收的数据</span></span><br><span class="line">    mOut.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>); <span class="comment">//mOut也是Parcel对象，用于存储向binder发送的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState和ProcessState的关系就清楚了，通过mProcess变量持有了ProcessState对象的引用。</p>
<h3 id="IPCThreadState-transact"><a href="#IPCThreadState-transact" class="headerlink" title="IPCThreadState::transact()"></a>IPCThreadState::transact()</h3><p>看一下IPCThreadState::transact的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//handle = 0，就是ServiceManager在binder系统中的标识</span></span><br><span class="line"><span class="comment">//code = ADD_SERVICE_TRANSACTION</span></span><br><span class="line"><span class="comment">//data 就是BpServiceManager.addService中组装的要通过binder发送出去的Parcel数据</span></span><br><span class="line"><span class="comment">//flags = 0</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">LOG_ONEWAY</span>(<span class="string">&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getuid</span>(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">&quot;READ REPLY&quot;</span> : <span class="string">&quot;ONE WAY&quot;</span>);</span><br><span class="line">        err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;  <span class="comment">//flags初始值是0，走该分支</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123; <span class="comment">//replay不为空，走if分支</span></span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState::transact有两个重点函数调用：writeTransactionData和waitForResponse。分别看下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;  <span class="comment">//target表示发送给谁，此处handle为0就代表ServiceManager</span></span><br><span class="line">    tr.code = code;  <span class="comment">//code值为ADD_SERVICE_TRANSACTION，addService</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>(); <span class="comment">//Parcel数据大小</span></span><br><span class="line">        <span class="comment">//ptr.buffer就是Parcel的mData的地址</span></span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        <span class="comment">//ptr.offsets指向Parcel的mObjects</span></span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是把数据写到mOut中，并没有发送出去</span></span><br><span class="line">    <span class="comment">//需要注意下数据结构的转换：把输入的Parcel转换成binder_transaction_data</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);  <span class="comment">//cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>writeTransactionData把要通过binder传输的数据写入mOut。这里需要注意下数据结构的变更，首先把原始的Parcel(data)转换成binder_transaction_data结构体，然后又写入到mOut中，而mOut也是个Parcel对象。</p>
<h3 id="Parcel等数据结构分析"><a href="#Parcel等数据结构分析" class="headerlink" title="Parcel等数据结构分析"></a>Parcel等数据结构分析</h3><p>我们有必要分析一下传输数据在这个过程中的转换过程。我们都知道，binder通信都是使用Parcel作为数据载体的，Parcel在传输基本数据类型（比如int、string）时，都直接写到成员变量mData指针指向的内存中。Parcel对象构建时，mData并没有指向任何内存，当真正写入数据时才通过memcpy来按需申请内存。mDataSize表示已经写入的数据大小，mDataPos指针指向下次要写入数据的位置。</p>
<p>再回顾一下<code>BpServiceManager::addService</code>拼装初始Parcel数据的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class BpServiceManager</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> allowIsolated)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">    data.<span class="built_in">writeString16</span>(name);</span><br><span class="line">    data.<span class="built_in">writeStrongBinder</span>(service);</span><br><span class="line">    data.<span class="built_in">writeInt32</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.<span class="built_in">readExceptionCode</span>() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行后，Parcel中mData和mObjects两个成员变量可以用下图来表示：</p>
<!--  -->

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: parcel_data Pages: 1 -->
<svg width="532pt" height="116pt"
 viewBox="0.00 0.00 531.50 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>parcel_data</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-112 527.5,-112 527.5,4 -4,4"/>
<!-- mData -->
<g id="node1" class="node">
<title>mData</title>
<polygon fill="none" stroke="#000000" points="6,-79 6,-101 49,-101 49,-79 6,-79"/>
<text text-anchor="start" x="8.8415" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">mData</text>
</g>
<!-- data -->
<g id="node2" class="node">
<title>data</title>
<polygon fill="none" stroke="#000000" points="73,-79 73,-101 96,-101 96,-79 73,-79"/>
<text text-anchor="start" x="75.9474" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">len</text>
<polygon fill="none" stroke="#000000" points="96,-79 96,-101 281,-101 281,-79 96,-79"/>
<text text-anchor="start" x="98.7012" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">“android.os.IServiceManager”</text>
<polygon fill="none" stroke="#000000" points="281,-79 281,-101 304,-101 304,-79 281,-79"/>
<text text-anchor="start" x="283.9474" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">len</text>
<polygon fill="none" stroke="#000000" points="304,-79 304,-101 403,-101 403,-79 304,-79"/>
<text text-anchor="start" x="306.6546" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">“media.player”</text>
<polygon fill="none" stroke="#000000" points="403,-79 403,-101 511,-101 511,-79 403,-79"/>
<text text-anchor="start" x="405.6837" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">flat_binder_object</text>
<polygon fill="none" stroke="#000000" points="511,-79 511,-101 524,-101 524,-79 511,-79"/>
<text text-anchor="start" x="514" y="-85.4" font-family="Times,serif" font-size="14.00" fill="#000000">0</text>
</g>
<!-- mData&#45;&gt;data -->
<g id="edge1" class="edge">
<title>mData:p0&#45;&gt;data:p0</title>
<path fill="none" stroke="#000000" d="M49.1823,-90C53.9239,-90 58.7438,-90 62.7958,-90"/>
<polygon fill="#000000" stroke="#000000" points="63,-93.5001 73,-90 63,-86.5001 63,-93.5001"/>
</g>
<!-- mObjects -->
<g id="node3" class="node">
<title>mObjects</title>
<polygon fill="none" stroke="#000000" points="7,-7 7,-29 66,-29 66,-7 7,-7"/>
<text text-anchor="start" x="9.6739" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">mObjects</text>
</g>
<!-- mData&#45;&gt;mObjects -->
<!-- objects -->
<g id="node4" class="node">
<title>objects</title>
<polygon fill="none" stroke="#000000" points="397,-7 397,-29 410,-29 410,-7 397,-7"/>
<text text-anchor="start" x="400" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">0</text>
<polygon fill="none" stroke="#000000" points="410,-7 410,-29 423,-29 423,-7 410,-7"/>
<text text-anchor="start" x="413" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">1</text>
<polygon fill="none" stroke="#000000" points="423,-7 423,-29 436,-29 436,-7 423,-7"/>
<text text-anchor="start" x="426" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">2</text>
<polygon fill="none" stroke="#000000" points="436,-7 436,-29 449,-29 449,-7 436,-7"/>
<text text-anchor="start" x="439" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">3</text>
</g>
<!-- mObjects&#45;&gt;objects -->
<g id="edge2" class="edge">
<title>mObjects&#45;&gt;objects</title>
<path fill="none" stroke="#000000" d="M65.8564,-18C172.3993,-18 278.9422,-18 385.4851,-18"/>
<polygon fill="#000000" stroke="#000000" points="385.7957,-21.5001 395.7957,-18 385.7957,-14.5001 385.7957,-21.5001"/>
</g>
<!-- objects&#45;&gt;data -->
<g id="edge3" class="edge">
<title>objects:n&#45;&gt;data:sw</title>
<path fill="none" stroke="#000000" d="M403,-29C403,-29 403,-54.2716 403,-68.8818"/>
<polygon fill="#000000" stroke="#000000" points="399.5001,-69 403,-79 406.5001,-69 399.5001,-69"/>
</g>
</g>
</svg>


<p>可以看到有个flat_binder_object结构体，这个结构体就是通过调用<code>Parcel::writeStrongBinder</code>写入的<code>sp&lt;IBinder&gt;</code>(本例中就是MediaPlayerService)。writeStrongBinder的实现与基本数据结构的写入是有区别的，专门用于承载IBinder对象的传输任务。来看下代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flatten_binder</span>(ProcessState::<span class="built_in">self</span>(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">flatten_binder</span><span class="params">(<span class="type">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">backgroundSchedulingDisabled</span>()) &#123;</span><br><span class="line">        <span class="comment">/* minimum priority for all nodes is nice 0 */</span></span><br><span class="line">        obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* minimum priority for all nodes is MAX_NICE(19) */</span></span><br><span class="line">        obj.flags = <span class="number">0x13</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是Bn端的BBinder，则localBinder会返回对象指针；</span></span><br><span class="line">        <span class="comment">//Bp端的BpBinder没有重写localBinder，所以会返回NULL；</span></span><br><span class="line">        <span class="comment">//此处写入的是MediaPlayerService，是Bn端，所以local返回的就是MediaPlayerService对象</span></span><br><span class="line">        IBinder *local = binder-&gt;<span class="built_in">localBinder</span>();  </span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            <span class="comment">//BpBinder实现了remoteBinder，返回this指针</span></span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//我们向Parcel中写入的是服务端IBinder，走else分支</span></span><br><span class="line">            <span class="comment">//只关重要的3句赋值代码，后面会介绍哪里会用</span></span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">finish_flatten_binder</span>(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flatten_binder函数把IBinder封装成flat_binder_object结构体，然后调用<code>finish_flatten_binder</code>。先看下flat_binder_object结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//flat_binder_object结构体定义比较简单，不多介绍。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> &#123;</span><br><span class="line">  __u32 type;  <span class="comment">//在add MediaPlayerService时type=BINDER_TYPE_BINDER</span></span><br><span class="line">  __u32 flags;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">binder_uintptr_t</span> binder;</span><br><span class="line">    __u32 handle;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">binder_uintptr_t</span> cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>进入<code>finish_flatten_binder</code>函数看下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\libs\binder\Parcel.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出传入的binder参数没有用到，所以flat_binder_object就是用于传输的数据结构。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">status_t</span> <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*binder*/</span>, <span class="type">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;<span class="built_in">writeObject</span>(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeObject</span><span class="params">(<span class="type">const</span> flat_binder_object&amp; val, <span class="type">bool</span> nullMetaData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enoughData = (mDataPos+<span class="built_in">sizeof</span>(val)) &lt;= mDataCapacity;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enoughObjects = mObjectsSize &lt; mObjectsCapacity;</span><br><span class="line">    <span class="keyword">if</span> (enoughData &amp;&amp; enoughObjects) &#123;</span><br><span class="line">restart_write: <span class="comment">//注意这个goto跳转标记，在Parcel内存不足以保存要写入的数据时，会先去申请内存，然后再跳转回来</span></span><br><span class="line">        <span class="comment">//把刚才的flat_binder_object数据结构保存到mData所指向内存的mDataPos位置</span></span><br><span class="line">        *<span class="built_in">reinterpret_cast</span>&lt;flat_binder_object*&gt;(mData+mDataPos) = val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remember if it&#x27;s a file descriptor</span></span><br><span class="line">        <span class="keyword">if</span> (val.type == BINDER_TYPE_FD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mAllowFds) &#123;</span><br><span class="line">                <span class="comment">// fail before modifying our object index</span></span><br><span class="line">                <span class="keyword">return</span> FDS_NOT_ALLOWED;</span><br><span class="line">            &#125;</span><br><span class="line">            mHasFds = mFdsKnown = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to write meta-data?</span></span><br><span class="line">        <span class="keyword">if</span> (nullMetaData || val.binder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//除了把数据写到mData，还会在mObjects中再记录一下数据的偏移地址mDataPos</span></span><br><span class="line">            mObjects[mObjectsSize] = mDataPos;</span><br><span class="line">            <span class="comment">//也是非常重要的一句代码，会调用cookie-&gt;incStrong，这样对象就不会被释放了</span></span><br><span class="line">            <span class="built_in">acquire_object</span>(ProcessState::<span class="built_in">self</span>(), val, <span class="keyword">this</span>, &amp;mOpenAshmemSize);</span><br><span class="line">            mObjectsSize++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成写入操作，把mDataPos指向新的可写位置，并更新数据大小mDataSize</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">finishWrite</span>(<span class="built_in">sizeof</span>(flat_binder_object));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的代码是在内存不足以存放要写入的数据时来增加内存的</span></span><br><span class="line">    <span class="keyword">if</span> (!enoughData) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> err = <span class="built_in">growData</span>(<span class="built_in">sizeof</span>(val));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!enoughObjects) &#123;</span><br><span class="line">        <span class="type">size_t</span> newSize = ((mObjectsSize+<span class="number">2</span>)*<span class="number">3</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newSize*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>) &lt; mObjectsSize) <span class="keyword">return</span> NO_MEMORY;   <span class="comment">// overflow</span></span><br><span class="line">        <span class="type">binder_size_t</span>* objects = (<span class="type">binder_size_t</span>*)<span class="built_in">realloc</span>(mObjects, newSize*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (objects == <span class="literal">NULL</span>) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        mObjects = objects;</span><br><span class="line">        mObjectsCapacity = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> restart_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Parcel数据结构的拼装就分析完了。但是作为binder传输的数据载体，Parcel的任务还没有结束。继续沿着传输链条向后分析。先来回忆一下数据传输链条：</p>
<ol>
<li><code>BpServiceManager::addService</code>中拼装完Parcel数据结构后，就调用了<code>remote()-&gt;transact</code>，<code>remote()</code>函数返回的就是BpBinder；</li>
<li>BpBinder::transact接收到Parcel后，原封不动的传给了<code>IPCThreadState::self()-&gt;transact</code>;</li>
<li><code>IPCThreadState::self()-&gt;transact</code>会调用<code>IPCThreadState::writeTransactionData</code>把原Parcel数据写入变量名为mOut的Parcel对象中。</li>
</ol>
<p>现在我们再把<code>IPCThreadState::writeTransactionData</code>函数贴出来看下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;  <span class="comment">//target表示发送给谁，handle为0就代表ServiceManager</span></span><br><span class="line">    tr.code = code;  <span class="comment">//code值为ADD_SERVICE_TRANSACTION，就是我们分析的addService</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>(); <span class="comment">//Parcel数据大小</span></span><br><span class="line">        <span class="comment">//ptr.buffer就是Parcel的mData的地址，addService瓶装的Parcel数据都放在以mData为首地址的内存中</span></span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();  <span class="comment">//指向Parcel.mData</span></span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        <span class="comment">//ptr.offsets会指向Parcel的mObjects数组的首地址，数组中存放着flat_binder_object结构体在mData中的偏移</span></span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是把数据写到mOut中，并没有发送出去</span></span><br><span class="line">    <span class="comment">//需要注意下数据结构的转换：把输入的Parcel转换成binder_transaction_data.</span></span><br><span class="line">    <span class="comment">//在IPCThreadState构造函数中mOut设置存储大小是256，binder_transaction_data的大小肯定不会大于256</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);  <span class="comment">//cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传输数据已经写入到mOut表示Parcel类中，我们看下此时的mOut数据：</p>
<!--  -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: parcel_data Pages: 1 -->
<svg width="268pt" height="44pt"
 viewBox="0.00 0.00 268.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>parcel_data</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-40 264,-40 264,4 -4,4"/>
<!-- mData -->
<g id="node1" class="node">
<title>mData</title>
<polygon fill="none" stroke="#000000" points="6,-7 6,-29 49,-29 49,-7 6,-7"/>
<text text-anchor="start" x="8.8415" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">mData</text>
</g>
<!-- data -->
<g id="node2" class="node">
<title>data</title>
<polygon fill="none" stroke="#000000" points="90,-7 90,-29 120,-29 120,-7 90,-7"/>
<text text-anchor="start" x="92.9474" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">cmd</text>
<polygon fill="none" stroke="#000000" points="120,-7 120,-29 260,-29 260,-7 120,-7"/>
<text text-anchor="start" x="122.7468" y="-13.4" font-family="Times,serif" font-size="14.00" fill="#000000">binder_transaction_data</text>
</g>
<!-- mData&#45;&gt;data -->
<g id="edge1" class="edge">
<title>mData:0&#45;&gt;data:0</title>
<path fill="none" stroke="#000000" d="M49.2343,-18C58.3067,-18 69.251,-18 79.9224,-18"/>
<polygon fill="#000000" stroke="#000000" points="80,-21.5001 90,-18 80,-14.5001 80,-21.5001"/>
</g>
</g>
</svg>


<p>来看下<code>binder_transaction_data</code>结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//binder.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_transaction_data</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    __u32 handle; <span class="comment">//handle为0就代表ServiceManager</span></span><br><span class="line">    <span class="type">binder_uintptr_t</span> ptr;</span><br><span class="line">  &#125; target;  <span class="comment">//target表示数据传输的目标</span></span><br><span class="line">  <span class="type">binder_uintptr_t</span> cookie;  <span class="comment">//addService流程设置该值为无效值0</span></span><br><span class="line">  __u32 code;  <span class="comment">//code值为ADD_SERVICE_TRANSACTION，就是我们分析的addService</span></span><br><span class="line">  __u32 flags;</span><br><span class="line">  <span class="type">pid_t</span> sender_pid;</span><br><span class="line">  <span class="type">uid_t</span> sender_euid;</span><br><span class="line">  <span class="type">binder_size_t</span> data_size;  <span class="comment">//Parcel的mData的有效数据大小</span></span><br><span class="line">  <span class="type">binder_size_t</span> offsets_size;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="comment">//buffer指向Parcel的mData所指向的内存地址，注意这里只是内存首地址，</span></span><br><span class="line">      <span class="comment">//并没有进行内存拷贝，当binder驱动收到数据后再通过copy_from_user</span></span><br><span class="line">      <span class="comment">//把用户态的内存拷贝到内核态。这样就减少了一次内存的拷贝，因为即使先拷贝了一次，</span></span><br><span class="line">      <span class="comment">//在驱动中依然要通过copy_from_user进行一次拷贝。</span></span><br><span class="line">      <span class="type">binder_uintptr_t</span> buffer;  </span><br><span class="line">      <span class="type">binder_uintptr_t</span> offsets; <span class="comment">//指向Parcel的mObjects</span></span><br><span class="line">    &#125; ptr;</span><br><span class="line">    __u8 buf[<span class="number">8</span>];</span><br><span class="line">  &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IPCThreadState-waitForResponse"><a href="#IPCThreadState-waitForResponse" class="headerlink" title="IPCThreadState::waitForResponse"></a>IPCThreadState::waitForResponse</h3><p>现在要发送的数据已经写到IPCThreadState::mOut中了，怎么发送出去的呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>; <span class="comment">//talkWithDriver需要重点分析</span></span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:  <span class="comment">//addService成功会收到BR_TRANSACTION_COMPLETE</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IPCThreadState-talkWithDriver"><a href="#IPCThreadState-talkWithDriver" class="headerlink" title="IPCThreadState::talkWithDriver"></a>IPCThreadState::talkWithDriver</h3><p>无比关键的talkWithDriver</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    binder_write_read bwr;  <span class="comment">//又把数据封装成binder_write_read</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();  <span class="comment">//mOut是一个Parcel，write_buffer指向mOut.mData所指向的内存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we&#x27;ll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">//mIn在IPCThreadState构造函数中设置内存大小是256</span></span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//通过系统调用ioctl把addService的请求发送给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.<span class="built_in">dataSize</span>())</span><br><span class="line">                mOut.<span class="built_in">remove</span>(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.<span class="built_in">setDataSize</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addService的客户端的流程就分析到这里。关于binder驱动里面的处理可以分析内核源码，从binder.c的<code>binder_ioctl</code>函数开始分析。<code>binder_ioctl</code>就是系统调用<code>ioctl</code>的执行函数。后续会持续补充…</p>
<h2 id="4-ServiceManager分析"><a href="#4-ServiceManager分析" class="headerlink" title="4. ServiceManager分析"></a>4. ServiceManager分析</h2><h3 id="入口函数-main"><a href="#入口函数-main" class="headerlink" title="入口函数 main"></a>入口函数 main</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\native\cmds\servicemanager\service_manager.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">selinux_callback</span> cb;</span><br><span class="line">    <span class="type">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">binder_open</span>(driver, <span class="number">128</span>*<span class="number">1024</span>);  <span class="comment">//打开binder设备</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//把自己设置为context_manager(ServiceManager的服务端)</span></span><br><span class="line">    <span class="comment">//该函数的目的就是通过ioctl把设置handle值为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binder_become_context_manager</span>(bs)) &#123;  </span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//selinux相关的一些操作，此处省略，读者有兴趣可以自行分析</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="built_in">binder_loop</span>(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service_manager的main函数主要有3个重要步骤：</p>
<ol>
<li>binder_open打开binder设备；</li>
<li>成为context_manager，也就是ServiceManager；</li>
<li>进入binder_loop；</li>
</ol>
<p>我们一步步进行分析</p>
<h3 id="ServiceManager打开binder设备"><a href="#ServiceManager打开binder设备" class="headerlink" title="ServiceManager打开binder设备"></a>ServiceManager打开binder设备</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_state</span> *<span class="built_in">binder_open</span>(<span class="type">const</span> <span class="type">char</span>* driver, <span class="type">size_t</span> mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_version</span> vers;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC); <span class="comment">//打开binder设备，就是&quot;/dev/binder&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot open %s (%s)\n&quot;</span>,</span><br><span class="line">                driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取驱动版本号，并对比应用和驱动的版本号是否相同</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                <span class="string">&quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot map device (%s)\n&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    <span class="built_in">close</span>(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成为context-manager"><a href="#成为context-manager" class="headerlink" title="成为context_manager"></a>成为context_manager</h3><p>其实就是ServiceManager。通过系统调用ioctl的BINDER_SET_CONTEXT_MGR命令来设置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_become_context_manager</span><span class="params">(<span class="keyword">struct</span> binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder驱动中的处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux-4.9.243\drivers\android\binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">binder_node</span> *binder_context_mgr_node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        ...</span><br><span class="line">        ret = <span class="built_in">binder_ioctl_set_ctx_mgr</span>(filp);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_ioctl_set_ctx_mgr</span><span class="params">(<span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="type">kuid_t</span> curr_euid = <span class="built_in">current_euid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;BINDER_SET_CONTEXT_MGR already set\n&quot;</span>);</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">security_binder_set_context_mgr</span>(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">uid_valid</span>(binder_context_mgr_uid)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">uid_eq</span>(binder_context_mgr_uid, curr_euid)) &#123;</span><br><span class="line">            <span class="built_in">pr_err</span>(<span class="string">&quot;BINDER_SET_CONTEXT_MGR bad uid %d != %d\n&quot;</span>,</span><br><span class="line">                   <span class="built_in">from_kuid</span>(&amp;init_user_ns, curr_euid),</span><br><span class="line">                   <span class="built_in">from_kuid</span>(&amp;init_user_ns,</span><br><span class="line">                    binder_context_mgr_uid));</span><br><span class="line">            ret = -EPERM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        binder_context_mgr_uid = curr_euid;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_context_mgr_node = <span class="built_in">binder_new_node</span>(proc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成为context_manager就是把ServiceManager进程的信息保存到了binder驱动的binder_context_mgr_node结构体中。想要更深入分析需要了解内核编程，这里暂时就不详细分析了。</p>
<h3 id="binder-loop循环"><a href="#binder-loop循环" class="headerlink" title="binder_loop循环"></a>binder_loop循环</h3><p>然后就进入了<code>binder_loop</code>,该函数的第二个参数非常重要，接收到消息后都是在改函数中进行处理的。先看下<code>binder_loop</code>函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binder_loop</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line">    <span class="type">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//binder主线程？</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="built_in">binder_write</span>(bs, readbuf, <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="built_in">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: ioctl failed (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">binder_parse</span>(bs, <span class="number">0</span>, (<span class="type">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: unexpected reply?!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: io error %d %s\n&quot;</span>, res, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Android13: Activity启动流程</title>
    <url>/posts/93b40782.html</url>
    <content><![CDATA[<!-- toc -->

<p>本文以时序图的形式来展示activity的启动过程，相比于贴源码会更加直观。本文的讲解的流程是基于<code>MainActivity</code>使用standard模式启动<code>SecondActivity</code>，且两个Activity都在同一个应用中，最后的部分也会讲解一下进程的启动。</p>
<h2 id="第一阶段：执行startActivity"><a href="#第一阶段：执行startActivity" class="headerlink" title="第一阶段：执行startActivity"></a>第一阶段：执行startActivity</h2><pre class="mermaid">

zenuml
group App {
    &lt;&lt;App&gt;&gt; act as Activity
    &lt;&lt;App&gt;&gt; ins as Instrumentation
}
group AMS {
    &lt;&lt;AMS&gt;&gt; atms as ActivityTaskManagerService #F0F8FF
    ActivityStarter #F0F8FF
}
act.startActivity {
    act.startActivityForResult {
        ins.execStartActivity {
            atms.startActivity {
                atms.startActivityAsUser {
                    &#x2F;&#x2F;没有缓存则创建
                    new ActivityStarter()
                    ActivityStarter.&quot;① execute&quot;
                }
            }
        }
    }
}
</pre>

<pre class="mermaid">

zenuml
&lt;&lt;AMS&gt;&gt; ActivityStarter #F0F8FF
ActivityStarter.&quot;① execute&quot; {
    executeRequest {
        new ActivityRecord()
        startActivityUnchecked {
            startActivityInner {
                Task.addChild
                Task.startActivityLocked
                RootWindowContainer.resumeFocusedTasksTopActivities {
                    Task.resumeTopActivityUncheckedLocked {
                        resumeTopActivityInnerLocked {
                            TaskFragment.resumeTopActivity {
                                &#x2F;&#x2F;pause当前activity
                                &quot;② startPausing()&quot;
                                if (! isProcessRunning) {
                                    ActivityTaskManagerService.startProcessAsync
                                }
                            }
                        }
                    }
                }
            }
            handleStartResult
            postStartActivityProcessing
        }
    }
}
</pre>

<h2 id="第二阶段：pause当前activity"><a href="#第二阶段：pause当前activity" class="headerlink" title="第二阶段：pause当前activity"></a>第二阶段：pause当前activity</h2><p>启动<code>SecondActivity</code>之前会先执行<code>MainActivity</code>的<strong>pause</strong>操作：</p>
<img src="\assert\puml\af8cd81dee6672e6f6a20a10468fb62bfb7ef4461d0bf7676b888ad21293248a.svg"/>

<p>在Android 9之前的版本，<code>ActivityThread</code>中通过<code>LAUNCH_ACTIVITY</code>消息来启动activity，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android\app\ActivityThread.java</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityStart&quot;</span>);</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                    handleLaunchActivity(r, <span class="literal">null</span>, <span class="string">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>但从Andorid 9开始，<code>ActivityThread</code>去掉了<code>LAUNCH_ACTIVITY</code> <code>PAUSE_ACTIVITY</code> <code>RESUME_ACTIVITY</code>等消息，而是改成了EXECUTE_TRANSACTION，通过ClientTransaction这套机制来执行activity生命周期流程，相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> (ClientTransaction) msg.obj;</span><br><span class="line">            mTransactionExecutor.execute(transaction);</span><br><span class="line">            <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">                <span class="comment">// Client transactions inside system process are recycled on the client side</span></span><br><span class="line">                <span class="comment">// instead of ClientLifecycleManager to avoid being cleared before this</span></span><br><span class="line">                <span class="comment">// message is handled.</span></span><br><span class="line">                transaction.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>下面是<code>ClientTransaction</code>类图：</p>
<p><img src="/images/Android/Activity_Transaction%E7%B1%BB%E5%9B%BE.drawio.svg" alt="Activity Transaction"></p>
<h2 id="第三阶段：启动新Activity"><a href="#第三阶段：启动新Activity" class="headerlink" title="第三阶段：启动新Activity"></a>第三阶段：启动新Activity</h2><p>下面继续Activity启动流程：</p>
<img src="\assert\puml\263aec74e1347cf395906f401c5d05e5870918c03946c34837af9d65139e0d5c.svg"/>

<p>执行<code>SecondAcitivity</code>的启动流程：</p>
<img src="\assert\puml\8f597172f5a16153dcbfe468e77efa4ee4b7059593673287f4583b3af72fe22d.svg"/>

<img src="\assert\puml\3bcfe12610278113939a68ac5bb2704fc69439c70b49710d89fff49917d51b30.svg"/>

<h2 id="第四阶段：View添加到Window"><a href="#第四阶段：View添加到Window" class="headerlink" title="第四阶段：View添加到Window"></a>第四阶段：View添加到Window</h2><img src="\assert\puml\3d503e05c50ab5418d77a651aaf07091465229526edbb7a50e14feee684abb65.svg"/>

<p>通过<a href="https://developer.android.google.cn/studio/profile/hierarchy-viewer">Hierarchy Viewer</a>看下DecorView结构：</p>
<p><img src="/images/Android/DecorView%E7%A4%BA%E4%BE%8B.png" alt="DecorView示例"></p>
<p>用户自定义的View会被添加到PhoneWindow.mContentParent中，而mContentParent是DecorView的一个子孙View。</p>
<p>下面是Activity、Task之间的类图关系：</p>
<img src="\assert\puml\10b3fa2523947201df50f6639920ed45fbdb4275b64aa4ca708e4adab6eefd67.svg"/>

<h2 id="启动新APP进程"><a href="#启动新APP进程" class="headerlink" title="启动新APP进程"></a>启动新APP进程</h2><p>如果需要启动的activity不在同一个app中，就需要启动新的进程。</p>
<pre class="mermaid">

zenuml
ActivityTaskManagerService.startProcessAsync {
    H.sendMessage {
        ActivityManagerService.startProcess {
            startProcessLocked {
                ProcessList.startProcessLocked {
                    newProcessRecordLocked {
                        new ProcessRecord()
                    }
                    &#x2F;&#x2F;with ProcessRecord
                    startProcessLocked {
                        ProcessList.&quot;配置runtimeFlags&quot;
                        &#x2F;&#x2F;异步启动线程
                        ProcessList -&gt; ActivityManagerService : mProcStartHandler.post
                    }
                }
            }
        }
    }
}
</pre>

<pre class="mermaid">

zenuml
ActivityManagerService.&quot;mProcStartHandler.dispatchMessage&quot; {
    ProcessList.handleProcessStart {
        startProcess {
            ProcessStartResult &#x3D; Process.start {
                ProcessStartResult &#x3D; ZygoteProcess.start {
                    startViaZygote {
                        ZygoteProcess.&quot;组装参数列表args&quot;
                        zygoteSendArgsAndGetResult {
                            &#x2F;&#x2F;通过LocalSocket向zygote发送进程启动参数
                            &#x2F;&#x2F;并阻塞读取进程pid
                            attemptZygoteSendArgsAndGetResult
                        }
                    }
                }
            }
        }
        handleProcessStartedLocked {
            ActivityManagerService.addPidLocked {
                ActivityTaskManagerService.&quot;onProcessMapped(pid, WindowProcessController)&quot; {
                    ActivityTaskManagerService.&quot;mProcessMap.put(pid, proc)&quot;
                }
            }
        }
    }
}
</pre>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-13.0.0_r41\frameworks\base\core\java\android\os\ZygoteProcess.java</span></span><br><span class="line">    <span class="keyword">private</span> Process.ProcessStartResult <span class="title function_">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span><br><span class="line"><span class="params">            ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">BufferedWriter</span> <span class="variable">zygoteWriter</span> <span class="operator">=</span> zygoteState.mZygoteOutputWriter;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">DataInputStream</span> <span class="variable">zygoteInputStream</span> <span class="operator">=</span> zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过LocalSocket将进程启动参数传输给zygote进程</span></span><br><span class="line">            zygoteWriter.write(msgStr);</span><br><span class="line">            zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">            Process.<span class="type">ProcessStartResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Process</span>.ProcessStartResult();</span><br><span class="line">            <span class="comment">//读取新进程的pid</span></span><br><span class="line">            result.pid = zygoteInputStream.readInt();</span><br><span class="line">            result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteStartFailedEx</span>(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">&quot;IO Exception while communicating with Zygote - &quot;</span></span><br><span class="line">                    + ex.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ZygoteStartFailedEx</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>新的app进程启动运行的入口是<code>ActivityThread.main</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//初始化主线程Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//创建ActivityThread</span></span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//启动主线程消息循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">

zenuml
group App {
    ApplicationThread
    Application
    ActivityThread
    mH
}
group AMS {
    ActivityManagerService
}
ActivityThread.attach {
    ActivityManagerService.attachApplication {
        Binder.getCallingPid
        attachApplicationLocked {
            &quot;根据pid获取ProcessRecord&quot;
            ApplicationThread.bindApplication {
                mH.sendMessage(BIND_APPLICATION)
            }
        }
    }
}
ActivityThread.handleMessage(BIND_APPLICATION) {
    handleBindApplication {
        new Application()
        Application.attachBaseContext()
        Application.onCreate()
    }
}
</pre>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler源码解析</title>
    <url>/posts/48a4fa29.html</url>
    <content><![CDATA[<h2 id="当前线程启动消息队列"><a href="#当前线程启动消息队列" class="headerlink" title="当前线程启动消息队列"></a>当前线程启动消息队列</h2><p>Thread默认是没有消息循环机制的，而Looper就是在Thread基础上运行一个消息循环，通过<code>Looper.prepare()</code>可以把当前线程初始化为一个<strong>Looper thread</strong>。一个典型的Looper thread创建示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LooperThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.myLooper()) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="comment">//在此处理消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码分为三部：1）调用Looper.prepare()初始化Looper；2）创建一个Handler用于与Looper进行交互；3）调用Looper.loop()启动消息循环。下面分别看下这三步是如何实现的：</p>
<h3 id="初始化Looper-prepare"><a href="#初始化Looper-prepare" class="headerlink" title="初始化Looper.prepare()"></a>初始化Looper.prepare()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\java\android\os\Looper.java</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123; <span class="comment">//prepare是静态方法</span></span><br><span class="line">        prepare(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//一个线程中Looper.prepare()只能执行一次，否则会抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造了一个Looper放到ThreadLocal中</span></span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Looper的构造方法也很简单：1）创建消息队列；2）获取当先线程句柄；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Handler"><a href="#创建Handler" class="headerlink" title="创建Handler"></a>创建Handler</h3><p>用户无法直接使用Looper来进行消息发送和处理，而是需要通过一个Handler来实现。使用Handler可以发送和处理Message，或者运行一个Runnable。每个Handler都会绑定一个Looper，Handler将会把message和runnable投递到Looper的消息队列中，然后Looper thread将会执行这些message和runnable。</p>
<p>下图是Handler与Looper、Thread、MessageQueue之间的对应关系，Thread和Looper是一对一的关系，否则会抛出异常，一个Looper只有一个消息队列，但是可以多个Handler对应同一个Looper。</p>
<img src="\assert\puml\33d2988d69d295c768a9221d9521997902e123382595230517895709c863b57c.svg"/>

<p>下面看下Handler的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">        ...... <span class="comment">//代码省略</span></span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">//默认使用当前线程关联的looper，也可以通过其他构造函数来指定使用哪个Looper</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue; <span class="comment">//获取Looper的消息队列</span></span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\java\android\os\Looper.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get(); <span class="comment">//从ThreadLocal中获取当前线程关联的Looper</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动消息循环"><a href="#启动消息循环" class="headerlink" title="启动消息循环"></a>启动消息循环</h3><p>下面代码是一个精简版代码（精简了debug、异常处理等相关逻辑），但基本逻辑不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">        me.mInLoop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//forever loop</span></span><br><span class="line">            <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Poll and deliver single message, return true if the outer loop should continue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me, <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// 从消息队列中读取消息，如果消息队列为空将会堵塞等待</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//msg.target就是Handler，调用Handler.dispatchMessage进行消息处理</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\java\android\os\Handler.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123; <span class="comment">//callback就是Runnable</span></span><br><span class="line">            handleCallback(msg); <span class="comment">//执行Runnable.run()</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg); <span class="comment">//处理message消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息发送-Handler-post"><a href="#消息发送-Handler-post" class="headerlink" title="消息发送 Handler.post()"></a>消息发送 Handler.post()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\java\android\os\Handler.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 通过getPostMessage将Runnable转换为Message，然后调用sendMessageDelayed</span></span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain(); <span class="comment">//从消息池中获取一个消息，是为了消息的复用，避免重新new一个类</span></span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码通过post执行一个Runnable，通过getPostMessage把Runnable转换为Message，然后调用sendMessageDelayed：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前系统时间，加上延时时间就是消息被执行的时间，然后调用sendMessageAtTime</span></span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>; <span class="comment">//Message的target字段指向Handler自身，target就是消息的最终投递目的地</span></span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息插入队列，并指定消息投递时间</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Handler的post来执行任务最终会被加入到Looper的消息队列中，即MessageQueue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\java\android\os\MessageQueue.java</span></span><br><span class="line"><span class="comment">// MessageQueue通过一个单项链表维护Message</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">        ...... <span class="comment">//代码省略</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="type">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">//队列为空，或者队列中的消息投递时间比新消息晚，就会把新消息放在队首。</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123; <span class="comment">//按照投递时间先后进行排序插入</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p;</span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123; <span class="comment">//判断是否需要唤醒线程</span></span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>nativeWake</code>的源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\jni\android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//android-12.1.0_r27\system\core\libutils\Looper.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;%p ~ wake&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;</span>,</span><br><span class="line">                             mWakeEventFd.<span class="built_in">get</span>(), nWrite, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从消息队列获取消息"><a href="#从消息队列获取消息" class="headerlink" title="从消息队列获取消息"></a>从消息队列获取消息</h2><p>Looper.loop()会通过MessageQueue.next()不断从消息队列获取消息，如果队列为空，线程就会阻塞等待。下面是next()对应的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr; <span class="comment">//mPtr是一个long类型，是native层c++类NativeMessageQueue对象的指针</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis); <span class="comment">//阻塞等待，第二个参数是超时时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages; <span class="comment">//mMessages是个单项链表，这里是获取链表首位的Message</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//msg.target==null表示这个Message是同步屏障，将会暂停执行队列中的同步消息，</span></span><br><span class="line">                <span class="comment">//异步消息不受同步屏障的影响，所以找到下一个异步消息</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//下个消息还没有到执行时间，因此计算出需要阻塞等待的时间，即阻塞等待的超时时间</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h2><p>当消息队列中没有消息，消息循环将要去阻塞等待新消息的时候会执行IdleHandler。IdleHandler使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.myLooper().getQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">MessageQueue</span>.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//返回false表示任务只执行一次，任务完成后将会被移除任务；</span></span><br><span class="line">    <span class="comment">//返回true表示下次消息循环将要阻塞时还会执行这个任务;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="消息阻塞等待的底层实现"><a href="#消息阻塞等待的底层实现" class="headerlink" title="消息阻塞等待的底层实现"></a>消息阻塞等待的底层实现</h2><p>当消息队列中没有消息，或者消息的执行时间还没有到，消息队列的执行线程会进入阻塞等待状态。在MessageQueue.next()中通过调用<code>nativePollOnce</code>方法进行阻塞等待。nativePollOnce()方法定义如下，是一个native函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativePollOnce</span><span class="params">(<span class="type">long</span> ptr, <span class="type">int</span> timeoutMillis)</span>; <span class="comment">/*non-static for callbacks*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数<code>ptr</code>是native层C++ NativeMessageQueue对象的指针。</li>
<li>第二个参数<code>timeoutMillis</code>是阻塞等待超时时间，当达到超时时间后，会自动唤醒。阻塞的超时时间就是下个消息的执行时间减去当前系统时间得到的时间差。如果消息队列为空，则超时时间会传入-1，会一直阻塞，直到新消息插入后唤醒。</li>
</ul>
<p><code>nativePollOnce</code>的native实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\core\jni\android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将java层传下来的ptr参数强转成NativeMessageQueue对象指针</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">//调用NativeMessageQueue#pollOnce方法</span></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">pollOnce</span>(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;<span class="built_in">pollOnce</span>(timeoutMillis); <span class="comment">//调用native层Looper对象的pollOnce方法</span></span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">Throw</span>(mExceptionObj);</span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>native层的Looper函数在<code>system\core\libutils\Looper.cpp</code>文件中实现，native层的<code>Looper#pollOnce</code>方法实现代码很长，这里就不贴代码了，原理简要描述下：</p>
<p>native层的Looper类通过linux <a href="https://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd</a>和<a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>两个机制来完成线程间通信。eventfd是用于事件通知机制的文件描述符，epoll则用于监控eventfd的I/O事件，两者结合可以实现事件的等待和通知。</p>
<p>构造时会通过linux函数<code>epoll_create1</code>创建一个epoll实例，并关联一个读写文件描述符，然后在pollOnce方法中，通过epoll_wait来监听这个文件描述符的I/O事件，收到事件或者超时后就会唤醒，否则线程就处于阻塞等待状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\system\core\libutils\include\utils\Looper.h</span></span><br><span class="line">    <span class="comment">//unique_fd是android用于管理文件描述符的类，当离开作用域后文件会被自动关闭，在这里把它等同于文件描述符理解即可</span></span><br><span class="line">    android::base::unique_fd mWakeEventFd;  <span class="comment">//eventfd文件描述符</span></span><br><span class="line">    android::base::unique_fd mEpollFd; <span class="comment">//创建epoll实例后返回的文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//android-12.1.0_r27\system\core\libutils\Looper.cpp</span></span><br><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks)</span><br><span class="line">    : <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks),</span><br><span class="line">      <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mPolling</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mEpollRebuildRequired</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mNextRequestSeq</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mResponseIndex</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    <span class="comment">//调用eventfd系统函数创建eventfd，函数返回一个文件描述符，然后赋值给mWakeEventFd</span></span><br><span class="line">    mWakeEventFd.<span class="built_in">reset</span>(<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd.<span class="built_in">get</span>() &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...... <span class="comment">//代码省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll_create1方法创建一个epoll实例，返回的文件描述符赋值给mEpollFd</span></span><br><span class="line">    mEpollFd.<span class="built_in">reset</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    eventItem.events = EPOLLIN; <span class="comment">//设置eventfd为可读</span></span><br><span class="line">    eventItem.data.fd = mWakeEventFd.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">//把eventfd文件描述符添加到epoll的监控列表中</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class="built_in">get</span>(), &amp;eventItem);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面代码实现了堵塞等待，并设置超时事件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//system\core\libutils\Looper.cpp文件的Looper::pollInner方法中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.<span class="built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">//因为epoll支持同时监控多个文件描述符，因此循环查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="built_in">awoken</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::awoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">uint64_t</span> counter;</span><br><span class="line">    <span class="comment">//从eventfd文件中读取一个int内容</span></span><br><span class="line">    <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">read</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;counter, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒堵塞等待的线程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//向eventfd文件描述符中写入一个int值</span></span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitmap内存分配以及回收</title>
    <url>/posts/68833f9e.html</url>
    <content><![CDATA[<h2 id="Bitmap内存分配"><a href="#Bitmap内存分配" class="headerlink" title="Bitmap内存分配"></a>Bitmap内存分配</h2><ul>
<li>Android 2.3.3 (API level 10)以及更早的Android版本中，Bitmap的像素数据保存在native内存中，像素数据内存的回收则在finalize()中进行回收，存在很大的不确定性，很容易导致OOM的发生；</li>
<li>从Android 3.0 (API level 11) 到Android 7.1 (API level 25)，像素数据存放在Java Heap中，跟Bitmap对象一起回收。但由于图片是内存消耗大户，所以也很容易导致OOM，以及频繁的GC导致内存抖动问题。</li>
<li>在Android 8.0 (API level 26)以及更高的版本中，像素数据保存在native heap中。通过一个辅助类<code>NativeAllocationRegistry</code>来实现native内存的回收。</li>
</ul>
<p>在android.graphics.BitmapFactory类中有一系列函数可以解码生成Bitmap：</p>
<ul>
<li>Bitmap decodeByteArray(byte[] data, int offset, int length)</li>
<li>Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</li>
<li>Bitmap decodeFile(String pathName)</li>
<li>Bitmap decodeFile(String pathName, Options opts)</li>
<li>…… 等等</li>
</ul>
<p>这些方法都会调用到jni层<code>frameworks\base\libs\hwui\jni\BitmapFactory.cpp</code>,最终都会走到<code>doDecode</code>方法：</p>
<h3 id="Android-12位图解码，使用native内存"><a href="#Android-12位图解码，使用native内存" class="headerlink" title="Android 12位图解码，使用native内存"></a>Android 12位图解码，使用native内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\libs\hwui\jni\BitmapFactory.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv* env, std::unique_ptr&lt;SkStreamRewindable&gt; stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                        jobject padding, jobject options, jlong inBitmapHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                        jlong colorSpaceHandle)</span> </span>&#123;</span><br><span class="line">    ...... <span class="comment">//代码省略</span></span><br><span class="line">    <span class="comment">// Scale is necessary due to density differences.</span></span><br><span class="line">    <span class="keyword">if</span> (scale != <span class="number">1.0f</span>) &#123;</span><br><span class="line">        willScale = <span class="literal">true</span>;</span><br><span class="line">        scaledWidth = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(scaledWidth * scale + <span class="number">0.5f</span>);</span><br><span class="line">        scaledHeight = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(scaledHeight * scale + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android::Bitmap* reuseBitmap = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> existingBufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        reuseBitmap = &amp;bitmap::<span class="built_in">toBitmap</span>(inBitmapHandle);</span><br><span class="line">        <span class="keyword">if</span> (reuseBitmap-&gt;<span class="built_in">isImmutable</span>()) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Unable to reuse an immutable bitmap as an image decoder target.&quot;</span>);</span><br><span class="line">            javaBitmap = <span class="literal">nullptr</span>;</span><br><span class="line">            reuseBitmap = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            existingBufferSize = reuseBitmap-&gt;<span class="built_in">getAllocationByteCount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HeapAllocator defaultAllocator;</span><br><span class="line">    <span class="function">RecyclingPixelAllocator <span class="title">recyclingAllocator</span><span class="params">(reuseBitmap, existingBufferSize)</span></span>;</span><br><span class="line">    <span class="function">ScaleCheckingAllocator <span class="title">scaleCheckingAllocator</span><span class="params">(scale, existingBufferSize)</span></span>;</span><br><span class="line">    SkBitmap::HeapAllocator heapAllocator;</span><br><span class="line">    SkBitmap::Allocator* decodeAllocator;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span> &amp;&amp; willScale) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator, since there will be an extra</span></span><br><span class="line">        <span class="comment">// scaling step that copies these pixels into Java memory.  This allocator</span></span><br><span class="line">        <span class="comment">// also checks that the recycled javaBitmap is large enough.</span></span><br><span class="line">        decodeAllocator = &amp;scaleCheckingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        decodeAllocator = &amp;recyclingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (willScale || isHardware) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator,</span></span><br><span class="line">        <span class="comment">// for scale case: there will be an extra scaling step.</span></span><br><span class="line">        <span class="comment">// for hardware case: there will be extra swizzling &amp; upload to gralloc step.</span></span><br><span class="line">        decodeAllocator = &amp;heapAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeAllocator = &amp;defaultAllocator;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    SkBitmap decodingBitmap; <span class="comment">//SkBitmap 是skia库中的类</span></span><br><span class="line">    <span class="comment">//decodingBitmap.tryAllocPixels的作用是分配piexel内存，最终调用的是</span></span><br><span class="line">    <span class="comment">//decodeAllocator-&gt;allocPixelRef(this);</span></span><br><span class="line">    <span class="keyword">if</span> (!decodingBitmap.<span class="built_in">setInfo</span>(bitmapInfo) ||</span><br><span class="line">            !decodingBitmap.<span class="built_in">tryAllocPixels</span>(decodeAllocator)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use SkAndroidCodec to perform the decode.</span></span><br><span class="line">    SkAndroidCodec::AndroidOptions codecOptions;</span><br><span class="line">    codecOptions.fZeroInitialized = decodeAllocator == &amp;defaultAllocator ?</span><br><span class="line">            SkCodec::kYes_ZeroInitialized : SkCodec::kNo_ZeroInitialized;</span><br><span class="line">    codecOptions.fSampleSize = sampleSize;</span><br><span class="line">    <span class="comment">//codec指的是SkAndroidCodec，是skia库中的类。下面这句代码就是真正的解码了</span></span><br><span class="line">    SkCodec::Result result = codec-&gt;<span class="built_in">getAndroidPixels</span>(decodeInfo, decodingBitmap.<span class="built_in">getPixels</span>(), </span><br><span class="line">            decodingBitmap.<span class="built_in">rowBytes</span>(), &amp;codecOptions);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//按比例缩放位图</span></span><br><span class="line">    SkBitmap outputBitmap;</span><br><span class="line">    <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">        <span class="comment">// Set the allocator for the outputBitmap.</span></span><br><span class="line">        SkBitmap::Allocator* outputAllocator;</span><br><span class="line">        <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            outputAllocator = &amp;recyclingAllocator;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputAllocator = &amp;defaultAllocator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkColorType scaledColorType = decodingBitmap.<span class="built_in">colorType</span>();</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> If the alphaType is kUnpremul and the image has alpha, the</span></span><br><span class="line">        <span class="comment">// colors may not be correct, since Skia does not yet support drawing</span></span><br><span class="line">        <span class="comment">// to/from unpremultiplied bitmaps.</span></span><br><span class="line">        outputBitmap.<span class="built_in">setInfo</span>(</span><br><span class="line">                bitmapInfo.<span class="built_in">makeWH</span>(scaledWidth, scaledHeight).<span class="built_in">makeColorType</span>(scaledColorType));</span><br><span class="line">        <span class="keyword">if</span> (!outputBitmap.<span class="built_in">tryAllocPixels</span>(outputAllocator)) &#123;</span><br><span class="line">            <span class="comment">// This should only fail on OOM.  The recyclingAllocator should have</span></span><br><span class="line">            <span class="comment">// enough memory since we check this before decoding using the</span></span><br><span class="line">            <span class="comment">// scaleCheckingAllocator.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;allocation failed for scaled bitmap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkPaint paint;</span><br><span class="line">        <span class="comment">// kSrc_Mode instructs us to overwrite the uninitialized pixels in</span></span><br><span class="line">        <span class="comment">// outputBitmap.  Otherwise we would blend by default, which is not</span></span><br><span class="line">        <span class="comment">// what we want.</span></span><br><span class="line">        paint.<span class="built_in">setBlendMode</span>(SkBlendMode::kSrc);</span><br><span class="line"></span><br><span class="line">        <span class="function">SkCanvas <span class="title">canvas</span><span class="params">(outputBitmap, SkCanvas::ColorBehavior::kLegacy)</span></span>;</span><br><span class="line">        canvas.<span class="built_in">scale</span>(scaleX, scaleY);</span><br><span class="line">        decodingBitmap.<span class="built_in">setImmutable</span>(); <span class="comment">// so .asImage() doesn&#x27;t make a copy</span></span><br><span class="line">        canvas.<span class="built_in">drawImage</span>(decodingBitmap.<span class="built_in">asImage</span>(), <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">                         <span class="built_in">SkSamplingOptions</span>(SkFilterMode::kLinear), &amp;paint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outputBitmap.<span class="built_in">swap</span>(decodingBitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//硬件位图</span></span><br><span class="line">    <span class="keyword">if</span> (isHardware) &#123;</span><br><span class="line">        <span class="comment">//GPU中分配位图内存。原outputBitmap是否需要释放呢？在哪释放？</span></span><br><span class="line">        sk_sp&lt;Bitmap&gt; hardwareBitmap = Bitmap::<span class="built_in">allocateHardwareBitmap</span>(outputBitmap);</span><br><span class="line">        <span class="keyword">if</span> (!hardwareBitmap.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;Failed to allocate a hardware bitmap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建java层Bitmap，此处的hardwareBitmap.release()不是资源回收的意思，而是取出sk_sp中的Bitmap实例。</span></span><br><span class="line">        <span class="keyword">return</span> bitmap::<span class="built_in">createBitmap</span>(env, hardwareBitmap.<span class="built_in">release</span>(), bitmapCreateFlags,</span><br><span class="line">                ninePatchChunk, ninePatchInsets, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now create the java bitmap</span></span><br><span class="line">    <span class="keyword">return</span> bitmap::<span class="built_in">createBitmap</span>(env, defaultAllocator.<span class="built_in">getStorageObjAndReset</span>(),</span><br><span class="line">            bitmapCreateFlags, ninePatchChunk, ninePatchInsets, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认pixel内存分配"><a href="#默认pixel内存分配" class="headerlink" title="默认pixel内存分配"></a>默认pixel内存分配</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapAllocator::allocPixelRef</span><span class="params">(SkBitmap* bitmap)</span> </span>&#123;</span><br><span class="line">    mStorage = android::Bitmap::<span class="built_in">allocateHeapBitmap</span>(bitmap);</span><br><span class="line">    <span class="keyword">return</span> !!mStorage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//frameworks\base\libs\hwui\hwui\Bitmap.cpp</span></span><br><span class="line"><span class="function">sk_sp&lt;Bitmap&gt; <span class="title">Bitmap::allocateHeapBitmap</span><span class="params">(SkBitmap* bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">allocateBitmap</span>(bitmap, &amp;Bitmap::allocateHeapBitmap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> sk_sp&lt;Bitmap&gt; <span class="title">allocateBitmap</span><span class="params">(SkBitmap* bitmap, AllocPixelRef alloc)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> SkImageInfo&amp; info = bitmap-&gt;<span class="built_in">info</span>();</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="built_in">colorType</span>() == kUnknown_SkColorType) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;unknown bitmap configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we must respect the rowBytes value already set on the bitmap instead of</span></span><br><span class="line">    <span class="comment">// attempting to compute our own.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> rowBytes = bitmap-&gt;<span class="built_in">rowBytes</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Bitmap::<span class="built_in">computeAllocationSize</span>(rowBytes, bitmap-&gt;<span class="built_in">height</span>(), &amp;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> wrapper = <span class="built_in">alloc</span>(size, info, rowBytes); <span class="comment">//使用入参的alloc函数分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (wrapper) &#123;</span><br><span class="line">        wrapper-&gt;<span class="built_in">getSkBitmap</span>(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sk_sp&lt;Bitmap&gt; <span class="title">Bitmap::allocateHeapBitmap</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> SkImageInfo&amp; info, <span class="type">size_t</span> rowBytes)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">calloc</span>(size, <span class="number">1</span>); <span class="comment">//调用Linux C库函数分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sk_sp</span>&lt;Bitmap&gt;(<span class="keyword">new</span> <span class="built_in">Bitmap</span>(addr, size, info, rowBytes)); <span class="comment">//返回最终的Bitmap对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比例缩放或硬件位图场景内存分配"><a href="#比例缩放或硬件位图场景内存分配" class="headerlink" title="比例缩放或硬件位图场景内存分配"></a>比例缩放或硬件位图场景内存分配</h4><p>在需要将图片进行按比例缩放，或者使用硬件内存时，使用SkBitmap::HeapAllocator来分配内存。当解码位图时如果配置了<code>android.graphics.Bitmap.Config#HARDWARE</code>就会使用硬件位图。硬件位图是一种 Android O 添加的新的位图格式。硬件位图仅在显存 (graphic memory) 里存储像素数据，并对图片仅在屏幕上绘制的场景做了优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//external\skia\src\core\SkBitmap.cpp</span></span><br><span class="line"><span class="type">bool</span> SkBitmap::HeapAllocator::<span class="built_in">allocPixelRef</span>(SkBitmap* dst) &#123;</span><br><span class="line">    <span class="type">const</span> SkImageInfo&amp; info = dst-&gt;<span class="built_in">info</span>();</span><br><span class="line">    <span class="keyword">if</span> (kUnknown_SkColorType == info.<span class="built_in">colorType</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sk_sp&lt;SkPixelRef&gt; pr = SkMallocPixelRef::<span class="built_in">MakeAllocate</span>(info, dst-&gt;<span class="built_in">rowBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (!pr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;<span class="built_in">setPixelRef</span>(std::<span class="built_in">move</span>(pr), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//external\skia\src\core\SkMallocPixelRef.cpp</span></span><br><span class="line"><span class="function">sk_sp&lt;SkPixelRef&gt; <span class="title">SkMallocPixelRef::MakeAllocate</span><span class="params">(<span class="type">const</span> SkImageInfo&amp; info, <span class="type">size_t</span> rowBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rowBytes == <span class="number">0</span>) &#123;</span><br><span class="line">        rowBytes = info.<span class="built_in">minRowBytes</span>();</span><br><span class="line">        <span class="comment">// rowBytes can still be zero, if it overflowed (width * bytesPerPixel &gt; size_t)</span></span><br><span class="line">        <span class="comment">// or if colortype is unknown</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_valid</span>(info) || !info.<span class="built_in">validRowBytes</span>(rowBytes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> size = info.<span class="built_in">computeByteSize</span>(rowBytes);</span><br><span class="line">    <span class="keyword">if</span> (SkImageInfo::<span class="built_in">ByteSizeOverflowed</span>(size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SK_BUILD_FOR_FUZZER)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">sk_calloc_canfail</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == addr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PixelRef</span> <span class="keyword">final</span> : <span class="keyword">public</span> SkPixelRef &#123;</span><br><span class="line">        <span class="built_in">PixelRef</span>(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">void</span>* s, <span class="type">size_t</span> r) : <span class="built_in">SkPixelRef</span>(w, h, s, r) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">PixelRef</span>() <span class="keyword">override</span> &#123; <span class="built_in">sk_free</span>(<span class="keyword">this</span>-&gt;<span class="built_in">pixels</span>()); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sk_sp</span>&lt;SkPixelRef&gt;(<span class="keyword">new</span> <span class="built_in">PixelRef</span>(info.<span class="built_in">width</span>(), info.<span class="built_in">height</span>(), addr, rowBytes));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//external\skia\include\private\SkMalloc.h</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>* <span class="title">sk_calloc_canfail</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SK_BUILD_FOR_FUZZER)</span></span><br><span class="line">    <span class="comment">// To reduce the chance of OOM, pretend we can&#x27;t allocate more than 200kb.</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">200000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sk_malloc_flags</span>(size, SK_MALLOC_ZERO_INITIALIZE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//external\skia\src\ports\SkMemory_malloc.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sk_malloc_flags</span><span class="params">(<span class="type">size_t</span> size, <span class="type">unsigned</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* p;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SK_MALLOC_ZERO_INITIALIZE) &#123;</span><br><span class="line">        p = <span class="built_in">calloc</span>(size, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SK_BUILD_FOR_ANDROID_FRAMEWORK) &amp;&amp; defined(__BIONIC__)</span></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> After b/169449588 is fixed, we will want to change this to restore</span></span><br><span class="line"><span class="comment">         *       original behavior instead of always disabling the flag.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> After b/158870657 is fixed and scudo is used globally, we can assert when an</span></span><br><span class="line"><span class="comment">         *       an error is returned.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// malloc() generally doesn&#x27;t initialize its memory and that&#x27;s a huge security hole,</span></span><br><span class="line">        <span class="comment">// so Android has replaced its malloc() with one that zeros memory,</span></span><br><span class="line">        <span class="comment">// but that&#x27;s a huge performance hit for HWUI, so turn it back off again.</span></span><br><span class="line">        (<span class="type">void</span>)<span class="built_in">mallopt</span>(M_THREAD_DISABLE_MEM_INIT, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        p = <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(SK_BUILD_FOR_ANDROID_FRAMEWORK) &amp;&amp; defined(__BIONIC__)</span></span><br><span class="line">        (<span class="type">void</span>)<span class="built_in">mallopt</span>(M_THREAD_DISABLE_MEM_INIT, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SK_MALLOC_THROW) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">throw_on_failure</span>(size, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Android-7使用Java内存"><a href="#Android-7使用Java内存" class="headerlink" title="Android 7使用Java内存"></a>Android 7使用Java内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\core\jni\android\graphics\BitmapFactory.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options)</span> </span>&#123;</span><br><span class="line">    ...... <span class="comment">//代码省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JavaPixelAllocator就是从Java heap中分配内存，JavaPixelAllocator中通过</span></span><br><span class="line">    <span class="comment">//使用dalvik.system.VMRuntime.getRuntime().newNonMovableArray来申请内存</span></span><br><span class="line">    <span class="function">JavaPixelAllocator <span class="title">javaAllocator</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="comment">//复用inBitmap</span></span><br><span class="line">    <span class="function">RecyclingPixelAllocator <span class="title">recyclingAllocator</span><span class="params">(reuseBitmap, existingBufferSize)</span></span>;</span><br><span class="line">    <span class="comment">//ScaleCheckingAllocator内部通过SkBitmap::HeapAllocator来申请native内存，但是</span></span><br><span class="line">    <span class="comment">//这个内存只是临时内存，在后面的scale操作时会最终申请java内存，native内存会被释放</span></span><br><span class="line">    <span class="function">ScaleCheckingAllocator <span class="title">scaleCheckingAllocator</span><span class="params">(scale, existingBufferSize)</span></span>;</span><br><span class="line">    <span class="comment">//SkBitmap::HeapAllocator是skia库提供的内存分派类，使用native内存</span></span><br><span class="line">    SkBitmap::HeapAllocator heapAllocator;</span><br><span class="line">    SkBitmap::Allocator* decodeAllocator;</span><br><span class="line">    <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span> &amp;&amp; willScale) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator, since there will be an extra</span></span><br><span class="line">        <span class="comment">// scaling step that copies these pixels into Java memory.  This allocator</span></span><br><span class="line">        <span class="comment">// also checks that the recycled javaBitmap is large enough.</span></span><br><span class="line">        decodeAllocator = &amp;scaleCheckingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        decodeAllocator = &amp;recyclingAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">        <span class="comment">// This will allocate pixels using a HeapAllocator, since there will be an extra</span></span><br><span class="line">        <span class="comment">// scaling step that copies these pixels into Java memory.</span></span><br><span class="line">        decodeAllocator = &amp;heapAllocator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeAllocator = &amp;javaAllocator;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    SkBitmap outputBitmap;</span><br><span class="line">    <span class="keyword">if</span> (willScale) &#123;</span><br><span class="line">        <span class="comment">// This is weird so let me explain: we could use the scale parameter</span></span><br><span class="line">        <span class="comment">// directly, but for historical reasons this is how the corresponding</span></span><br><span class="line">        <span class="comment">// Dalvik code has always behaved. We simply recreate the behavior here.</span></span><br><span class="line">        <span class="comment">// The result is slightly different from simply using scale because of</span></span><br><span class="line">        <span class="comment">// the 0.5f rounding bias applied when computing the target image size</span></span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> sx = scaledWidth / <span class="built_in">float</span>(decodingBitmap.<span class="built_in">width</span>());</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> sy = scaledHeight / <span class="built_in">float</span>(decodingBitmap.<span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the allocator for the outputBitmap.</span></span><br><span class="line">        SkBitmap::Allocator* outputAllocator;</span><br><span class="line">        <span class="keyword">if</span> (javaBitmap != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            outputAllocator = &amp;recyclingAllocator; <span class="comment">//复用inBitmap</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputAllocator = &amp;javaAllocator; <span class="comment">//使用Java内存</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkColorType scaledColorType = <span class="built_in">colorTypeForScaledOutput</span>(decodingBitmap.<span class="built_in">colorType</span>());</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> If the alphaType is kUnpremul and the image has alpha, the</span></span><br><span class="line">        <span class="comment">// colors may not be correct, since Skia does not yet support drawing</span></span><br><span class="line">        <span class="comment">// to/from unpremultiplied bitmaps.</span></span><br><span class="line">        outputBitmap.<span class="built_in">setInfo</span>(SkImageInfo::<span class="built_in">Make</span>(scaledWidth, scaledHeight,</span><br><span class="line">                scaledColorType, decodingBitmap.<span class="built_in">alphaType</span>()));</span><br><span class="line">        <span class="keyword">if</span> (!outputBitmap.<span class="built_in">tryAllocPixels</span>(outputAllocator, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// This should only fail on OOM.  The recyclingAllocator should have</span></span><br><span class="line">            <span class="comment">// enough memory since we check this before decoding using the</span></span><br><span class="line">            <span class="comment">// scaleCheckingAllocator.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;allocation failed for scaled bitmap&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkPaint paint;</span><br><span class="line">        <span class="comment">// kSrc_Mode instructs us to overwrite the unininitialized pixels in</span></span><br><span class="line">        <span class="comment">// outputBitmap.  Otherwise we would blend by default, which is not</span></span><br><span class="line">        <span class="comment">// what we want.</span></span><br><span class="line">        paint.<span class="built_in">setXfermodeMode</span>(SkXfermode::kSrc_Mode);</span><br><span class="line">        paint.<span class="built_in">setFilterQuality</span>(kLow_SkFilterQuality);</span><br><span class="line"></span><br><span class="line">        <span class="function">SkCanvas <span class="title">canvas</span><span class="params">(outputBitmap)</span></span>;</span><br><span class="line">        canvas.<span class="built_in">scale</span>(sx, sy);</span><br><span class="line">        canvas.<span class="built_in">drawBitmap</span>(decodingBitmap, <span class="number">0.0f</span>, <span class="number">0.0f</span>, &amp;paint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outputBitmap.<span class="built_in">swap</span>(decodingBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<h3 id="Android4-4使用Java内存，支持共享内存"><a href="#Android4-4使用Java内存，支持共享内存" class="headerlink" title="Android4.4使用Java内存，支持共享内存"></a>Android4.4使用Java内存，支持共享内存</h3><img src="\assert\puml\d2a2d0997372158e82fc39fcc262b129af98cc688984cda081392f023d80dfd6.svg"/>

<h2 id="Bitmap内存回收机制"><a href="#Bitmap内存回收机制" class="headerlink" title="Bitmap内存回收机制"></a>Bitmap内存回收机制</h2><p>从Android 8.0开始，Bitmap的pixels数据放在native heap中，通过<code>NativeAllocationRegistry</code>来回收内存。这一节分析<code>NativeAllocationRegistry</code>的原理。</p>
<h3 id="NativeAllocationRegistry内存回收原理"><a href="#NativeAllocationRegistry内存回收原理" class="headerlink" title="NativeAllocationRegistry内存回收原理"></a>NativeAllocationRegistry内存回收原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\frameworks\base\graphics\java\android\graphics\Bitmap.java</span></span><br><span class="line">    Bitmap(<span class="type">long</span> nativeBitmap, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> density,</span><br><span class="line">            <span class="type">boolean</span> requestPremultiplied, <span class="type">byte</span>[] ninePatchChunk,</span><br><span class="line">            NinePatch.InsetStruct ninePatchInsets, <span class="type">boolean</span> fromMalloc) &#123;</span><br><span class="line">        ...... <span class="comment">//代码省略</span></span><br><span class="line">        mNativePtr = nativeBitmap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">allocationByteCount</span> <span class="operator">=</span> getAllocationByteCount();</span><br><span class="line">        NativeAllocationRegistry registry;</span><br><span class="line">        <span class="keyword">if</span> (fromMalloc) &#123; <span class="comment">//内存在native堆中进行分配</span></span><br><span class="line">            registry = NativeAllocationRegistry.createMalloced(</span><br><span class="line">                    Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), allocationByteCount);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//fromMalloc=false是内存在Ashmem，或者gpu上进行分配的场景</span></span><br><span class="line">            registry = NativeAllocationRegistry.createNonmalloced(</span><br><span class="line">                    Bitmap.class.getClassLoader(), nativeGetNativeFinalizer(), allocationByteCount);</span><br><span class="line">        &#125;</span><br><span class="line">        registry.registerNativeAllocation(<span class="built_in">this</span>, nativeBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeGetNativeFinalizer</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>NativeAllocationRegistry的使用比较简单，通过createMalloced/createNonmalloced来构造实例，然后调用registerNativeAllocation来进行注册。构造函数一共有3个参数，第一个是ClassLoader，第二个是nativeGetNativeFinalizer，第三个是内存大小。ClassLoader和内存大小很好理解，<code>nativeGetNativeFinalizer</code>是对应什么呢？它是一个jni函数，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android\android-12.1.0_r27\frameworks\base\libs\hwui\jni\Bitmap.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gBitmapMethods[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;   <span class="string">&quot;nativeGetNativeFinalizer&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="type">void</span>*)Bitmap_getNativeFinalizer &#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="built_in">Bitmap_destruct</span>(BitmapWrapper* bitmap) &#123;</span><br><span class="line">    <span class="keyword">delete</span> bitmap;  <span class="comment">//最终会调用到析构函数Bitmap::~Bitmap()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">Bitmap_getNativeFinalizer</span><span class="params">(JNIEnv*, jobject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;jlong&gt;(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;Bitmap_destruct));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nativeGetNativeFinalizer</code>就是native函数<code>Bitmap_destruct</code>的函数指针，<code>Bitmap_destruct</code>中会调用到native层Bitmap类的析构函数，从而释放内存。</p>
<p>继续看下<code>NativeAllocationRegistry</code>的构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NativeAllocationRegistry <span class="title function_">createNonmalloced</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ClassLoader classLoader, <span class="type">long</span> freeFunction, <span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(classLoader, freeFunction, size, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NativeAllocationRegistry <span class="title function_">createMalloced</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> ClassLoader classLoader, <span class="type">long</span> freeFunction, <span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NativeAllocationRegistry</span>(classLoader, freeFunction, size, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">NativeAllocationRegistry</span><span class="params">(ClassLoader classLoader, <span class="type">long</span> freeFunction, <span class="type">long</span> size,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> mallocAllocation)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid native allocation size: &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.classLoader = classLoader;</span><br><span class="line">    <span class="built_in">this</span>.freeFunction = freeFunction;</span><br><span class="line">    <span class="built_in">this</span>.size = mallocAllocation ? (size | IS_MALLOCED) : (size &amp; ~IS_MALLOCED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出构造函数只是给成员变量赋值。真正的工作是在registerNativeAllocation中进行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-12.1.0_r27\libcore\luni\src\main\java\libcore\util\NativeAllocationRegistry.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@NonNull</span> Runnable <span class="title function_">registerNativeAllocation</span><span class="params">(<span class="meta">@NonNull</span> Object referent, <span class="type">long</span> nativePtr)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        CleanerThunk thunk;</span><br><span class="line">        CleanerRunner result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thunk = <span class="keyword">new</span> <span class="title class_">CleanerThunk</span>();</span><br><span class="line">            <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create(referent, thunk); <span class="comment">//对应sun.misc.Cleaner</span></span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">CleanerRunner</span>(cleaner); <span class="comment">//忽略这一行，因为Bitmap调用registerNativeAllocation没有使用返回值</span></span><br><span class="line">            registerNativeAllocation(<span class="built_in">this</span>.size);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VirtualMachineError vme <span class="comment">/* probably OutOfMemoryError */</span>) &#123;</span><br><span class="line">            applyFreeFunction(freeFunction, nativePtr);</span><br><span class="line">            <span class="keyword">throw</span> vme;</span><br><span class="line">        &#125; <span class="comment">// Other exceptions are impossible.</span></span><br><span class="line">        <span class="comment">// Enable the cleaner only after we can no longer throw anything, including OOME.</span></span><br><span class="line">        thunk.setNativePtr(nativePtr);</span><br><span class="line">        <span class="comment">// Ensure that cleaner doesn&#x27;t get invoked before we enable it.</span></span><br><span class="line">        Reference.reachabilityFence(referent);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CleanerThunk</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> nativePtr;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CleanerThunk</span><span class="params">()</span> &#123; <span class="built_in">this</span>.nativePtr = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">                applyFreeFunction(freeFunction, nativePtr); <span class="comment">//回收内存</span></span><br><span class="line">                registerNativeFree(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNativePtr</span><span class="params">(<span class="type">long</span> nativePtr)</span> &#123; <span class="built_in">this</span>.nativePtr = nativePtr; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//jni函数，执行native内存回收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">applyFreeFunction</span><span class="params">(<span class="type">long</span> freeFunction, <span class="type">long</span> nativePtr)</span>;</span><br></pre></td></tr></table></figure>

<p>看来NativeAllocationRegistry是通过sun.misc.Cleaner来执行内存回收的。</p>
<h3 id="Cleaner源码分析"><a href="#Cleaner源码分析" class="headerlink" title="Cleaner源码分析"></a>Cleaner源码分析</h3><p>（源码分析基于jdk1.8.0）</p>
<p><strong>首先，</strong> Cleaner是一个虚引用，继承自PhantomReference，如下图：</p>
<img src="\assert\puml\20ba84932c9718618aca79042c5910ce5edf5baae66de2de5c28fba6fb052d23.svg"/>

<p><strong>第二：</strong> Cleaner的父类Reference的静态代码块中会启动一个线程ReferenceHandler，这个线程永远不会退出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//while循环永远不会退出</span></span><br><span class="line">                tryHandlePending(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">             tgn != <span class="literal">null</span>;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceHandler</span>(tg, <span class="string">&quot;Reference Handler&quot;</span>);</span><br><span class="line">        handler.setPriority(Thread.MAX_PRIORITY); <span class="comment">//高优先级</span></span><br><span class="line">        handler.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        handler.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">        SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> <span class="title class_">JavaLangRefAccess</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryHandlePendingReference</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> tryHandlePending(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三：</strong> pending是一个Reference链表，由GC来赋值。pending链表中的Reference都在等待被加入到ReferenceQueue中，如果Reference没有关联到ReferenceQueue，就不会被添加到pending列表。而ReferenceHandler是一个永远不会退出的线程，一直从链表中获取元素，当元素是Cleaner类型时就会执行Cleaner.clean()方法，否则就会加入到ReferenceQueue队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* List of References waiting to be enqueued.  The collector adds</span></span><br><span class="line"><span class="comment"> * References to this list, while the Reference-handler thread removes</span></span><br><span class="line"><span class="comment"> * them.  This list is protected by the above lock object. The</span></span><br><span class="line"><span class="comment"> * list uses the discovered field to link its elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryHandlePending</span><span class="params">(<span class="type">boolean</span> waitForNotify)</span> &#123;</span><br><span class="line">    Reference&lt;Object&gt; r;</span><br><span class="line">    Cleaner c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">                r = pending;</span><br><span class="line">                <span class="comment">// &#x27;instanceof&#x27; might throw OutOfMemoryError sometimes</span></span><br><span class="line">                <span class="comment">// so do this before un-linking &#x27;r&#x27; from the &#x27;pending&#x27; chain...</span></span><br><span class="line">                c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// unlink &#x27;r&#x27; from &#x27;pending&#x27; chain</span></span><br><span class="line">                pending = r.discovered; <span class="comment">//pending链表指向下一个Reference</span></span><br><span class="line">                r.discovered = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">                <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">                <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">                    lock.wait(); <span class="comment">//pending为空，线程阻塞等待。</span></span><br><span class="line">                    <span class="comment">//当GC每次执行收集流程之前都会获取lock，然后将被回收的Reference放到pending链表中，然后唤醒阻塞线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// retry if waited</span></span><br><span class="line">                <span class="keyword">return</span> waitForNotify;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span><br><span class="line">        <span class="comment">// and GC reclaims some space.</span></span><br><span class="line">        <span class="comment">// Also prevent CPU intensive spinning in case &#x27;r instanceof Cleaner&#x27; above</span></span><br><span class="line">        <span class="comment">// persistently throws OOME for some time...</span></span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">        <span class="comment">// retry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fast path for cleaners</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">        c.clean();  <span class="comment">//执行Cleaner的clean()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceQueue&lt;? <span class="built_in">super</span> Object&gt; q = r.queue;</span><br><span class="line">    <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);  <span class="comment">//将其他Reference加入到ReferenceQueue中。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel?hl=zh-cn">硬件加速</a><br><a href="https://muyangmin.github.io/glide-docs-cn/doc/hardwarebitmaps.html">硬件位图</a><br><a href="https://www.dazhuanlan.com/zipaiwang/topics/992879">Android硬件位图填坑之获取硬件画布</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Java虚拟机创建过程</title>
    <url>/posts/31280.html</url>
    <content><![CDATA[<p>本文基于Android8.0源码</p>
<p>Android8.0使用的java虚拟机为ART，在大名鼎鼎的zygote进程中启动java虚拟机。<br>首先看一下zygote的main函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app_main.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//AppRuntime继承自AndroidRuntime, 构造函数中没有什么有用信息，可以不关注</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">//调用到AndroidRuntime.start函数启动zygote进程的虚拟机</span></span><br><span class="line">        <span class="comment">//传入的第一个参数是java类ZygoteInit</span></span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">app_usage</span>();</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime.start会调用父类的AndroidRuntime::start，看一下实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AndroidRuntime.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> Vector&lt;String8&gt;&amp; options, <span class="type">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);  <span class="comment">// 1. 加载虚拟机动态库，并加载库函数符号</span></span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123; <span class="comment">// 2. 启动虚拟机</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">onVmCreated</span>(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用com.android.internal.os.ZygoteInit的main函数，从此便进入了Java的世界</span></span><br><span class="line">        jmethodID startMeth = env-&gt;<span class="built_in">GetStaticMethodID</span>(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;<span class="built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>加载虚拟机动态库，并加载库函数符号</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JniInvocation.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JniInvocation::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* library)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  library = <span class="built_in">GetLibrary</span>(library, buffer); <span class="comment">//返回“libart.so” art虚拟机库</span></span><br><span class="line">  ......</span><br><span class="line">  handle_ = <span class="built_in">dlopen</span>(library, kDlopenFlags);  <span class="comment">//动态加载虚拟机so库</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//下面的三个if语句都是通过dlsym来获取虚拟机so库中的函数符号</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindSymbol</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;JNI_GetDefaultJavaVMInitArgs_),</span><br><span class="line">                  <span class="string">&quot;JNI_GetDefaultJavaVMInitArgs&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//无比重要的函数，获取虚拟机构造函数的函数符号，创建虚拟机全靠JNI_CreateJavaVM</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindSymbol</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;JNI_CreateJavaVM_),</span><br><span class="line">                  <span class="string">&quot;JNI_CreateJavaVM&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindSymbol</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;JNI_GetCreatedJavaVMs_),</span><br><span class="line">                  <span class="string">&quot;JNI_GetCreatedJavaVMs&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jint <span class="title">JniInvocation::JNI_CreateJavaVM</span><span class="params">(JavaVM** p_vm, JNIEnv** p_env, <span class="type">void</span>* vm_args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JNI_CreateJavaVM_</span>(p_vm, p_env, vm_args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数就是最终创建虚拟机的函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">jint <span class="title">JNI_CreateJavaVM</span><span class="params">(JavaVM** p_vm, JNIEnv** p_env, <span class="type">void</span>* vm_args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> JniInvocation::<span class="built_in">GetJniInvocation</span>().<span class="built_in">JNI_CreateJavaVM</span>(p_vm, p_env, vm_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动虚拟机</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Dalvik Virtual Machine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="type">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...... <span class="comment">//组装虚拟机启动参数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Initialize the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread.</span></span><br><span class="line"><span class="comment">     * If this call succeeds, the VM is ready, and we can start issuing</span></span><br><span class="line"><span class="comment">     * JNI calls.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">JNI_CreateJavaVM</span>(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;JNI_CreateJavaVM failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Fresco源码详解</title>
    <url>/posts/863074da.html</url>
    <content><![CDATA[<!-- 
`com.facebook.imagepipeline.image.EncodedImage#getInputStream`是什么？
`com.facebook.imagepipeline.platform.DefaultDecoder#decodeFromStream`会首先通过`mDecodeBuffers.acquire()`获取byteBuffer，如果获取不到就通过`ByteBuffer.allocate`来申请内存。 
-->

<p>通过Fresco加载图片，最简单的方式是通过<code>SimpleDraweeView</code>来展示图片，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.facebook.drawee.view.SimpleDraweeView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/my_image_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;130dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;130dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">fresco:placeholderImage</span>=<span class="string">&quot;@drawable/my_drawable&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码在Fragment#onViewCreated中调用</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;https://frescolib.org/static/sample-images/animal_a.png&quot;</span>);</span><br><span class="line"><span class="type">SimpleDraweeView</span> <span class="variable">draweeView</span> <span class="operator">=</span> (SimpleDraweeView) findViewById(R.id.my_image_view);</span><br><span class="line">draweeView.setImageURI(uri);</span><br></pre></td></tr></table></figure>

<p>先看一下<code>SimpleDraweeView</code>相关的类图结构：</p>
<img src="\assert\puml\3d0cbe1a2000392ede96ee6008e2a66790364eb70d9f5dce9814d5c13fe18973.svg"/>

<h2 id="图片加载过程"><a href="#图片加载过程" class="headerlink" title="图片加载过程"></a>图片加载过程</h2><p>这个时序图是以文章开头的<code>SimpleDraweeView</code>的示例代码为例进行绘制。</p>
<img src="\assert\puml\3b8b646146b7ed7f97b4ac8dc1e452360c0e92028b6fdb6bde09486a657f4440.svg"/>

<p>上图中DateSource是一个<code>CloseableProducerToDataSourceAdapter</code>实例，如下图类图所示：</p>
<img src="\assert\puml\d7b0c9c5fecd7db5bec3bdabba68d82216eacc82c7446c5039062b9b5fd37445.svg"/>

<p>Producer就是图片的生产者队列，会执行网络请求、缓存读写、图片解码等等图片处理任务。下文会详细介绍生产者队列。</p>
<h3 id="PipelineDraweeController的构造过程"><a href="#PipelineDraweeController的构造过程" class="headerlink" title="PipelineDraweeController的构造过程"></a>PipelineDraweeController的构造过程</h3><img src="\assert\puml\f93412cd3f67bd7662bc7b7adfac78e65498892dcf701fcf9bfa27c17dccf29f.svg"/>

<p>上图中的Supplier是<code>Supplier&lt;DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt;&gt;</code>是一个内部类,这个类就是DataSource提供者。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractDraweeControllerBuilder.java</span></span><br><span class="line">  <span class="keyword">protected</span> Supplier&lt;DataSource&lt;IMAGE&gt;&gt; <span class="title function_">getDataSourceSupplierForRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> REQUEST imageRequest,</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> <span class="type">boolean</span> bitmapCacheOnly)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">callerContext</span> <span class="operator">=</span> getCallerContext();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;DataSource&lt;IMAGE&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> DataSource&lt;IMAGE&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDataSourceForRequest(imageRequest, callerContext, bitmapCacheOnly);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.toStringHelper(<span class="built_in">this</span>)</span><br><span class="line">            .add(<span class="string">&quot;request&quot;</span>, imageRequest.toString())</span><br><span class="line">            .toString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//PipelineDraweeControllerBuilder.java</span></span><br><span class="line">  <span class="keyword">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; <span class="title function_">getDataSourceForRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">      DraweeController controller,</span></span><br><span class="line"><span class="params">      String controllerId,</span></span><br><span class="line"><span class="params">      ImageRequest imageRequest,</span></span><br><span class="line"><span class="params">      Object callerContext,</span></span><br><span class="line"><span class="params">      AbstractDraweeControllerBuilder.CacheLevel cacheLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mImagePipeline.fetchDecodedImage(</span><br><span class="line">        imageRequest,</span><br><span class="line">        callerContext,</span><br><span class="line">        convertCacheLevelToRequestLevel(cacheLevel),</span><br><span class="line">        getRequestListener(controller),</span><br><span class="line">        controllerId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面是与PipelineDraweeController构造相关的类图：</p>
<img src="\assert\puml\6bd665683c2a4e8fb335660e36fd5bf39afe63e2fd5d7514c9224009acc5a3a0.svg"/>

<h2 id="三级缓存机制"><a href="#三级缓存机制" class="headerlink" title="三级缓存机制"></a>三级缓存机制</h2><p>Fresco采用了三级缓存机制，两级内存，一级磁盘。</p>
<img src="\assert\puml\6714089f47f5b2c44c9ddf1fe71664d16d7f107fa077bd383a75959df3dc8edc.svg"/>

<h3 id="内存缓存池"><a href="#内存缓存池" class="headerlink" title="内存缓存池"></a>内存缓存池</h3><p>Fresco的第一级和第二级内存缓存都是采用<code>LruCountingMemoryCache</code>来进行内存管理。</p>
<img src="\assert\puml\d8bb99e1e27832045dd1c4bc3c7366df3f06e1137a4653f953a747f27e0f7d01.svg"/>

<p>LruCountingMemoryCache包含了两个CountingLruMap：<code>mCachedEntries</code>保存所有缓存数据，即缓存池；<code>mExclusiveEntries</code>是回收队列，用于保存不再被使用的数据，这些数据是可以被安全回收的。<code>CountingLruMap</code>中的数据通过<code>LinkedHashMap</code>来保存，同时CountingLruMap中有一个mSizeInBytes变量，表示缓存数据的总大小，在每次添加和删除数据时都会更新mSizeInBytes。</p>
<p>缓存池中保存的是<code>Entry&lt;K, V&gt;</code>数据类型，然而添加和获取缓存数据都会通过<code>newClientReference</code>方法来创建一个<code>CloseableReference&lt;V&gt;</code>返回的是一个<code>CloseableReference&lt;V&gt;</code>类型的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LruCountingMemoryCache.java</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> CloseableReference&lt;V&gt; <span class="title function_">newClientReference</span><span class="params">(<span class="keyword">final</span> Entry&lt;K, V&gt; entry)</span> &#123;</span><br><span class="line">    increaseClientCount(entry);</span><br><span class="line">    <span class="keyword">return</span> CloseableReference.of(</span><br><span class="line">        entry.valueRef.get(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ResourceReleaser</span>&lt;V&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(V unused)</span> &#123; <span class="comment">//当CloseableReference#close被调用时就会执行release方法</span></span><br><span class="line">            releaseClientReference(entry);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Called when the client closes its reference. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">releaseClientReference</span><span class="params">(<span class="keyword">final</span> Entry&lt;K, V&gt; entry)</span> &#123;</span><br><span class="line">    Preconditions.checkNotNull(entry);</span><br><span class="line">    <span class="type">boolean</span> isExclusiveAdded;</span><br><span class="line">    CloseableReference&lt;V&gt; oldRefToClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      decreaseClientCount(entry);</span><br><span class="line">      isExclusiveAdded = maybeAddToExclusives(entry);</span><br><span class="line">      oldRefToClose = referenceToClose(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    CloseableReference.closeSafely(oldRefToClose);</span><br><span class="line">    maybeNotifyExclusiveEntryInsertion(isExclusiveAdded ? entry : <span class="literal">null</span>);</span><br><span class="line">    maybeUpdateCacheParams();</span><br><span class="line">    maybeEvictEntries();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Adds the entry to the exclusively owned queue if it is viable for eviction. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">maybeAddToExclusives</span><span class="params">(Entry&lt;K, V&gt; entry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!entry.isOrphan &amp;&amp; entry.clientCount == <span class="number">0</span>) &#123;</span><br><span class="line">      mExclusiveEntries.put(entry.key, entry); <span class="comment">//添加到回收队列中</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当数据消费者不再使用这条数据时，CloseableReference#close()就会被调用，进而调用到上面代码中的release回调方法，当这条数据的使用者数量为零时，就会把这条数据添加到<code>mExclusiveEntries</code>回收队列中，<code>mCachedEntries</code>依然会保留这条数据。当从缓存池get数据时，如果这条数据在回收队列中，将会从回收队列中移除掉，因为这条数据有了使用者，就不能被回收了。</p>
<p>再来看下缓存池的配置参数：</p>
<ul>
<li>maxCacheSize 缓存的最大大小，以字节为单位；</li>
<li>maxCacheEntries 缓存中能够保存的最大数量；</li>
<li>maxEvictionQueueSize 回收队列用于存储准备回收的数据，这个字段表示回收队列的最大字节数；</li>
<li>maxEvictionQueueEntries 回收队列可以保存的最大数量；</li>
<li>maxCacheEntrySize 单个缓存数据的最大内存；</li>
<li>paramsCheckIntervalMs 检查配置参数更新的间隔时间(以毫秒为单位)。当添加缓存、获取缓存等操作时，都会检查距离上次更新配置参数是否超过这个值，如果超过了，就会重新后去这些配置参数。</li>
</ul>
<p>上面这些参数用于确定缓存池的最大容量，当超过容量限制时就会触发回收动作，回收时只会删除已经在回收队列中的数据，不在回收队列中的数据说明还再被使用，是不能回收的。在添加、获取缓存数据时都会调用<code>maybeEvictEntries</code>来判断是否要对缓存池进行清理回收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maybeEvictEntries</span><span class="params">()</span> &#123;</span><br><span class="line">  ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//计算回收队列要保留的数据个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span></span><br><span class="line">        Math.min(</span><br><span class="line">            mMemoryCacheParams.maxEvictionQueueEntries,</span><br><span class="line">            mMemoryCacheParams.maxCacheEntries - getInUseCount());</span><br><span class="line">    <span class="comment">//计算回收队列要保留数据的总大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span></span><br><span class="line">        Math.min(</span><br><span class="line">            mMemoryCacheParams.maxEvictionQueueSize,</span><br><span class="line">            mMemoryCacheParams.maxCacheSize - getInUseSizeInBytes());</span><br><span class="line">    oldEntries = trimExclusivelyOwnedEntries(maxCount, maxSize);</span><br><span class="line">    makeOrphans(oldEntries);</span><br><span class="line">  &#125;</span><br><span class="line">  maybeClose(oldEntries);</span><br><span class="line">  maybeNotifyExclusiveEntryRemoval(oldEntries);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取正在被使用的数据的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getInUseCount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> mCachedEntries.getCount() - mExclusiveEntries.getCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行回收工作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> ArrayList&lt;Entry&lt;K, V&gt;&gt; <span class="title function_">trimExclusivelyOwnedEntries</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">  count = Math.max(count, <span class="number">0</span>);</span><br><span class="line">  size = Math.max(size, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// fast path without array allocation if no eviction is necessary</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.mExclusiveEntries.getCount() &lt;= count &amp;&amp; mExclusiveEntries.getSizeInBytes() &lt;= size) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//循环从回收队列删除数据，直到同时满足小于等于size和count</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.mExclusiveEntries.getCount() &gt; count || mExclusiveEntries.getSizeInBytes() &gt; size) &#123;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> mExclusiveEntries.getFirstKey(); <span class="comment">//获取回收队列中最早添加的数据</span></span><br><span class="line">    ......</span><br><span class="line">    mExclusiveEntries.remove(key); <span class="comment">//从回收队列中删除</span></span><br><span class="line">    oldEntries.add(mCachedEntries.remove(key)); <span class="comment">//从缓存池删除</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> oldEntries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存块缓存池-MemoryChunkPool"><a href="#内存块缓存池-MemoryChunkPool" class="headerlink" title="内存块缓存池-MemoryChunkPool"></a>内存块缓存池-MemoryChunkPool</h3><img src="\assert\puml\ab72a0c1ba7c452585987573b376d1c0e47b9ab66f03d89824d2dc4a8ffabe75.svg"/>

<p>Fresco默认使用<code>NativeMemoryChunkPool</code>，而如果要使用<code>AshmemMemoryChunkPool</code>则必须配置开发打开，并且8.1及以上的android版本才能使用（<code>ImagePipelineConfig#getMemoryChunkType</code>）。</p>
<ul>
<li>NativeMemoryChunk使用nativce内存，通过C函数malloc来申请内存；</li>
<li>AshmemMemoryChunk使用匿名共享内存，通过<code>android.os.SharedMemory#create</code>来申请内存；</li>
<li>BufferMemoryChunk使用Java堆上的内存，通过<code>java.nio.ByteBuffer#allocateDirect</code>来申请内存；</li>
</ul>
<p>MemoryChunkPool中维护了一个int数组（mBucketSizes），是内存块大小列表，数组的值来自<code>PoolParams#bucketSizes</code>的keys，此处不会使用其value值。<code>PoolParams#bucketSizes</code>是个SparseIntArray类型，相当于map类型，key、value都是int。key表示内存块大小、value表示该大小的内存块的个数。默认值如下<small>（<em>默认值在<code>DefaultNativeMemoryChunkPoolParams#get</code>赋值</em>）</small>：</p>
<img src="\assert\puml\2758552ba52d1c2964a8202249256f35c0e5d7151c020c179200393a34c1d2cf.svg"/>

<p>当需要获取内存块时，会调用<code>MemoryChunkPool#get(int size)</code>来获取一个MemoryChunk。比如要获取一个60KB大小的内存块，就会在mBucketSizes数组中找大于等于60KB的最小值，所以，最终内存块大小是64KB。申请内存块时，如果内存池中已经有对应大小的内存块就返回，否则会创建一个新的内存块，并申请内存。</p>
<p><code>Bucket&lt;MemoryChunk&gt;</code>中维护的都是相同大小的内存块，使用一个Queue维护空闲的内存块，当内存块被取走后，就在Queue中删除了。当内存块使用完后再放入Queue中。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>NetworkFetchProducer中，图片从网络下载后，原始图片数据就会写入到一个MemoryChunk中。</li>
</ul>
<h3 id="字节内存缓存池-ByteArrayPool"><a href="#字节内存缓存池-ByteArrayPool" class="headerlink" title="字节内存缓存池 ByteArrayPool"></a>字节内存缓存池 ByteArrayPool</h3><img src="\assert\puml\2dbaf0176ffa5bfdfb30868812f647e0196d431323436786701a33e9df802a4a.svg"/>

<p>字节缓存池与内存块缓存池的机制是一样的，区别是内存块缓存池使用了1KB、2KB、4KB等一系列大小的内存块，而字节内存缓存池只有16KB大小的一种缓存块。一般作为一个临时内存来使用，使用完成后立马放回缓存池，</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>网络请求数据从输入流中读数据到一个临时的buffer中，这个buffer就是从字节内存缓存池中拿到的；</li>
<li>图片缓存到磁盘中时，内存的输入流中先读取数据到一个buffer中，然后从buffer写入到磁盘的输出流，其中buffer也是从字节内存缓存池中拿到；</li>
</ul>
<h2 id="图片解码器"><a href="#图片解码器" class="headerlink" title="图片解码器"></a>图片解码器</h2><img src="\assert\puml\de9d201a9fac60c376b58e62c7c91739f92f43493932aefff88fcaa1a51c664e.svg"/>

<h3 id="Bitmap内存占用"><a href="#Bitmap内存占用" class="headerlink" title="Bitmap内存占用"></a>Bitmap内存占用</h3><ul>
<li>Android 2.3.3 (API level 10)以及更早的Android版本中，Bitmap的像素数据保存在native内存中，像素数据内存的回收则在finalize()中进行回收，存在很大的不确定性，很容易导致OOM的发生；</li>
<li>从Android 3.0 (API level 11) 到Android 7.1 (API level 25)，像素数据存放在Java Heap中，跟Bitmap对象一起回收。但由于图片是内存消耗大户，所以也很容易导致OOM，以及频繁的GC导致内存抖动问题。</li>
<li>在Android 8.0 (API level 26)以及更高的版本中，像素数据保存在native heap中。通过一个辅助类<code>NativeAllocationRegistry</code>来实现native内存的回收。</li>
</ul>
<p>Android5.0及以上的版本，Fresco采用标准的Bitmap解码，通过BitmapFactoty.decodeXXX系列函数进行位图解码，pixel数据内存的分配完全由Android系统决定，可以参考<a href="/posts/68833f9e.html" title="Bitmap内存分配以及回收">Bitmap内存分配以及回收</a>，所以这里就不介绍了。</p>
<p>本节重点介绍在Android5.0以下的系统上，Fresco是如何把pixel数据放在了共享内存中的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//imagepipeline-native/src/main/java/com/facebook/imagepipeline/nativecode/DalvikPurgeableDecoder.java</span></span><br><span class="line">  <span class="keyword">public</span> CloseableReference&lt;Bitmap&gt; <span class="title function_">decodeJPEGFromEncodedImageWithColorSpace</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> EncodedImage encodedImage,</span></span><br><span class="line"><span class="params">      Bitmap.Config bitmapConfig,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Rect regionToDecode,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> length,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> ColorSpace colorSpace)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置解码配置信息，函数实现见下方代码</span></span><br><span class="line">    BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span></span><br><span class="line">        getBitmapFactoryOptions(encodedImage.getSampleSize(), bitmapConfig); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">      OreoUtils.setColorSpace(options, colorSpace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef();</span><br><span class="line">    Preconditions.checkNotNull(bytesRef);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//最终会调用BitmapFactory.decodeByteArray或BitmapFactory.decodeFileDescriptor来解码位图</span></span><br><span class="line">      <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> decodeJPEGByteArrayAsPurgeable(bytesRef, length, options);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//通过jni最终调用framework中的AndroidBitmap_lockPixels（c++函数），待会儿再介绍作用</span></span><br><span class="line">      <span class="keyword">return</span> pinBitmap(bitmap); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      CloseableReference.closeSafely(bytesRef);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> BitmapFactory.Options <span class="title function_">getBitmapFactoryOptions</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="type">int</span> sampleSize, Bitmap.Config bitmapConfig)</span> &#123;</span><br><span class="line">    BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">    options.inDither = <span class="literal">true</span>; <span class="comment">// known to improve picture quality at low cost</span></span><br><span class="line">    options.inPreferredConfig = bitmapConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode the image into a &#x27;purgeable&#x27; bitmap that lives on the ashmem heap</span></span><br><span class="line">    <span class="comment">//BitmapFactory.cpp中doDecode时会读取这个配置，从而使用共享内存</span></span><br><span class="line">    options.inPurgeable = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Enable copy of of bitmap to enable purgeable decoding by filedescriptor</span></span><br><span class="line">    options.inInputShareable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sample size should ONLY be different than 1 when downsampling is enabled in the pipeline</span></span><br><span class="line">    options.inSampleSize = sampleSize;</span><br><span class="line">    options.inMutable = <span class="literal">true</span>; <span class="comment">// no known perf difference; allows postprocessing to work</span></span><br><span class="line">    <span class="keyword">return</span> options;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>继续看以下android framework 中bitmap解码的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-4.4.4_r1\frameworks\base\core\jni\android\graphics\BitmapFactory.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">doDecode</span><span class="params">(JNIEnv* env, SkStreamRewindable* stream, jobject padding,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject options, <span class="type">bool</span> allowPurgeable, <span class="type">bool</span> forcePurgeable = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    ...... <span class="comment">//代码省略</span></span><br><span class="line">    <span class="type">bool</span> isPurgeable = forcePurgeable || (allowPurgeable &amp;&amp; <span class="built_in">optionsPurgeable</span>(env, options));</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> willScale = scale != <span class="number">1.0f</span>;</span><br><span class="line">    isPurgeable &amp;= !willScale;  <span class="comment">//如果配置了按比例缩放，则isPurgeable不生效</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果配置了isPurgeable，将会使用kDecodeBounds_Mode解码模式，即只解析长宽等信息，不会申请piexel内存</span></span><br><span class="line">    SkImageDecoder::Mode decodeMode = isPurgeable ? SkImageDecoder::kDecodeBounds_Mode : mode;</span><br><span class="line"></span><br><span class="line">    <span class="function">JavaPixelAllocator <span class="title">javaAllocator</span><span class="params">(env)</span></span>;</span><br><span class="line">    <span class="function">RecyclingPixelAllocator <span class="title">recyclingAllocator</span><span class="params">(outputBitmap-&gt;pixelRef(), existingBufferSize)</span></span>;</span><br><span class="line">    <span class="function">ScaleCheckingAllocator <span class="title">scaleCheckingAllocator</span><span class="params">(scale, existingBufferSize)</span></span>;</span><br><span class="line">    SkBitmap::Allocator* outputAllocator = (javaBitmap != <span class="literal">NULL</span>) ?</span><br><span class="line">            (SkBitmap::Allocator*)&amp;recyclingAllocator : (SkBitmap::Allocator*)&amp;javaAllocator;</span><br><span class="line">    <span class="keyword">if</span> (decodeMode != SkImageDecoder::kDecodeBounds_Mode) &#123;</span><br><span class="line">        <span class="comment">//isPurgeable为true时，不会走入这个if判断，所以decoder不会设置allocator</span></span><br><span class="line">        <span class="keyword">if</span> (!willScale) &#123;</span><br><span class="line">            <span class="comment">// If the java allocator is being used to allocate the pixel memory, the decoder</span></span><br><span class="line">            <span class="comment">// need not write zeroes, since the memory is initialized to 0.</span></span><br><span class="line">            decoder-&gt;<span class="built_in">setSkipWritingZeroes</span>(outputAllocator == &amp;javaAllocator);</span><br><span class="line">            decoder-&gt;<span class="built_in">setAllocator</span>(outputAllocator);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaBitmap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// check for eventual scaled bounds at allocation time, so we don&#x27;t decode the bitmap</span></span><br><span class="line">            <span class="comment">// only to find the scaled result too large to fit in the allocation</span></span><br><span class="line">            decoder-&gt;<span class="built_in">setAllocator</span>(&amp;scaleCheckingAllocator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    SkBitmap decodingBitmap;</span><br><span class="line">    <span class="comment">//使用SkImageDecoder::kDecodeBounds_Mode模式进行解码，所以decodingBitmap中没有pixel数据</span></span><br><span class="line">    <span class="keyword">if</span> (!decoder-&gt;<span class="built_in">decode</span>(stream, &amp;decodingBitmap, prefConfig, decodeMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;decoder-&gt;decode returned false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// if we&#x27;re in justBounds mode, return now (skip the java bitmap)</span></span><br><span class="line">    <span class="comment">//此处并没有使用decodeMode来判断，所以不会返回，还会继续执行后面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (mode == SkImageDecoder::kDecodeBounds_Mode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    SkPixelRef* pr;</span><br><span class="line">    <span class="keyword">if</span> (isPurgeable) &#123;</span><br><span class="line">        <span class="comment">//installPixelRef函数实现见下文</span></span><br><span class="line">        pr = <span class="built_in">installPixelRef</span>(outputBitmap, stream, sampleSize, doDither);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if we get here, we&#x27;re in kDecodePixels_Mode and will therefore</span></span><br><span class="line">        <span class="comment">// already have a pixelref installed.</span></span><br><span class="line">        pr = outputBitmap-&gt;<span class="built_in">pixelRef</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nullObjectReturn</span>(<span class="string">&quot;Got null SkPixelRef&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// now create the java bitmap</span></span><br><span class="line">    <span class="keyword">return</span> GraphicsJNI::<span class="built_in">createBitmap</span>(env, outputBitmap, javaAllocator.<span class="built_in">getStorageObj</span>(),</span><br><span class="line">            bitmapCreateFlags, ninePatchChunk, layoutBounds, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> SkPixelRef* <span class="title">installPixelRef</span><span class="params">(SkBitmap* bitmap, SkStreamRewindable* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> sampleSize, <span class="type">bool</span> ditherImage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SkImageInfo bitmapInfo;</span><br><span class="line">    <span class="keyword">if</span> (!bitmap-&gt;<span class="built_in">asImageInfo</span>(&amp;bitmapInfo)) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;bitmap has unknown configuration so no memory has been allocated&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SkImageRef* pr;</span><br><span class="line">    <span class="comment">// only use ashmem for large images, since mmaps come at a price</span></span><br><span class="line">    <span class="comment">//当Bitmap内存超过32K时，才会使用共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (bitmap-&gt;<span class="built_in">getSize</span>() &gt;= <span class="number">32</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        pr = <span class="keyword">new</span> <span class="built_in">SkImageRef_ashmem</span>(bitmapInfo, stream, sampleSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//会走到SkBitmap::allocPixels默认申请内存native内存的分支，并通过一个全局缓存池进行管理</span></span><br><span class="line">        pr = <span class="keyword">new</span> <span class="built_in">SkImageRef_GlobalPool</span>(bitmapInfo, stream, sampleSize);</span><br><span class="line">    &#125;</span><br><span class="line">    pr-&gt;<span class="built_in">setDitherImage</span>(ditherImage);</span><br><span class="line">    bitmap-&gt;<span class="built_in">setPixelRef</span>(pr)-&gt;<span class="built_in">unref</span>();</span><br><span class="line">    pr-&gt;<span class="built_in">isOpaque</span>(bitmap);</span><br><span class="line">    <span class="keyword">return</span> pr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，当isPurgeable==true时，并没有解码pixel数据，而且内存也没有申请，那么什么时候进行解码呢？还记得Fresco调用BitmapFactory解码后有个pinBitmap的函数调用吧，这个函数通过jni调用AndroidBitmap_lockPixels函数，进而调用到<code>SkImageRef::onLockPixels</code>，从而触发pixel解码。下面代码介绍了触发解码的过程，以及共享内存的分配：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-4.4.4_r1\external\skia\src\images\SkImageRef.cpp</span></span><br><span class="line"><span class="comment">//Fresco的pinBitmap最终就会调用这个函数，进而触发pixel解码，pixel数据存放在共享内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">SkImageRef::onLockPixels</span><span class="params">(SkColorTable** ct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == fBitmap.<span class="built_in">getPixels</span>()) &#123;</span><br><span class="line">        (<span class="type">void</span>)<span class="keyword">this</span>-&gt;<span class="built_in">prepareBitmap</span>(SkImageDecoder::kDecodePixels_Mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct) &#123;</span><br><span class="line">        *ct = fBitmap.<span class="built_in">getColorTable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fBitmap.<span class="built_in">getPixels</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SkImageRef_ashmem就是SkImageRef的子类，prepareBitmap会调用onDecode</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkImageRef::prepareBitmap</span><span class="params">(SkImageDecoder::Mode mode)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    SkImageDecoder* codec;</span><br><span class="line">    <span class="keyword">if</span> (fFactory) &#123; <span class="comment">//默认是null，不走这个分支</span></span><br><span class="line">        codec = fFactory-&gt;<span class="built_in">newDecoder</span>(fStream);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        codec = SkImageDecoder::<span class="built_in">Factory</span>(fStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec) &#123;</span><br><span class="line">        <span class="function">SkAutoTDelete&lt;SkImageDecoder&gt; <span class="title">ad</span><span class="params">(codec)</span></span>;</span><br><span class="line"></span><br><span class="line">        codec-&gt;<span class="built_in">setSampleSize</span>(fSampleSize);</span><br><span class="line">        codec-&gt;<span class="built_in">setDitherImage</span>(fDoDither);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处就是SkImageRef_ashmem::onDecode，见下面函数定义</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">onDecode</span>(codec, fStream, &amp;fBitmap, fBitmap.<span class="built_in">config</span>(), mode)) &#123;</span><br><span class="line">            <span class="built_in">SkDEBUGCODE</span>(SkImageInfo info;)</span><br><span class="line">            <span class="built_in">SkASSERT</span>(!fBitmap.<span class="built_in">asImageInfo</span>(&amp;info) || <span class="keyword">this</span>-&gt;<span class="built_in">info</span>().fColorType == info.fColorType);</span><br><span class="line">            <span class="built_in">SkASSERT</span>(<span class="keyword">this</span>-&gt;<span class="built_in">info</span>().fWidth == fBitmap.<span class="built_in">width</span>());</span><br><span class="line">            <span class="built_in">SkASSERT</span>(<span class="keyword">this</span>-&gt;<span class="built_in">info</span>().fHeight == fBitmap.<span class="built_in">height</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//android-4.4.4_r1\external\skia\src\images\SkImageRef_ashmem.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkImageRef_ashmem::onDecode</span><span class="params">(SkImageDecoder* codec, SkStreamRewindable* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 SkBitmap* bitmap, SkBitmap::Config config,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 SkImageDecoder::Mode mode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SkImageDecoder::kDecodeBounds_Mode == mode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;INHERITED::<span class="built_in">onDecode</span>(codec, stream, bitmap, config, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ashmem memory is guaranteed to be initialized to 0.</span></span><br><span class="line">    codec-&gt;<span class="built_in">setSkipWritingZeroes</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这就是我们的主角，共享内存分配器</span></span><br><span class="line">    <span class="function">AshmemAllocator <span class="title">alloc</span><span class="params">(&amp;fRec, <span class="keyword">this</span>-&gt;getURI())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向解码器中注册共享内存分配器。如果不注册将会采用默认的内存分配器</span></span><br><span class="line">    codec-&gt;<span class="built_in">setAllocator</span>(&amp;alloc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用父类的onDecode，父类会调用codec-&gt;decode进行位图解码，见下面函数定义</span></span><br><span class="line">    <span class="type">bool</span> success = <span class="keyword">this</span>-&gt;INHERITED::<span class="built_in">onDecode</span>(codec, stream, bitmap, config,</span><br><span class="line">                                             mode);</span><br><span class="line">    <span class="comment">// remove the allocator, since its on the stack</span></span><br><span class="line">    codec-&gt;<span class="built_in">setAllocator</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="comment">// remember the colortable (if any)</span></span><br><span class="line">        <span class="built_in">SkRefCnt_SafeAssign</span>(fCT, bitmap-&gt;<span class="built_in">getColorTable</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fRec.fPinned) &#123;</span><br><span class="line">            <span class="built_in">ashmem_unpin_region</span>(fRec.fFD, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            fRec.fPinned = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">closeFD</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkImageRef::onDecode</span><span class="params">(SkImageDecoder* codec, SkStreamRewindable* stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                          SkBitmap* bitmap, SkBitmap::Config config,</span></span></span><br><span class="line"><span class="params"><span class="function">                          SkImageDecoder::Mode mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> codec-&gt;<span class="built_in">decode</span>(stream, bitmap, config, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//android-4.4.4_r1\external\skia\src\images\SkImageDecoder_libjpeg.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkJPEGImageDecoder::onDecode</span><span class="params">(SkStream* stream, SkBitmap* bm, Mode mode)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (SkImageDecoder::kDecodeBounds_Mode == mode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">allocPixelRef</span>(bm, <span class="literal">NULL</span>)) &#123; <span class="comment">//调用父类函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">return_false</span>(cinfo, *bm, <span class="string">&quot;allocPixelRef&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//android-4.4.4_r1\external\skia\src\core\SkBitmap.cpp</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkImageDecoder::allocPixelRef</span><span class="params">(SkBitmap* bitmap,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   SkColorTable* ctable)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用bitmap分配pixel内存，fAllocator就是前面我们设置的共享内存分配器</span></span><br><span class="line">    <span class="keyword">return</span> bitmap-&gt;<span class="built_in">allocPixels</span>(fAllocator, ctable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SkBitmap::allocPixels</span><span class="params">(Allocator* allocator, SkColorTable* ctable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是默认内存分配器，因为我们传入了allocator参数，所以不会使用默认内存分配器</span></span><br><span class="line">    <span class="comment">//上面代码中介绍的SkImageRef_GlobalPool就会使用这个默认的内存分配器</span></span><br><span class="line">    HeapAllocator stdalloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == allocator) &#123;</span><br><span class="line">        allocator = &amp;stdalloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用AshmemAllocator::allocPixelRef来分配内存</span></span><br><span class="line">    <span class="keyword">return</span> allocator-&gt;<span class="built_in">allocPixelRef</span>(<span class="keyword">this</span>, ctable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AshmemAllocator</span> : <span class="keyword">public</span> SkBitmap::Allocator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AshmemAllocator</span>(SkAshmemRec* rec, <span class="type">const</span> <span class="type">char</span> name[])</span><br><span class="line">        : <span class="built_in">fRec</span>(rec), <span class="built_in">fName</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">allocPixelRef</span><span class="params">(SkBitmap* bm, SkColorTable* ct)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> size = <span class="built_in">roundToPageSize</span>(bm-&gt;<span class="built_in">getSize</span>());</span><br><span class="line">        <span class="type">int</span> fd = fRec-&gt;fFD;</span><br><span class="line">        <span class="type">void</span>* addr = fRec-&gt;fAddr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SkASSERT</span>(!fRec-&gt;fPinned);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line">            <span class="built_in">SkASSERT</span>(<span class="literal">NULL</span> == addr);</span><br><span class="line">            <span class="built_in">SkASSERT</span>(<span class="number">0</span> == fRec-&gt;fSize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打开/dev/ashmem虚拟设备，然后ioctl配置name和size</span></span><br><span class="line">            fd = <span class="built_in">ashmem_create_region</span>(fName, size);</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用mmap分配内存</span></span><br><span class="line">            addr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            fRec-&gt;fFD = fd;</span><br><span class="line">            fRec-&gt;fAddr = addr;</span><br><span class="line">            fRec-&gt;fSize = size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">SkASSERT</span>(addr);</span><br><span class="line">            <span class="built_in">SkASSERT</span>(size == fRec-&gt;fSize);</span><br><span class="line">            (<span class="type">void</span>)<span class="built_in">ashmem_pin_region</span>(fd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bm-&gt;<span class="built_in">setPixels</span>(addr, ct);</span><br><span class="line">        fRec-&gt;fPinned = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// we just point to our caller&#x27;s memory, these are not copies</span></span><br><span class="line">    SkAshmemRec* fRec;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*  fName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Bitmap复用"><a href="#Bitmap复用" class="headerlink" title="Bitmap复用"></a>Bitmap复用</h3><p>通过<code>android.graphics.BitmapFactory#decodeStream(...)</code>接口进行图片解码时可以通过设置<code>BitmapFactory.Options#inBitmap</code>来复用旧的Bitmap实例，这样可以避免频繁申请内存。但是有如下限制条件：</p>
<ol>
<li>被复用的Bitmap的isMutable属性必须为true；</li>
<li>Android4.4及以上版本，只要新图片需要的pixels内存小于等于inBitmap的即可；</li>
<li>Android4.4以下版本有额外的限制，图片必须是jpeg或png格式，而且pixels内存大小必须相等，且inSampleSize必须是1；而且新图片的inPreferredConfig属性将会被inBitmap覆盖。</li>
</ol>
<p>解码时Bitmap的复用代码在<code>DefaultDecoder#decodeFromStream</code>中。被复用的Bitmap保存在BitmapPool中。当一个Bitmap不再被使用后（引用计数为0）就会被放到BitmapPool中：</p>
<img src="\assert\puml\46b2431a01edd8a25321682d99beb2af2e6dd2a13ba9a3368853e4f69aa314ff.svg"/>

<p>BitmapPool默认情况下使用BucketsBitmapPool和DummyBitmapPool，Android5.0及以上使用BucketsBitmapPool。</p>
<p>Bitmap是如何被放到BitmapPool中的呢？<code>DefaultDecoder.decodeFromStream</code>生成Bitmap后并不是直接返回一个Bitmap，而是一个CloseableReference，CloseableReference就会把Bitmap与BitmapPool进行关联，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultDecoder.java</span></span><br><span class="line">  <span class="keyword">private</span> CloseableReference&lt;Bitmap&gt; <span class="title function_">decodeFromStream</span><span class="params">(</span></span><br><span class="line"><span class="params">      InputStream inputStream,</span></span><br><span class="line"><span class="params">      BitmapFactory.Options options,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Rect regionToDecode,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> ColorSpace colorSpace)</span> &#123;</span><br><span class="line">    ...... <span class="comment">//代码省略</span></span><br><span class="line">    <span class="keyword">return</span> CloseableReference.of(decodedBitmap, mBitmapPool);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>每次<code>CloseableReference#close</code>都会导致Bitmap的引用计数减一，当计数为零后，就会调用到<code>BitmapPool#release</code>，把Bitmap放到BitmapPool中。release的含义就是把不再使用的Bitmap放到缓存池中备用。</p>
<img src="\assert\puml\7dbd382b937ad7c592c2008ebd8c8c57a2699c0135a43bccfdd9aec5f67bdbbc.svg"/>

<p><strong><em>什么时候引用计数加一呢？</em></strong> 调用<code>CloseableReference</code>子类clone方法克隆一个新的CloseableReference时，就等价于增加了一个使用者，应用计数就会加一。 新和旧的CloseableReference持有同一个SharedReference实例。</p>
<p><strong><em>BitmapPool</em></strong> 不会无限扩张，最大支持多少个Bitmap？是否有清理策略？</p>
<img src="\assert\puml\ea7cb872dd9a8d77b49dec67f21412017210a081038a390a049b8f0e54255ac6.svg"/>

<p><code>com.facebook.imagepipeline.memory.DefaultNativeMemoryChunkPoolParams#get</code></p>
<h3 id="解码的临时缓存"><a href="#解码的临时缓存" class="headerlink" title="解码的临时缓存"></a>解码的临时缓存</h3><p>DefaultDecoder在解码图片生成BitMap时可以设置临时缓存，防止频繁GC，通过<code>android.graphics.BitmapFactory.Options#inTempStorage</code>来设置图片解码临时缓存，api文档中临时缓存大小建议为16K左右。临时缓存使用Pools.Pool&lt;ByteBuffer&gt;，是<code>SynchronizedPool</code>，缓存的个数默认是java虚拟机可使用的处理器个数<small>（可等同于cpu的核心数，但不是完全对等）</small>。这个是解码器独用的内存池，在Java堆上申请内存。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlatformDecoderFactory.kt</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">createPool</span><span class="params">(poolFactory: <span class="type">PoolFactory</span>, useDecodeBufferHelper: <span class="type">Boolean</span>)</span></span>: Pools.Pool&lt;ByteBuffer&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (useDecodeBufferHelper) &#123;</span><br><span class="line">      <span class="keyword">return</span> DecodeBufferHelper.INSTANCE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> maxNumThreads = poolFactory.flexByteArrayPoolMaxNumThreads</span><br><span class="line">    <span class="keyword">val</span> pool: Pools.Pool&lt;ByteBuffer&gt; = SynchronizedPool(maxNumThreads)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until maxNumThreads) &#123;</span><br><span class="line">      <span class="comment">//release这个函数含义是：将实例释放到缓存池中，提供给后续使用。</span></span><br><span class="line">      <span class="comment">//每个buffer的默认大小是16K</span></span><br><span class="line">      pool.release(ByteBuffer.allocate(DecodeBufferHelper.getRecommendedDecodeBufferSize()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pool</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片处理生产者序列"><a href="#图片处理生产者序列" class="headerlink" title="图片处理生产者序列"></a>图片处理生产者序列</h2><p>Fresco从一个图片的URL下载图片并解码成Bitmap需要经过一个生产者序列的处理。在<code>ImagePipeline#fetchDecodedImage</code>中开始生成队列并执行任务序列。下图展示了图片处理的所有生产者，其中有些序列默认是不使用的，除非进行特别配置或者特定场景。图中箭头的方向是图片数据流动的方向，而调用顺序正好相反，后面的Producer持有前面的Producer，当然这个持有只是对Producer接口的依赖，并不是直接依赖实现类。</p>
<img src="\assert\puml\da17508b5db418465c0efcfeea3c23c1b2ce1f31c013ccbaeb76364fc91fda4c.svg"/>

<h3 id="NetworkFetchProducer"><a href="#NetworkFetchProducer" class="headerlink" title="NetworkFetchProducer"></a>NetworkFetchProducer</h3><p>Fresco默认使用<code>HttpURLConnection</code>而不是Okhttp来请求网络图片，在生成ImagePipelineConfig时需要使用<code>OkHttpImagePipelineConfigFactory</code>来使用Okhttp来请求网络。</p>
<img src="\assert\puml\bfe76b1d3f07530a68a0c4aa343e19634fe5bb5476ed4e9b05ec1a1ad40d232d.svg"/>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NetworkFetchProducer.java</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(</span></span><br><span class="line"><span class="params">      FetchState fetchState, InputStream responseData, <span class="type">int</span> responseContentLength)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">final</span> PooledByteBufferOutputStream pooledOutputStream;</span><br><span class="line">    <span class="keyword">if</span> (responseContentLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pooledOutputStream = mPooledByteBufferFactory.newOutputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] ioArray = mByteArrayPool.get(READ_SIZE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">int</span> length;</span><br><span class="line">      <span class="comment">//responseData（InputStream）对应okhttp3.ResponseBody#byteStream，原始图片byte数据流</span></span><br><span class="line">      <span class="comment">//循环从InputStream中读取数据到ioArray中</span></span><br><span class="line">      <span class="keyword">while</span> ((length = responseData.read(ioArray)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//将图片数据写入到pooledOutputStream是MemoryPooledByteBufferOutputStream类型</span></span><br><span class="line">          pooledOutputStream.write(ioArray, <span class="number">0</span>, length);</span><br><span class="line">          maybeHandleIntermediateResult(pooledOutputStream, fetchState);</span><br><span class="line">          <span class="type">float</span> <span class="variable">progress</span> <span class="operator">=</span> calculateProgress(pooledOutputStream.size(), responseContentLength);</span><br><span class="line">          fetchState.getConsumer().onProgressUpdate(progress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());</span><br><span class="line">      handleFinalResult(pooledOutputStream, fetchState);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      mByteArrayPool.release(ioArray);</span><br><span class="line">      pooledOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>NetworkFetchProducer从网络请求的图片数据写入到<code>MemoryPooledByteBufferOutputStream</code>中。<code>MemoryPooledByteBufferOutputStream</code>从内存池中申请内存块（详情参考<a href="#%E5%86%85%E5%AD%98%E5%9D%97%E7%BC%93%E5%AD%98%E6%B1%A0-memorychunkpool">内存块缓存池</a>一节），在OutputStream的close中会把申请的内存块放回到内存池中。</p>
<p>NetworkFetchProducer处理结束时返回一个<code>EncodedImage</code>类型数据，class结构如下，图片数据保存在MemoryChunk中。</p>
<img src="\assert\puml\fb4ed904a2ac0c476b16183fb82d43e1e0fe2d8601f79e566a3d46abfad9b866.svg"/>

<h3 id="DiskCacheWriteProducer"><a href="#DiskCacheWriteProducer" class="headerlink" title="DiskCacheWriteProducer"></a>DiskCacheWriteProducer</h3><p>DiskCacheWriteProducer用于缓存原始图片数据，包括两级缓存：内存和磁盘。</p>
<img src="\assert\puml\e37373f1794704d4127ab7c5ebea3d0de4dea09fc40d878e4443a7c3dfb92872.svg"/>

<p>DiskCacheWriteProducer接收到下级Producer的EncodedImage后就会调用<code>BufferedDiskCache#put()</code>进行缓存。BufferedDiskCache在缓存图片时，会先把图片（EncodedImage）保存到StagingArea（mMap）中，即内存缓存，下次获取时也会优先从StagingArea中获取内存中的图片缓存。然后，在子线程中写入磁盘缓存。</p>
<h3 id="DiskCacheReadProducer"><a href="#DiskCacheReadProducer" class="headerlink" title="DiskCacheReadProducer"></a>DiskCacheReadProducer</h3><img src="\assert\puml\aa887992db9872b891a9220765ce70c98e46cd434e60f2c721d3da3c890d9fdc.svg"/>

<p>DiskCacheReadProducer也持有两个BufferedDiskCache，与DiskCacheWriteProducer中的同一个对象实例。从DiskCacheWriteProducer的分析中我们知道图片会优先保存到内存中（StagingArea）,读取时也优先使用内存中的缓存。</p>
<p>DiskCacheReadProducer启动后会先从缓存读取图片，如果存在缓存的图片就不会再调用下一级Producer，直接把结果返回给上一级。如果没有读取到缓存的图片，就会继续调用下一级Producer。</p>
<h3 id="EncodedMemoryCacheProducer"><a href="#EncodedMemoryCacheProducer" class="headerlink" title="EncodedMemoryCacheProducer"></a>EncodedMemoryCacheProducer</h3><img src="\assert\puml\b258dc8c68713aca122e5a81b9667dec14d2fc452817b9e84b196b14ff9ffd49.svg"/>

<p>EncodedMemoryCacheProducer执行时，会首先从MemoryCache读取缓存在内存中的图片，如果有缓存，则将缓存的图片传递给上一级生产者，不再执行下一级生产者。</p>
<img src="\assert\puml\488a6e5343945cce4904011cce280fbd577b16eae34bf8ad20c4d9b94912a05a.svg"/>

<p>加入缓存或者获取缓存等操作，都会触发缓存的清理，清理时如果超过了最大数量或者最大存储空间，都会进行清理，被清理掉的都是不被使用的图片，而且时最老的优先被清理。</p>
<h3 id="DecodeProducer"><a href="#DecodeProducer" class="headerlink" title="DecodeProducer"></a>DecodeProducer</h3><img src="\assert\puml\9a98634d0756c0291469499bd2114cbbc39fa77911d7c45913531bfb1f285909.svg"/>

<h3 id="BitmapMemoryCacheProducer"><a href="#BitmapMemoryCacheProducer" class="headerlink" title="BitmapMemoryCacheProducer"></a>BitmapMemoryCacheProducer</h3><img src="\assert\puml\a02367457338b720be1a7fd6c9480801829f94d8a155da43519c48f40a510b44.svg"/>

<p>配置参数的默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//imagepipeline/src/main/java/com/facebook/imagepipeline/cache/DefaultBitmapMemoryCacheParamsSupplier.java</span></span><br><span class="line">  <span class="keyword">public</span> MemoryCacheParams <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MemoryCacheParams</span>(</span><br><span class="line">        getMaxCacheSize(), <span class="comment">//maxCacheSize等于APP最大堆内存的四分之一，代码见后面</span></span><br><span class="line">        MAX_CACHE_ENTRIES, <span class="comment">//maxCacheEntries = 256</span></span><br><span class="line">        MAX_EVICTION_QUEUE_SIZE, <span class="comment">//maxEvictionQueueSize = Integer.MAX_VALUE</span></span><br><span class="line">        MAX_EVICTION_QUEUE_ENTRIES, <span class="comment">//maxEvictionQueueEntries = Integer.MAX_VALUE</span></span><br><span class="line">        MAX_CACHE_ENTRY_SIZE, <span class="comment">//maxCacheEntrySize = Integer.MAX_VALUE</span></span><br><span class="line">        PARAMS_CHECK_INTERVAL_MS); <span class="comment">//paramsCheckIntervalMs = 5 minutes</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxCacheSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//mActivityManager.getMemoryClass()是获取的没有设置android:largeHeap属性的APP的最大堆内存；</span></span><br><span class="line">    <span class="comment">//也就是获取系统属性dalvik.vm.heapgrowthlimit的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxMemory</span> <span class="operator">=</span></span><br><span class="line">        Math.min(mActivityManager.getMemoryClass() * ByteConstants.MB, Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">if</span> (maxMemory &lt; <span class="number">32</span> * ByteConstants.MB) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">4</span> * ByteConstants.MB;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxMemory &lt; <span class="number">64</span> * ByteConstants.MB) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">6</span> * ByteConstants.MB;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> maxMemory / <span class="number">4</span>; <span class="comment">//app最大堆内存的四分之一</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="从缓存获取Bitmap"><a href="#从缓存获取Bitmap" class="headerlink" title="从缓存获取Bitmap"></a>从缓存获取Bitmap</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LruCountingMemoryCache.java</span></span><br><span class="line">  <span class="keyword">public</span> CloseableReference&lt;V&gt; <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> K key)</span> &#123;</span><br><span class="line">    Preconditions.checkNotNull(key);</span><br><span class="line">    Entry&lt;K, V&gt; oldExclusive;</span><br><span class="line">    CloseableReference&lt;V&gt; clientRef = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      oldExclusive = mExclusiveEntries.remove(key); <span class="comment">//首先从回收列表移除</span></span><br><span class="line">      Entry&lt;K, V&gt; entry = mCachedEntries.get(key);  <span class="comment">//从LinkedHashMap中获取缓存的Bitmap</span></span><br><span class="line">      <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">        clientRef = newClientReference(entry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maybeNotifyExclusiveEntryRemoval(oldExclusive);</span><br><span class="line">    maybeUpdateCacheParams(); <span class="comment">//查看是否需要更新配置参数，前面已经介绍</span></span><br><span class="line">    maybeEvictEntries();</span><br><span class="line">    <span class="keyword">return</span> clientRef;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果内存超过最大限制，就会开始清理回收列表中存在的Bitmap</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maybeEvictEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span></span><br><span class="line">          Math.min(</span><br><span class="line">              mMemoryCacheParams.maxEvictionQueueEntries, <span class="comment">//maxEvictionQueueEntries默认是Integer.MAX_VALUE</span></span><br><span class="line">              mMemoryCacheParams.maxCacheEntries - getInUseCount()); <span class="comment">//maxCacheEntries默认是256</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span></span><br><span class="line">          Math.min(</span><br><span class="line">              mMemoryCacheParams.maxEvictionQueueSize, <span class="comment">//maxEvictionQueueSize默认值Integer.MAX_VALUE</span></span><br><span class="line">              mMemoryCacheParams.maxCacheSize - getInUseSizeInBytes()); <span class="comment">//maxCacheSize是APP最大堆内存的四分之一</span></span><br><span class="line">      oldEntries = trimExclusivelyOwnedEntries(maxCount, maxSize);</span><br><span class="line">      makeOrphans(oldEntries);</span><br><span class="line">    &#125;</span><br><span class="line">    maybeClose(oldEntries);</span><br><span class="line">    maybeNotifyExclusiveEntryRemoval(oldEntries);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getInUseCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mCachedEntries.getCount() - mExclusiveEntries.getCount();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getInUseSizeInBytes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mCachedEntries.getSizeInBytes() - mExclusiveEntries.getSizeInBytes();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> ArrayList&lt;Entry&lt;K, V&gt;&gt; <span class="title function_">trimExclusivelyOwnedEntries</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    count = Math.max(count, <span class="number">0</span>);</span><br><span class="line">    size = Math.max(size, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// fast path without array allocation if no eviction is necessary</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mExclusiveEntries.getCount() &lt;= count &amp;&amp; mExclusiveEntries.getSizeInBytes() &lt;= size) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Entry&lt;K, V&gt;&gt; oldEntries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.mExclusiveEntries.getCount() &gt; count || mExclusiveEntries.getSizeInBytes() &gt; size) &#123;</span><br><span class="line">      <span class="meta">@Nullable</span> <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> mExclusiveEntries.getFirstKey();</span><br><span class="line">      <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIgnoreSizeMismatch) &#123;</span><br><span class="line">          mExclusiveEntries.resetSize();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            String.format(</span><br><span class="line">                <span class="string">&quot;key is null, but exclusiveEntries count: %d, size: %d&quot;</span>,</span><br><span class="line">                <span class="built_in">this</span>.mExclusiveEntries.getCount(), mExclusiveEntries.getSizeInBytes()));</span><br><span class="line">      &#125;</span><br><span class="line">      mExclusiveEntries.remove(key);</span><br><span class="line">      oldEntries.add(mCachedEntries.remove(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldEntries;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="BitmapPrepareProducer"><a href="#BitmapPrepareProducer" class="headerlink" title="BitmapPrepareProducer"></a>BitmapPrepareProducer</h3><p>BitmapPrepareProducer只有一个作用，就是调用<code>Bitmap#prepareToDraw()</code>。prepareToDraw接口会构建一个用于绘制的缓存。从Android7.0开始，这个接口会在RenderThread线程上启动GPU的异步上传。开启硬件加速后，Bitmap必须上传到GPU才能被渲染。Bitmap第一次绘制时会默认就执行GPU上传动作，但是这个有几毫秒的耗时，图片越大耗时越高。通过调用prepareToDraw可以提前完成上传GPU的动作，这样可以节省第一帧的显示时间。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.google.cn/topic/performance/graphics/manage-memory">Managing Bitmap Memory</a><br><a href="https://www.cnblogs.com/wytiger/p/5690039.html">Fresco内存机制(Ashmem匿名共享内存）</a><br><a href="https://www.kaelli.com/9.html">Android网络加载图片库对比：Fresco、Glide、Picasso</a><br><a href="https://www.jianshu.com/p/6f042f9e47a8">Android | Bitmap的Java对象GC之后，对应的native内存会回收吗？</a><br><a href="https://blog.csdn.net/niuba123456/article/details/86548437">Android图片缓存框架 - Fresco设置和清除缓存(十一)</a></p>
<!-- 生产者序列图按照执行序列 -->
<!-- ```plantuml
@startuml
skinparam componentStyle rectangle
component [DelayProducer] #back:white;line.dotted
[DelayProducer] -> [BitmapPrepareProducer]
component [PostprocessedBitmapMemoryCacheProducer] #back:white;line.dotted
[BitmapPrepareProducer] -> [PostprocessedBitmapMemoryCacheProducer]
[PostprocessedBitmapMemoryCacheProducer] -> [PostprocessorProducer]
component [PostprocessorProducer] #back:white;line.dotted
[PostprocessorProducer] -\-> [BitmapProbeProducer]
component [BitmapProbeProducer] #back:white;line.dotted
[BitmapProbeProducer] -left-> [BitmapMemoryCacheGetProducer]
[BitmapMemoryCacheGetProducer] -left-> [ThreadHandoffProducer]
[ThreadHandoffProducer] -left-> [BitmapMemoryCacheKeyMultiplexProducer]
[BitmapMemoryCacheKeyMultiplexProducer] -\-> [BitmapMemoryCacheProducer]
[BitmapMemoryCacheProducer] -> [DecodeProducer]
[DecodeProducer] -> [ResizeAndRotateProducer]
[ResizeAndRotateProducer] -> [AddImageTransformMetaDataProducer]
[AddImageTransformMetaDataProducer] -\-> [EncodedCacheKeyMultiplexProducer]
component [EncodedProbeProducer] #back:white;line.dotted
[EncodedCacheKeyMultiplexProducer] -left-> [EncodedProbeProducer]
[EncodedProbeProducer] -left-> [EncodedMemoryCacheProducer]
[EncodedMemoryCacheProducer] -left-> [DiskCacheReadProducer]
[DiskCacheReadProducer] -\-> [DiskCacheWriteProducer]
[DiskCacheWriteProducer] -> [PartialDiskCacheProducer]
component [PartialDiskCacheProducer] #back:white;line.dotted
[PartialDiskCacheProducer] -> [WebpTranscodeProducer]
component [WebpTranscodeProducer] #back:white;line.dotted
[WebpTranscodeProducer] -> [NetworkFetchProducer]
@enduml
``` -->]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fresco</tag>
      </tags>
  </entry>
  <entry>
    <title>LeakCanary源码详解</title>
    <url>/posts/faedbb97.html</url>
    <content><![CDATA[<p>本文基于LeakCanary 2.12进行分析。</p>
<img src="\assert\puml\5956ed6f46404b9ae4f0a580bdbdd8c8aa7a05645c598e56d57926aa4dc676c6.svg"/>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>引入LeakCanary时，只需要引入maven库的坐标即可，如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.12&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不需要进行任何的代码改动就可以使用LeakCanary了。另外，引入leakcanary时使用的是debugImplementation表示只在debug版本中才会集成leakcanary，release版本不会集成。</p>
<p>那么，leakcanary如何完成初始化呢？</p>
<p>leakcanary使用了<code>ContentProvider</code>来进行初始化，当app启动时系统会自动初始化注册的ContentProvider。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:name</span>=<span class="string">&quot;leakcanary.internal.MainProcessAppWatcherInstaller&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:enabled</span>=<span class="string">&quot;@bool/leak_canary_watcher_auto_install&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcessAppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>系统初始化ContentProvider的时机在Application之前，即<code>ContentProvider#onCreate</code>先于<code>Application#onCreate</code>来执行，但此时Application的实例已经存在了。</p>
<h3 id="注册内存泄漏监视器"><a href="#注册内存泄漏监视器" class="headerlink" title="注册内存泄漏监视器"></a>注册内存泄漏监视器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,</span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)</span><br><span class="line">) &#123;</span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="keyword">if</span> (isInstalled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  check(retainedDelayMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="string">&quot;retainedDelayMillis <span class="variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.retainedDelayMillis = retainedDelayMillis</span><br><span class="line">  <span class="keyword">if</span> (application.isDebuggableBuild) &#123;</span><br><span class="line">    LogcatSharkLog.install()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Requires AppWatcher.objectWatcher to be set</span></span><br><span class="line">  LeakCanaryDelegate.loadLeakCanary(application)</span><br><span class="line"></span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Only install after we&#x27;re fully done with init.</span></span><br><span class="line">  installCause = RuntimeException(<span class="string">&quot;manualInstall() first called here&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appDefaultWatchers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reachabilityWatcher: <span class="type">ReachabilityWatcher</span> = objectWatcher</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;InstallableWatcher&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> listOf(</span><br><span class="line">    ActivityWatcher(application, reachabilityWatcher), <span class="comment">//Activity内存泄漏监视器</span></span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher), <span class="comment">//Fragment和ViewModel内存泄漏监视器</span></span><br><span class="line">    RootViewWatcher(reachabilityWatcher), <span class="comment">//RootView内存泄漏监视器</span></span><br><span class="line">    ServiceWatcher(reachabilityWatcher) <span class="comment">//服务内存泄漏监视器</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Activity泄漏监视"><a href="#Activity泄漏监视" class="headerlink" title="Activity泄漏监视"></a>Activity泄漏监视</h2><p>Activity的内存泄漏通过ActivityWatcher来监控。下图是Activity泄漏监控相关类图结构：</p>
<img src="\assert\puml\638e67c93e92406b3f1838c883fa4e83b3a328a1ed8e675470a299e4495a4e54.svg"/>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher <span class="comment">//ObjectWatcher实例</span></span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks = <span class="comment">//activity生命周期监听事件回调</span></span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="comment">//当Activity被销毁时会收到onActivityDestroyed事件通知，其中activity参数就是被销毁的activity实例</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化时调用，注册Activity生命周期回调监听</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityWatcher的作用是注册Activity生命周期监听，在onActivityDestroyed时将activity实例通过<code>ObjectWatcher#expectWeaklyReachable</code>注册到监控表中。下面看下<code>ObjectWatcher#expectWeaklyReachable</code>的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">expectWeaklyReachable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID().toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">  <span class="comment">//KeyedWeakReference是弱引用，是WeakReference的子类</span></span><br><span class="line">  <span class="keyword">val</span> reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  ......</span><br><span class="line">  watchedObjects[key] = reference  <span class="comment">//存入监控表中</span></span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    moveToRetained(key) <span class="comment">//弱引用标记为retained状态（既没有被回收）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一个弱引用KeyedWeakReference来持有activity，然后注册到监控表中。KeyedWeakReference构造函数指定了<code>ReferenceQueue</code>，因此当实例被回收后，弱引用就会被添加到<code>ReferenceQueue</code>中。</p>
<p>最后通过checkRetainedExecutor来执行一个Runnable任务，checkRetainedExecutor在ObjectWatcher的构造函数中传入，定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> objectWatcher = ObjectWatcher(</span><br><span class="line">  clock = &#123; SystemClock.uptimeMillis() &#125;,</span><br><span class="line">  checkRetainedExecutor = &#123;</span><br><span class="line">    check(isInstalled) &#123;</span><br><span class="line">      <span class="string">&quot;AppWatcher not installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在主线程执行一个延时任务，retainedDelayMillis默认值是5秒</span></span><br><span class="line">    mainHandler.postDelayed(it, retainedDelayMillis)</span><br><span class="line">  &#125;,</span><br><span class="line">  isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>总结一下上面的代码流程：当activity被销毁后，会创建一个弱引用KeyedWeakReference来持有这个activity实例，KeyedWeakReference还包含了一个uuid和activity的描述信息，而且弱引用关联了ReferenceQueue，在对象实例被回收后，弱引用本身会被添加到ReferenceQueue中。然后启动一个延时5秒（可配置）的任务来检查这个弱引用持有的实例是否被回收。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用队列，当弱引用持有的实例被回收后，弱引用本身会被添加到队列中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  removeWeaklyReachableObjects() <span class="comment">//清理已经被GC回收的对象弱引用</span></span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123; <span class="comment">//不为空表示key对应的监控对象（activity）没有被回收，可能存在内存泄漏</span></span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis() <span class="comment">//更新retained时间</span></span><br><span class="line">    <span class="comment">//onObjectRetainedListeners是一个监听者列表，InternalLeakCanary就是其中之一，默认也是唯一的一个</span></span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从引用队列中拿到的对象就表示这个实例已经被GC正常回收了，所以从监控表中删除引用</span></span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当检测到对象没有被回收后，会调用<code>leakcanary.internal.InternalLeakCanary#onObjectRetained</code>来触发泄漏检测：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InternalLeakCanary.kt</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> = scheduleRetainedObjectCheck()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">      heapDumpTrigger.scheduleRetainedObjectCheck()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HeapDumpTrigger.kt</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    delayMillis: <span class="type">Long</span> = <span class="number">0</span>L  <span class="comment">//默认延时是0，调用时没有传参，所以使用默认值0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">    <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    checkScheduledAt = SystemClock.uptimeMillis() + delayMillis</span><br><span class="line">    backgroundHandler.postDelayed(&#123;  <span class="comment">//启动后台任务</span></span><br><span class="line">      checkScheduledAt = <span class="number">0</span></span><br><span class="line">      checkRetainedObjects()</span><br><span class="line">    &#125;, delayMillis)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检测内存泄漏</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ......<span class="comment">//忽略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取泄漏对象个数</span></span><br><span class="line">    <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      gcTrigger.runGc() <span class="comment">//执行Runtime.getRuntime().gc()</span></span><br><span class="line">      retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查对象泄漏个数，如果小于阈值（默认是5）直接返回不执行后续步骤</span></span><br><span class="line">    <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">    <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line">    <span class="comment">//如果距离上次分析堆栈信息不足1分钟则返回</span></span><br><span class="line">    <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">      onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">      showRetainedCountNotification(</span><br><span class="line">        objectCount = retainedReferenceCount,</span><br><span class="line">        contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">      )</span><br><span class="line">      scheduleRetainedObjectCheck(</span><br><span class="line">        delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dismissRetainedCountNotification()</span><br><span class="line">    <span class="keyword">val</span> visibility = <span class="keyword">if</span> (applicationVisible) <span class="string">&quot;visible&quot;</span> <span class="keyword">else</span> <span class="string">&quot;not visible&quot;</span></span><br><span class="line">    dumpHeap( <span class="comment">//保存堆栈信息</span></span><br><span class="line">      retainedReferenceCount = retainedReferenceCount,</span><br><span class="line">      retry = <span class="literal">true</span>,</span><br><span class="line">      reason = <span class="string">&quot;<span class="variable">$retainedReferenceCount</span> retained objects, app is <span class="variable">$visibility</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\e81ec700d921577d11b1cae9ad3e0fc3441d5fc6fc3da2775985885479f572b1.svg"/>

<h2 id="Service泄漏监控"><a href="#Service泄漏监控" class="headerlink" title="Service泄漏监控"></a>Service泄漏监控</h2><p>Activity可以通过Application注册生命周期事件回调来监控Activity的销毁，但是Service没有这样的机制，需要采用hook系统AMS方式来监控Service的销毁。</p>
<p>Service的内存泄漏监控分为两个阶段：onServicePreDestroy和onServiceDestroyed。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServicePreDestroy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  token: <span class="type">IBinder</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  service: <span class="type">Service</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  servicesToBeDestroyed[token] = WeakReference(service)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDestroyed</span><span class="params">(token: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">  servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;</span><br><span class="line">    serviceWeakReference.<span class="keyword">get</span>()?.let &#123; service -&gt;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        service, <span class="string">&quot;<span class="subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出<code>onServicePreDestroy</code>的作用是把service对象通过弱引用保存到map中，然后在<code>onServiceDestroyed</code>中取出service对象，并触发泄漏检测逻辑。</p>
<h3 id="onServicePreDestroy获取service实例"><a href="#onServicePreDestroy获取service实例" class="headerlink" title="onServicePreDestroy获取service实例"></a>onServicePreDestroy获取service实例</h3><p>Service的创建、绑定、停止都会走到<code>ActivityThread.H</code>类，<code>ActivityThread</code>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ActivityThread</span> <span class="keyword">extends</span> <span class="title class_">ClientTransactionHandler</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ActivityThreadInternal</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;IBinder, Service&gt; mServices = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CREATE_SERVICE</span>          <span class="operator">=</span> <span class="number">114</span>; <span class="comment">//创建服务</span></span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVICE_ARGS</span>            <span class="operator">=</span> <span class="number">115</span>; <span class="comment">//Service#onStartCommand</span></span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP_SERVICE</span>            <span class="operator">=</span> <span class="number">116</span>; <span class="comment">//停止服务</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BIND_SERVICE</span>            <span class="operator">=</span> <span class="number">121</span>; <span class="comment">//绑定服务</span></span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNBIND_SERVICE</span>          <span class="operator">=</span> <span class="number">122</span>; <span class="comment">//解绑</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">case</span> STOP_SERVICE:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;serviceStop&quot;</span>);</span><br><span class="line">                    handleStopService((IBinder)msg.obj);</span><br><span class="line">                    schedulePurgeIdler();</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123; <span class="comment">//返回false，还会继续执行后面的handleMessage</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>通过反射替换掉<code>ActivityThread.mH.mCallback</code>，替换后的Callback如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ServiceWatcher.kt</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      swapActivityThreadHandlerCallback &#123; mCallback -&gt;</span><br><span class="line">        uninstallActivityThreadHandlerCallback = &#123;</span><br><span class="line">          swapActivityThreadHandlerCallback &#123;</span><br><span class="line">            mCallback</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Handler.Callback &#123; msg -&gt;</span><br><span class="line">          <span class="keyword">if</span> (msg.obj !<span class="keyword">is</span> IBinder) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">false</span> <span class="comment">//返回false后，继续执行H类的消息处理</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (msg.what == STOP_SERVICE) &#123;</span><br><span class="line">            <span class="keyword">val</span> key = msg.obj <span class="keyword">as</span> IBinder</span><br><span class="line">            activityThreadServices[key]?.let &#123; <span class="comment">//获取service实例</span></span><br><span class="line">              onServicePreDestroy(key, it)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//mCallback就是通过反射获取的ActivityThread.mH.mCallback</span></span><br><span class="line">          mCallback?.handleMessage(msg) ?: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>通过mH.mCallback只能拿到service的token，并没有拿到service实例。service实例的获取是通过反射获取ActivityThread中的mServices。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> activityThreadServices <span class="keyword">by</span> lazy &#123;</span><br><span class="line">  <span class="keyword">val</span> mServicesField =</span><br><span class="line">    activityThreadClass.getDeclaredField(<span class="string">&quot;mServices&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">  mServicesField[activityThreadInstance] <span class="keyword">as</span> Map&lt;IBinder, Service&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ActivityThread.mH反射方式可以拿到Service的停止事件，这是service stop开始执行的时机，此时可以从<code>ActivityThread.mServices</code>获取到service实例，之后service实例就会从map中删除，就再也拿不到了，这就是分成了onServicePreDestroy和onServiceDestroyed两个阶段的根本原因。</p>
<h3 id="onServiceDestroyed监控Service-destroy"><a href="#onServiceDestroyed监控Service-destroy" class="headerlink" title="onServiceDestroyed监控Service destroy"></a>onServiceDestroyed监控Service destroy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\core\java\android\app\ActivityThread.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleStopService</span><span class="params">(IBinder token)</span> &#123;</span><br><span class="line">        mServicesData.remove(token);</span><br><span class="line">        <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.remove(token);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Destroying service &quot;</span> + s);</span><br><span class="line">                s.onDestroy();   <span class="comment">//执行Service#onDestroy</span></span><br><span class="line">                s.detachAndCleanUp();</span><br><span class="line">                <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> s.getBaseContext();</span><br><span class="line">                <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">who</span> <span class="operator">=</span> s.getClassName();</span><br><span class="line">                    ((ContextImpl) context).scheduleFinalCleanup(who, <span class="string">&quot;Service&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//Service#onDestroy执行完成后的最终时机</span></span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            token, SERVICE_DONE_EXECUTING_STOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                            <span class="string">&quot;Unable to stop service &quot;</span> + s</span><br><span class="line">                            + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                Slog.i(TAG, <span class="string">&quot;handleStopService: exception for &quot;</span> + token, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;handleStopService: token=&quot;</span> + token + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Slog.i(TAG, &quot;Running services: &quot; + mServices);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出Service停止最后执行的是<code>ActivityManager.getService().serviceDoneExecuting</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks\base\core\java\android\app\ActivityManager.java</span></span><br><span class="line"><span class="meta">@SystemService(Context.ACTIVITY_SERVICE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivityManager</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Singleton</span>&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> IActivityManager <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    <span class="keyword">return</span> am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\2855ba07281b12eabd0e481d6f37092175c613c4e279472c0be60612716f4287.svg"/>

<p>LeakCanary通过动态代理<code>IActivityManager</code>接口的方式来hook serviceDoneExecuting。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ServiceWatcher.kt</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">      swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;</span><br><span class="line">        uninstallActivityManager = &#123;</span><br><span class="line">          swapActivityManager &#123; _, _ -&gt;</span><br><span class="line">            activityManagerInstance</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">          activityManagerInterface.classLoader, arrayOf(activityManagerInterface)</span><br><span class="line">        ) &#123; _, method, args -&gt;</span><br><span class="line">          <span class="keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;</span><br><span class="line">            <span class="keyword">val</span> token = args!![<span class="number">0</span>] <span class="keyword">as</span> IBinder</span><br><span class="line">            <span class="keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">              onServiceDestroyed(token)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">              method.invoke(activityManagerInstance)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              method.invoke(activityManagerInstance, *args)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (invocationException: InvocationTargetException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> invocationException.targetException</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDestroyed</span><span class="params">(token: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">    servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;</span><br><span class="line">      serviceWeakReference.<span class="keyword">get</span>()?.let &#123; service -&gt;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable( <span class="comment">//后面步骤就和activity的相同了</span></span><br><span class="line">          service, <span class="string">&quot;<span class="subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fragment泄漏监控"><a href="#Fragment泄漏监控" class="headerlink" title="Fragment泄漏监控"></a>Fragment泄漏监控</h2><p>Fragment的监控是先接收onActivityCreated事件，然后通过activity拿到FragmentManager，然后注册FragmentLifecycleCallbacks，通过onFragmentViewDestroyed回调事件来监控fragment view的内存泄漏，通过onFragmentDestroyed回调事件来监控fragment的泄漏。</p>
<img src="\assert\puml\9a0f8e5a7c963b50aeefc7cd45b43a9ea971e139e8962d40a92f562ffca22051.svg"/>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">AndroidOFragmentDestroyWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : (Activity) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentLifecycleCallbacks = <span class="keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> view = fragment.view</span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          view, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +</span><br><span class="line">          <span class="string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        fragment, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fragmentManager = activity.fragmentManager</span><br><span class="line">    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewModel泄漏监控"><a href="#ViewModel泄漏监控" class="headerlink" title="ViewModel泄漏监控"></a>ViewModel泄漏监控</h3><p>在AndroidXFragmentDestroyWatcher中初始化ViewModel的泄漏监控。<code>ViewModelClearedWatcher</code>继承自ViewModel。</p>
<img src="\assert\puml\2e7d4c398410c458eabc546be0482549d6692d68cd45c7f5fd74795f5e17a7fc.svg"/>

<p>FragmentActivity和Fragment都是ViewModelStoreOwner，所以在两者的create时机都会创建<code>ViewModelClearedWatcher</code>，并注册。ViewModelClearedWatcher本身也是一个ViewModel，当<code>ViewModelClearedWatcher#onCleared</code>被调用时，<code>ViewModelStoreOwner</code>中注册的ViewModel都会被clear。所以onCleared时，通过反射拿到<code>ViewModelStore#mMap</code>，将map中所有的ViewModel进行泄漏监控。</p>
<h2 id="RootView泄漏监控"><a href="#RootView泄漏监控" class="headerlink" title="RootView泄漏监控"></a>RootView泄漏监控</h2><p><code>RootViewWatcher</code>实现了对RootView内存泄漏的监控。原理是：<code>WindowManagerGlobal#mViews</code>就是存放DecorView的列表，通过反射把mViews替换为自定义的ArrayList。然后在<code>WindowManagerGlobal#addView</code>和<code>WindowManagerGlobal#removeView</code>就可以执行到自定义ArrayList的add和remove方法，从而得到RootView的添加和删除时机，从而触发内存泄漏检测逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowManagerGlobal</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;View&gt;();</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> WindowManagerGlobal <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sDefaultWindowManager == <span class="literal">null</span>) &#123;</span><br><span class="line">                sDefaultWindowManager = <span class="keyword">new</span> <span class="title class_">WindowManagerGlobal</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sDefaultWindowManager;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>RootViewWatcher会监听rootView的添加时机，然后调用<code>rootView.addOnAttachStateChangeListener</code>来接收onViewAttachedToWindow和onViewDetachedFromWindow事件。当onViewDetachedFromWindow时就会去检测是否发生内存泄漏。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/gdutxiaoxu/article/details/80738581">java 源码系列 - 带你读懂 Reference 和 ReferenceQueue</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>图解RecyclerView缓存机制</title>
    <url>/posts/e679f521.html</url>
    <content><![CDATA[<img src="\assert\puml\6983a52eff2e3aac41f6890b280b7f38ee1ef2df019c995b6ddd90706c68334a.svg"/>

<h2 id="删除View缓存使用图解"><a href="#删除View缓存使用图解" class="headerlink" title="删除View缓存使用图解"></a>删除View缓存使用图解</h2><p><img src="/images/RecyclerView/remove_item.drawio.svg" alt="RecyclerView移除元素"></p>
<p>在垂直布局的RecyclerView中展示了Item0~Item4这5个TextView，我们现在把Item2删掉。数据更新后，我们调用<code>Adapter#notifyItemRemoved(2)</code>来提交更新。</p>
<p><img src="/images/RecyclerView/remove_item_cache_use_sequence.drawio.svg" alt="RecyclerView删除Item"></p>
<p><strong>dispatchLayoutStep1阶段：</strong></p>
<ol>
<li>调用detachViewFromParent把Item0~Item4这五个View从RecyclerView中detache掉，然后放入把ViewHolder放入mAttachedScrap进行缓存。ViewHodler都会被标记为FLAG_TMP_DETACHED，并且Item2会被标记为FLAG_REMOVED；</li>
<li>然后layout进行填充，把Item0~Item4从mAttachedScrap中取出，然后调用attachViewToParent重新加入到RecyclerView中。</li>
<li>调用onCreateViewHolder创建一个新ViewHolder（Item5），执行onBindViewHolder，并addView到RecyclerView中。</li>
</ol>
<p><strong>dispatchLayoutStep2阶段：</strong></p>
<ol>
<li>调用detachViewFromParent把Item0~Item5这六个View从RecyclerView中detache掉，然后把ViewHolder放入mAttachedScrap进行缓存。ViewHolder都会被标记为FLAG_TMP_DETACHED，并且Item2会被标记为FLAG_REMOVED；</li>
<li>除了Item2的ViewHolder之外，把其他ViewHolder从mAttachedScrap缓存中取出，然后调用attachViewToParent重新加入到RecyclerView中。</li>
</ol>
<p><strong>dispatchLayoutStep3阶段：</strong></p>
<ol>
<li>从mAttachedScrap取出Item2，然后把Item2 View添加到mHiddenViews中；</li>
<li>在Item2 ItemAnimator的onAnimationFinished事件中把Item2从mAttachedScrap中移除，添加到RecycledViewPool中。</li>
</ol>
<h2 id="修改View缓存使用图解"><a href="#修改View缓存使用图解" class="headerlink" title="修改View缓存使用图解"></a>修改View缓存使用图解</h2><p><img src="/images/RecyclerView/change_item_text.drawio.svg" alt="RecyclerView修改Item"></p>
<p>RecyclerView中包含Item0~Item4共五个TextView，我们把Item2的文案更新为”New 2”。通过调用<code>Adapter#notifyItemChanged(2)</code>来通知RecyclerView进行更新。</p>
<p><img src="/images/RecyclerView/change_item_sequence.drawio.svg" alt="RecyclerView修改"></p>
<h2 id="插入View缓存使用图解"><a href="#插入View缓存使用图解" class="headerlink" title="插入View缓存使用图解"></a>插入View缓存使用图解</h2><p><img src="/images/RecyclerView/insert_item.drawio.svg" alt="RecyclerView插入Item"></p>
<p><img src="/images/RecyclerView/insert_item_sequence.drawio.svg" alt="RecyclerView插入Item时序"></p>
<h2 id="预加载缓存-mCachedViews"><a href="#预加载缓存-mCachedViews" class="headerlink" title="预加载缓存 mCachedViews"></a>预加载缓存 mCachedViews</h2><p>预加载的view会放在这里，这个数组最大默认是2。首次绘制出来，如果没有滑动屏幕，mCachedViews为空，当滑动UI后会将预加载的一个，以及划出的加入缓存中。</p>
<p><img src="/images/RecyclerView_mCachedViews.drawio.svg" alt="mCachedViews存储元素"></p>
<p>如果是向下滑动，则屏幕下面的元素会缓存两个，比如上图右边向下把H滑出屏幕，而C会露出，则mCachedViews中保存的是[B, H, I]。</p>
<h3 id="滑动时预加载流程"><a href="#滑动时预加载流程" class="headerlink" title="滑动时预加载流程"></a>滑动时预加载流程</h3><p><code>androidx.recyclerview.widget.RecyclerView#onTouchEvent</code>接收到<code>MotionEvent.ACTION_MOVE</code>事件时，如果判断滑动超过一定的距离时，就任务用户自滑动操作。然后就会调用<code>GapWorker#postFromTraversal</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//androidx/recyclerview/widget/GapWorker.java</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postFromTraversal</span><span class="params">(RecyclerView recyclerView, <span class="type">int</span> prefetchDx, <span class="type">int</span> prefetchDy)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (recyclerView.isAttachedToWindow()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RecyclerView.DEBUG &amp;&amp; !mRecyclerViews.contains(recyclerView)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;attempting to post unregistered view!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPostTimeNs == <span class="number">0</span>) &#123;</span><br><span class="line">                mPostTimeNs = recyclerView.getNanoTime();</span><br><span class="line">                recyclerView.post(<span class="built_in">this</span>); <span class="comment">//将自己转到主线程去执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置用户滑动的距离</span></span><br><span class="line">        recyclerView.mPrefetchRegistry.setPrefetchVector(prefetchDx, prefetchDy);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\76f8ab8a3fb6ee6a9369938431227223977ffa07a052ab0d2e28b2717b3b958e.svg"/>

<h2 id="mAttachedScrap"><a href="#mAttachedScrap" class="headerlink" title="mAttachedScrap"></a>mAttachedScrap</h2><p>先看下源码执行流程：</p>
<img src="\assert\puml\0a7e545135b0fbe088833b032e660b43b3e0161f5467deb88d9a9808f97aebc0.svg"/>

<p>从上面时序图可以看出，最终调用到了父类<code>View#requestLayout()</code>，然后调用<code>mParent.requestLayout();</code>，沿着view层级一直调用到<code>android.view.ViewRootImpl#requestLayout()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android-31\android\view\ViewRootImpl.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//添加同步屏障，保障vsync信号会优先执行</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            <span class="comment">//等待下一个vsync信号来执行TraversalRunnable</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//移除同步屏障</span></span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，requestLayout不会立马执行，而是等待下一个vsync信号到来再执行，最终执行<code>android.view.ViewRootImpl#performTraversals</code>，这个函数很长有800多行，这里就不贴代码了，这里面就会View的绘制的measure、layout、draw三大流程。分别对应：<code>ViewRootImpl#measureHierarchy</code>、<code>ViewRootImpl#performLayout</code>、<code>ViewRootImpl#performDraw</code>。</p>
<img src="\assert\puml\1c5df462ff8a3457540cbbdc11fbbea04d24298c5e8d5c63b197023a240f39e7.svg"/>

<h2 id="从缓存获取ViewHolder"><a href="#从缓存获取ViewHolder" class="headerlink" title="从缓存获取ViewHolder"></a>从缓存获取ViewHolder</h2><p>首次创建ViewHolder，以及从缓存中获取都是通过<code>androidx.recyclerview.widget.RecyclerView.Recycler#getViewForPosition(int)</code>，这个方法会优先使用缓存中ViewHolder，如果找不到，就会调用createViewHolder和bindViewHolder创建一个新的，并返回ViewHodler的itemView：</p>
<p><img src="/images/RecyclerView/RecyclerView%E6%9F%A5%E6%89%BE%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.svg" alt="ViewHolder查找创建流程"></p>
<h2 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h2><img src="\assert\puml\bb8bb9acb56eae0a874798df209257546867cc37e9b22c9b0786aa8d233b0bc2.svg"/>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>addr2line死机问题定位</title>
    <url>/posts/9839.html</url>
    <content><![CDATA[<p>死机问题在程序开发过程中是经常遇到的问题，本文介绍通过addr2line工具解析堆栈来定位死机问题</p>
<h2 id="使用addr2line定位死机问题"><a href="#使用addr2line定位死机问题" class="headerlink" title="使用addr2line定位死机问题"></a>使用addr2line定位死机问题</h2><p>在某个C应用程序挂掉后，会生成堆栈信息，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F/libc    (21866): Fatal signal 11 (SIGSEGV) at 0x00000000 (code=1)</span><br><span class="line">W/        (21866): [SkCanvas* DrawSurface::lockCanvas(const android::Rect&amp;)]-----[76]</span><br><span class="line">I/DEBUG   (  944): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">I/DEBUG   (  944): Build fingerprint: &#x27;full_godbox/godbox:4.0.3/8841C/84125002:eng/ test-keys&#x27;</span><br><span class="line">I/DEBUG   (  944): pid: 21866, tid: 21866  &gt;&gt;&gt; demo_cmd &lt;&lt;&lt;</span><br><span class="line">I/DEBUG   (  944): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 00000000</span><br><span class="line">I/DEBUG   (  944):  r0 00000003  r1 00000000  r2 000010b0  r3 0000001f</span><br><span class="line">I/DEBUG   (  944):  r4 41334124  r5 00000000  r6 beae2f94  r7 00000046</span><br><span class="line">I/DEBUG   (  944):  r8 beae2f08  r9 00000010  10 00000bb8  fp beae3024</span><br><span class="line">I/DEBUG   (  944):  ip 400c6108  sp beae2f00  lr 41331d13  pc 41331d42  cpsr 00000030</span><br><span class="line">I/DEBUG   (  944):  d0  0000000000000000  d1  0000000000000000</span><br><span class="line">I/DEBUG   (  944):  d2  0000000000000000  d3  c1859800408ca000</span><br><span class="line">I/DEBUG   (  944):  d4  4125f000c1981600  d5  43ff000041200000</span><br><span class="line">I/DEBUG   (  944):  d6  0000000000000000  d7  0000000000000000</span><br><span class="line">I/DEBUG   (  944):  d8  0000000000000000  d9  0000000000000000</span><br><span class="line">I/DEBUG   (  944):  d10 0000000000000000  d11 0000000000000000</span><br><span class="line">I/DEBUG   (  944):  d12 0000000000000000  d13 0000000000000000</span><br><span class="line">I/DEBUG   (  944):  d14 0000000000000000  d15 0000000000000000</span><br><span class="line">I/DEBUG   (  944):  scr 60000010</span><br><span class="line">I/DEBUG   (  944):</span><br><span class="line">I/DEBUG   (  944):          #00  pc 00002d42  /system/lib/libtest.so (std_ping)</span><br><span class="line">I/DEBUG   (  944):          #01  pc 0000f466  /system/bin/demo_cmd</span><br><span class="line">I/DEBUG   (  944):</span><br><span class="line">I/DEBUG   (  944): code around pc:</span><br></pre></td></tr></table></figure>

<p>这种情况下就可以通过<font color=blue>addr2line</font>命令定位出死在了哪一行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addr2line -e libtest.so 00002d42</span><br><span class="line">addr2line -e demo_cmd 0000f466</span><br></pre></td></tr></table></figure>

<p>注意：我们机顶盒上的so库或者可执行程序，一般都是被stripped的，是无法使用addr2line命令定位死机位置的。这种情况下，则需要找到对应的not stripped的同名文件。这两个文件必须是同一次编译生成的。<br>&ensp; 可以使用file命令查看strip状态，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file system/bin/demo_cmd</span><br><span class="line">system/bin/demo_cmd: ELF 32-bit LSB  shared object, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), stripped</span><br><span class="line">$ file symbols/system/bin/demo_cmd</span><br><span class="line">symbols/system/bin/demo_cmd: ELF 32-bit LSB  shared object, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), not stripped</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li>本文介绍的所有命令，都是在Linux主机上执行的命令；</li>
<li>addr2line解析的文件必须是”<font color=red>not stripped</font>“的文件。如果是android sdk，一般放在out的symbols目录下，比如：out/target/product/xxx/symbols/</li>
<li>如果是Android机顶盒，应用程序挂掉后在/data/tombstones/目录下面会生成墓碑文件tombstone_*。在这些文件中就会有堆栈信息。</li>
</ul>
<h2 id="Android墓碑文件tombstone"><a href="#Android墓碑文件tombstone" class="headerlink" title="Android墓碑文件tombstone"></a>Android墓碑文件tombstone</h2><p>Android logcat打印的日志可以显示堆栈信息，但堆栈信息同时会保存到墓碑文件中。</p>
<p>当一个动态库（native 程序）开始执行时，系统会注册一些连接到 debuggerd 的 signal handlers，当系统 crash 的时候，会保存一个 tombstone 文件到/data/tombstones目录下（Logcat中也会有相应的信息），文件的确就像墓碑一样记录了死亡了的进程的基本信息（例如进程的进程号，线程号），死亡的地址（在哪个地址上发生了 Crash），死亡时的现场是什么样的（记录了一系列的堆栈调用信息）等等。<br>注意：有些Android设备默认是不会产生墓碑文件的，需要手动创建文件/data/tombstones/tombstone_00</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /data/tombstones/</span><br><span class="line"><span class="built_in">touch</span> /data/tombstones/tombstone_00</span><br><span class="line"><span class="built_in">chmod</span> 777 /data/tombstones/tombstone_00</span><br></pre></td></tr></table></figure>

<p>系统发生一次段错误后，会把堆栈信息写入tombstone_0x文件，tombstone_0x文件需要从0~9循环使用，需要通过文件更新时间确认最新的一次段错误是哪个墓碑文件。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.cnblogs.com/CoderTian/p/5980426.html">Android Tombstone 分析</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android调试</tag>
      </tags>
  </entry>
  <entry>
    <title>代码调试之打印堆栈</title>
    <url>/posts/41513.html</url>
    <content><![CDATA[<h2 id="java代码中打印堆栈"><a href="#java代码中打印堆栈" class="headerlink" title="java代码中打印堆栈"></a>java代码中打印堆栈</h2><p>Java代码打印堆栈比较简单， 堆栈信息获取和输出，都可以通过Throwable类的方法实现。目前通用的做法是在java进程出现需要注意的异常时，打印堆栈，然后再决定退出或挽救。通常的方法是使用exception的printStackTrace()方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以只打印堆栈不退出，这样就比较方便分析代码的动态运行情况。Java代码中插入堆栈打印的方法如下  </p>
<p>推荐   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line">Log.d(TAG, android.util.Log.getStackTraceString(<span class="keyword">new</span> <span class="title class_">java</span>.lang.Throwable()));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Red Black Tree</title>
    <url>/posts/2588.html</url>
    <content><![CDATA[<h2 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h2><p>红黑树是一种自平衡二进制搜索树。每个节点存储一个代表颜色的标记位，用于在数的插入和删除期间保持数的近似平衡。红黑树是一个特殊的二叉树，用于组织可以进行比较的数据元素。</p>
<h2 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点"></a>红黑树的特点</h2><ol>
<li>每个节点都必须是红色或者黑色；</li>
<li>跟节点是黑色。这条规则有时会被忽略，因为跟节点始终可以从红色变为黑色，但反过来就不一定成立。该规则对数据分析影响很小；</li>
<li>所有叶子节点（包括空节点）都是黑色；</li>
<li>红色节点的子节点都是黑色；</li>
<li>从给定节点到其任何后代NIL节点的每条路径都经过相同数量的黑色节点；</li>
</ol>
<p>参考链接：</p>
<ul>
<li><a href="https://xlinux.nist.gov/dads/HTML/redblack.html">https://xlinux.nist.gov/dads/HTML/redblack.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</a></li>
<li><a href="https://medium.com/@kevinsmavani007/red-black-tree-47e3249cf17">https://medium.com/@kevinsmavani007/red-black-tree-47e3249cf17</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>算法复杂度</title>
    <url>/posts/30614.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Mixin模式</title>
    <url>/posts/52098.html</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Mixin">Mixin wiki</a></p>
<p><a href="http://www.cnblogs.com/xybaby/p/6484262.html">Mixin模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>软件设计原则</title>
    <url>/posts/56256.html</url>
    <content><![CDATA[<h3 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a><a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a></h3><hr>
<h4 id="Single-responsibility-principle-单一职责"><a href="#Single-responsibility-principle-单一职责" class="headerlink" title="Single responsibility principle 单一职责"></a><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single responsibility principle</a> 单一职责</h4><p>The single responsibility principle is a computer programming principle that states that every module, class, or function should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class, module or function. All its services should be narrowly aligned with that responsibility. Robert C. Martin expresses the principle as, “A class should have only one reason to change,” although, because of confusion around the word “reason” he more recently stated “This principle is about people.(Actor)”</p>
<p>Martin defines a responsibility as a reason to change, and concludes that a class or module should have one, and only one, reason to be changed (i.e. rewritten). As an example, consider a module that compiles and prints a report. Imagine such a module can be changed for two reasons. First, the content of the report could change. Second, the format of the report could change. These two things change for very different causes; one substantive, and one cosmetic. The single responsibility principle says that these two aspects of the problem are really two separate responsibilities, and should therefore be in separate classes or modules. It would be a bad design to couple two things that change for different reasons at different times.</p>
<p>The reason it is important to keep a class focused on a single concern is that it makes the class more robust. Continuing with the foregoing example, if there is a change to the report compilation process, there is greater danger that the printing code will break if it is part of the same class.</p>
<h4 id="Open–closed-principle-开闭原则"><a href="#Open–closed-principle-开闭原则" class="headerlink" title="Open–closed principle 开闭原则"></a><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open–closed principle</a> 开闭原则</h4><p>Open/closed principle states “software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”; that is, such an entity can allow its behaviour to be extended without modifying its source code.</p>
<p>The name open/closed principle has been used in two ways. Both ways use generalizations (for instance, inheritance or delegate functions) to resolve the apparent dilemma, but the goals, techniques, and results are different.</p>
<h4 id="Liskov-substitution-principle-里式替换"><a href="#Liskov-substitution-principle-里式替换" class="headerlink" title="Liskov substitution principle 里式替换"></a><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a> 里式替换</h4><h4 id="Interface-segregation-principle-ISP"><a href="#Interface-segregation-principle-ISP" class="headerlink" title="Interface segregation principle (ISP)"></a><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface segregation principle (ISP)</a></h4><p>ISP states that no client should be forced to depend on methods it does not use. ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called role interfaces. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.</p>
<h4 id="Dependency-inversion-principle"><a href="#Dependency-inversion-principle" class="headerlink" title="Dependency inversion principle"></a><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency inversion principle</a></h4><p>In object-oriented design, the dependency inversion principle is a specific form of decoupling software modules. When following this principle, the conventional dependency relationships established from high-level, policy-setting modules to low-level, dependency modules are reversed, thus rendering high-level modules independent of the low-level module implementation details. The principle states:</p>
<ul>
<li>High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces).</li>
<li>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</li>
</ul>
<p>By dictating that both high-level and low-level objects must depend on the same abstraction, this design principle inverts the way some people may think about object-oriented programming.</p>
<p> Depend upon abstractions.  Do not depend upon concrete classes. P177</p>
<p> In conventional application architecture, lower-level components (e.g. Utility Layer) are designed to be consumed by higher-level components (e.g. Policy Layer) which enable increasingly complex systems to be built. In this composition, higher-level components depend directly upon lower-level components to achieve some task. This dependency upon lower-level components limits the reuse opportunities of the higher-level components.The goal of the dependency inversion pattern is to avoid this highly coupled distribution with the mediation of an abstract layer, and to increase the re-usability of higher/policy layers.<br> <img src="/img/in-post/Traditional_Layers_Pattern.png" alt="Traditional_Layers_Pattern" title="Traditional Layers Pattern"></p>
<p> With the addition of an abstract layer, both high- and lower-level layers reduce the traditional dependencies from top to bottom. Nevertheless, the “inversion” concept does not mean that lower-level layers depend on higher-level layers. Both layers should depend on abstractions that draw the behavior needed by higher-level layers.<br> <img src="/img/in-post/DIPLayersPattern.png" alt="DIPLayersPattern" title="DIP Layers Pattern"></p>
<p> In a direct application of dependency inversion, the abstracts are owned by the upper/policy layers. This architecture groups the higher/policy components and the abstractions that define lower services together in the same package. The lower-level layers are created by inheritance/implementation of these abstract classes or interfaces.[1]</p>
<p>The inversion of the dependencies and ownership encourages the re-usability of the higher/policy layers. Upper layers could use other implementations of the lower services. When the lower-level layer components are closed or when the application requires the reuse of existing services, it is common that an Adapter mediates between the services and the abstractions.</p>
<h3 id="GRASP"><a href="#GRASP" class="headerlink" title="GRASP"></a><a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)">GRASP</a></h3><hr>
<p>General Responsibility Assignment Software Patterns (or Principles), abbreviated GRASP, consist of guidelines for assigning responsibility to classes and objects in object-oriented design. It is not related to the <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> design principle.</p>
<p>The different patterns and principles used in GRASP are <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller">controller</a>, <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Creator">creator</a>, <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Indirection">indirection</a>, <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Information_expert">information expert</a>, <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#High_cohesion">high cohesion</a>, <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Low_coupling">low coupling</a>, <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Polymorphism">polymorphism</a>, <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Protected_variations">protected variations</a>, and <a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Pure_fabrication">pure fabrication</a>. All these patterns answer some software problems, and these problems are common to almost every software development project. These techniques have not been invented to create new ways of working, but to better document and standardize old, tried-and-tested programming principles in object-oriented design.</p>
<h3 id="Separation-of-Concerns-关注点分离"><a href="#Separation-of-Concerns-关注点分离" class="headerlink" title="Separation of Concerns 关注点分离"></a><a href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns</a> 关注点分离</h3><hr>
<h3 id="Don’t-Repeat-Yourself"><a href="#Don’t-Repeat-Yourself" class="headerlink" title="Don’t Repeat Yourself"></a><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t Repeat Yourself</a></h3><hr>
<h3 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a><a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a></h3><hr>
<p>Inversion of control is sometimes facetiously referred to as the “Hollywood Principle: Don’t call us, we’ll call you”.<br>(The Hollywood Principle: Don’t call us, we’ll call you. 《Head First design patterns - ora 2004》 P334)</p>
<p><a href="https://martinfowler.com/bliki/InversionOfControl.html">Inversion of Control</a> by Martin Fowler</p>
<h3 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a></h3><hr>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter点击事件处理机制</title>
    <url>/posts/be1f8948.html</url>
    <content><![CDATA[<p>一次点击一般会有先后两个事件：PointerDownEvent和PointerUpEvent，分别表示按下down和抬起up（如果手指发生了滑动，还会有PointerMoveEvent事件）。本文分别分析按下和抬起两个事件的处理流程。</p>
<p>备注：本文以<code>GestureDetector</code>为示例进行点击事件处理流程的分析，基于Flutter 2.5.3。</p>
<h2 id="PointerDownEvent（按下）事件的处理流程"><a href="#PointerDownEvent（按下）事件的处理流程" class="headerlink" title="PointerDownEvent（按下）事件的处理流程"></a>PointerDownEvent（按下）事件的处理流程</h2><img src="\assert\puml\5a9d9d914cd4ef5ee7aec6487a10c27faf53568d62f0babc040d9a8756a7ffab.svg"/>

<h3 id="命中测试-hitTest"><a href="#命中测试-hitTest" class="headerlink" title="命中测试 hitTest"></a>命中测试 hitTest</h3><p>一次点击事件发生后，会首先进行命中测试。</p>
<p>命中测试hitTest在PointerDownEvent事件的处理流程中进行，从<code>RendererBinding.hitTest</code>开始，然后调用<code>GestureBinding.hitTest</code>，再调用<code>RenderView.hitTest</code>，RenderView会直接调用子节点的hitTest。（其实RendererBinding和GestureBinding都是对应一个WidgetsFlutterBinding类实例，属于继承关系。）RenderView的子节点是RenderBox的子类，从此之后，参与命中测试的组件都是RenderBox或者其子类。hitTest的默认处理逻辑在RenderBox中实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderBox</span> <span class="keyword">extends</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> hitTest(BoxHitTestResult result, &#123; <span class="keyword">required</span> Offset position &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_size!.contains(position)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123;</span><br><span class="line">        result.add(BoxHitTestEntry(<span class="keyword">this</span>, position));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理逻辑解读：</p>
<ul>
<li>先判断点击的坐标是否在控件范围内，如果在，则表示命中测试，否则就返回，不会再对子节点进行命中测试；</li>
<li>执行hitTestChildren判断子节点是否命中测试，如果命中就加入到HitTestResult中；</li>
<li>最后把自己加入到HitTestResult中。</li>
</ul>
<p>因此，hitTest采用深度优先遍历算法，先将最内部的子节点加入到HitTestResult中，最后再加入自己。命中测试会把点击坐标位置的控件都加入到命中列表中，并没有区分是否是可点击控件。</p>
<h3 id="hitTestChildren"><a href="#hitTestChildren" class="headerlink" title="hitTestChildren"></a>hitTestChildren</h3><p>RenderBox的hitTestChildren默认实现始终返回false，RenderBox子类需要自己来实现。对于RenderProxyBox，方法在<code>RenderProxyBoxMixin</code>中实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">bool</span> hitTestChildren(BoxHitTestResult result, &#123; <span class="keyword">required</span> Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> child?.hitTest(result, position: position) ?? <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解读：</p>
<p><code>hitTestChildren</code>会直接调用子节点的hitTest，如果没有子节点就返回false，表示节点没有命中测试。</p>
<p>对于具有多个子节点的RenderObject，比如Column等，处理逻辑在<code>RenderCustomMultiChildLayoutBox.hitTestChildren</code>中，会使用倒序的方式调用child的hitTest。很多继承自RenderObject的子类都有自己的实现，比如RenderCustomPaint、RenderFittedBox、RenderFlex等。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> defaultHitTestChildren(BoxHitTestResult result, &#123; <span class="keyword">required</span> Offset position &#125;) &#123;</span><br><span class="line">  ChildType? child = lastChild;  <span class="comment">//采用倒序，优先命中测试lastChild</span></span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ParentDataType childParentData = child.parentData! <span class="keyword">as</span> ParentDataType;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isHit = result.addWithPaintOffset(</span><br><span class="line">      offset: childParentData.offset,</span><br><span class="line">      position: position,</span><br><span class="line">      hitTest: (BoxHitTestResult result, Offset? transformed) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(transformed == position - childParentData.offset);</span><br><span class="line">        <span class="keyword">return</span> child!.hitTest(result, position: transformed!);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (isHit)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    child = childParentData.previousSibling;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点击事件分发"><a href="#点击事件分发" class="headerlink" title="点击事件分发"></a>点击事件分发</h3><p>命中测试完成后，就会执行down事件的分发，事件会分发给命中测试列表中的各个<code>RenderBox</code>，执行<code>RenderBox.handleEvent</code>函数。默认的handleEvent实现是空实现。GestureDetector会通过<code>RenderPointerListener</code>来处理按键。具体流程可以参考上面的时序图。</p>
<p>经过事件分发后，只有真正的点击事件处理组件才会被加入到事件路由和事件竞技场中。</p>
<h2 id="PointerUpEvent（抬起）事件处理流程"><a href="#PointerUpEvent（抬起）事件处理流程" class="headerlink" title="PointerUpEvent（抬起）事件处理流程"></a>PointerUpEvent（抬起）事件处理流程</h2><img src="\assert\puml\2467cecbafac97b0d6293bea3b126746020318693deabfba17df2bfe36aaa545.svg"/>

<p><code>PointerUpEvent</code>表示一次点击事件周期的结束，因此除了触发控件的点击事件回调外，还做了一些清理工作，比如删除事件路由，执行reset等。还有一项很重要的工作就是处理竞技逻辑，当点击范围存在多个可点击控件时，通过竞技逻辑来决定哪个空间来处理本次点击事件。</p>
<p>下面是竞技场的代码实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GestureArenaManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> sweep(<span class="built_in">int</span> pointer) &#123;</span><br><span class="line">    <span class="keyword">final</span> _GestureArena? state = _arenas[pointer];  <span class="comment">//根据pointer id获取竞技场</span></span><br><span class="line">    ...</span><br><span class="line">    _arenas.remove(pointer);  <span class="comment">//删除竞技场</span></span><br><span class="line">    <span class="keyword">if</span> (state.members.isNotEmpty) &#123;</span><br><span class="line">      <span class="comment">// First member wins.</span></span><br><span class="line">      state.members.first.acceptGesture(pointer);</span><br><span class="line">      <span class="comment">// Give all the other members the bad news.</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; state.members.length; i++)</span><br><span class="line">        state.members[i].rejectGesture(pointer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>竞技逻辑的代码实现非常简单，如果某次点击存在多个竞争者，则列表的第一个胜出，其他的都失败。所以，竞技的逻辑依赖竞争者的加入顺序，第一个加入的就会赢的胜利。这个顺序就是命中测试的顺序，可以参考hitTest一节的分析。</p>
<h2 id="GestureDetector相关的类图"><a href="#GestureDetector相关的类图" class="headerlink" title="GestureDetector相关的类图"></a>GestureDetector相关的类图</h2><img src="\assert\puml\615b819b7090396376282a880bc477825dd9aa0638d30e6930f778dda9d9a3ff.svg"/>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.flutterchina.club/chapter8/hittest.html#_8-3-1-flutter-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">《Flutter实战·第二版》 8.3 Flutter事件机制</a><br><a href="https://cloud.tencent.com/developer/news/767886">深入理解Flutter手势系统</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/posts/ca4438af.html</url>
    <content><![CDATA[<p>HashMap存储结构采用数组+链表<small>（java8以后当链表长度超过8后采用红黑树来存储）</small>，当存储数据时会先计算key的哈希值，然后使用哈希值计算数组指针，如果数组指针位置已经存在数据，且key不相同，就会采用链表形式存储数据。存储结构如下图：</p>
<p><img src="/images/HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.drawio.svg" alt="HashMap存储结构"></p>
<p>在jdk1.8中HashMap引入了红黑树，当链表中的元素达到阈值后，并且数组长度大于64，就会将链表转换为红黑树。引入红黑树的主要目的是解决哈希冲突导致的链化严重的问题。</p>
<h2 id="哈希值与数组指针"><a href="#哈希值与数组指针" class="headerlink" title="哈希值与数组指针"></a>哈希值与数组指针</h2><p>哈希值计算方法：获取key的hashCode，然后hashCode右移16位，最后将两者进行异或运算。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么没有直接使用key.hashCode()的值呢？这是因为数组长度都是2的幕，比如默认数组长度16=$2^4$，即<code>1&lt;&lt;4</code>，长度掩码就是<code>15=16-1</code>，二进制掩码就是<code>1111</code>。hash与掩码进行按位与运算后得到数组指针，相当于只取了hash的低4位，高位没有用到，增加了指针冲突的概率。因此将hashCode进行右移16位，再进行异或运算，这样做就是在运算中同时使用了高位和低位。</p>
<p>HashMap是通过数组来存储元素。当通过key来后去元素值的时候，首先计算出key的哈希值，然后通过哈希值来计算得到数组坐标，看下put操作中如何计算数组坐标：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  <span class="comment">//从数组中取出node赋值给p</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，计算数组坐标的算法是：<code>(n - 1) &amp; hash</code>，其中<code>n</code>表示数组长度。所以坐标指针是hash和长度掩码进行与运算。</p>
<p>下图以<code>key=&quot;Hello&quot;</code>为例来说明计算过程：</p>
<p><img src="/images/HashMap_hashCode%E8%AE%A1%E7%AE%97.drawio.svg" alt="哈希值与数组指针计算"></p>
<h2 id="put插入数据"><a href="#put插入数据" class="headerlink" title="put插入数据"></a>put插入数据</h2><p><img src="/images/HashMap_put.drawio.svg" alt="HashMap插入数据"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//初始状态table为空，进行resize扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>); <span class="comment">//没有发生hash碰撞，数据存放到数组</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//发生了hash碰撞，或者存在相同的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">//存在相同的key，覆盖原值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//红黑树</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">//链表长度大于8尝试转换为红黑树</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>HashMap采用数组和链表的形式存储数据，即使不扩容理论上可以存储无限多的数据元素。那么为什么要进行扩容呢？HashMap的扩容实际上指得是数组的扩容，默认的数组长度是16，如果不进行扩容，后续数据都依赖链表存储，那么随着数据的增多，查找效率会越来越低，即复杂度是O(n)，而不是O(1)。扩容的依据是总数据量，包括所有数组、链表、红黑树中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//负载因子，默认0.75，即75%</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//扩容阈值 = 负载因子 * 容量</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//元素存放在数组中，初始值为null</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap的无参构造函数中将负载因子<code>loadFactor</code>变量设置为0.75。但是并没有设置扩容阈值或者容量，table数组初始值也是null。既然默认都是空的，那么看一下put方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//因为table初始值是null，所以肯定会走到resize()方法</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看样子会在resize方法中设置容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//初始状态，oldCap==0</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="comment">//终于用到默认容量了</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  <span class="comment">//计算扩容阈值</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    threshold = newThr;  <span class="comment">//将计算得到的扩容阈值赋值给threshold成员变量</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap]; <span class="comment">//创建元素数组然后赋值给table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义初始容量"><a href="#自定义初始容量" class="headerlink" title="自定义初始容量"></a>自定义初始容量</h2><p>通过下面的构造函数用户可以自定义初始容量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，HashMap不会完全按照用户指定容量来扩容，因为HashMap的容量必须是2的幕。所以，会通过<code>tableSizeFor</code>方法进行换算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如用户传入的是18，计算过程如下：</p>
<table>
<thead>
<tr>
<th>运算公式</th>
<th>二进制运算</th>
</tr>
</thead>
<tbody><tr>
<td>$n=18-1=17$</td>
<td></td>
</tr>
<tr>
<td>$n=17|(17&gt;&gt;&gt;1)=25$</td>
<td>$n=0b10001|0b01000=0b11001$</td>
</tr>
<tr>
<td>$n=25|(25&gt;&gt;&gt;2)=31$</td>
<td>$n=0b11001|0b00110=0b11111$</td>
</tr>
<tr>
<td>$n=31|(31&gt;&gt;&gt;3)=31$</td>
<td>$n=0b11111|0b00011=0b11111$</td>
</tr>
<tr>
<td>$n=31|(31&gt;&gt;&gt;4)=31$</td>
<td>$n=0b11111|0b00001=0b11111$</td>
</tr>
<tr>
<td>$n=31|(31&gt;&gt;&gt;5)=31$</td>
<td>$n=0b11111|0b00000=0b11111$</td>
</tr>
<tr>
<td>$n=31|(31&gt;&gt;&gt;6)=31$</td>
<td>$n=0b11111|0b00000=0b11111$</td>
</tr>
<tr>
<td>return $31+1$; //$32=2^5$</td>
<td></td>
</tr>
</tbody></table>
<p>相当于把18二进制的bit位全部赋值位1，然后再加一。$0b10010$ &rArr; $0b11111$ &rArr; $0b100000$。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/sihai12345/article/details/119156631">盘点 HashMap 源码中的那些优雅的设计！</a><br><a href="https://zhuanlan.zhihu.com/p/351298116">HashMap底层实现原理详解</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java CAS详解</title>
    <url>/posts/fd3db9c4.html</url>
    <content><![CDATA[<h2 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h2><p>CAS(Compare and swap)是并发编程中经常用到的一项技术。大体上讲，CAS算法会先使用期望值比较变量的实际值，如果相同，就使用目标值替换变量的值。如果不相同，就会重新读取期望值再次进行对比和替换。</p>
<p>CAS主要是为了解决共享资源被加锁后，线程从阻塞状态切换回运行态比较耗时的问题，CAS是在不阻塞线程的情况下达到资源互斥的目的。但是如果共享资源竞争比较激烈就不适合使用CAS了，CAS会导致很多线程一直在重试访问共享资源，造成CPU资源的浪费。另外，如果共享资源的操作比较耗时，也就不适合使用CAS，这种场景使用阻塞的资源锁会更合适。</p>
<h2 id="CAS源码分析"><a href="#CAS源码分析" class="headerlink" title="CAS源码分析"></a>CAS源码分析</h2><p>以AtomicInteger.getAndIncrement为例进行源码分析，下面代码来自<a href="https://hg.openjdk.org/jdk8/jdk8/jdk/">openJdk8源码</a>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取value变量地址</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value; <span class="comment">//volatile类型的变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AtomicInteger.getAndIncrement</code>通过<code>Unsafe.getAndAddInt</code>方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Unsafe.java **/</span></span><br><span class="line">    <span class="comment">//native方法，通过jni来调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>getAndAddInt</code>函数中，首先获取到期望值<code>v</code>，<code>v + delta</code>是目标值。然后进入compareAndSwapInt函数，compareAndSwapInt会首先对比实际值与期望值是否相同，如果相同就替换并返回true，while循环退出。如果不相同，compareAndSwapInt就返回false，继续执行while循环读取期望值，然后再次进行对比替换的步骤。</p>
<p><code>compareAndSwapInt</code>是native函数，源码在hotspot的<code>unsafe.cpp</code>文件中，在现在的系统中对比替换操作都是通过硬件机制来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p><code>Atomic::cmpxchg</code>通过内嵌汇编语言来实现，在不同的硬件上有不同的实现。下面代码是windows x86平台的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** [hotspot]\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp **/</span></span><br><span class="line"><span class="keyword">inline</span> jint     <span class="title function_">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="type">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest   <span class="comment">//变量地址放入数据寄存器</span></span><br><span class="line">    mov ecx, exchange_value  <span class="comment">//目标值放入计数寄存器</span></span><br><span class="line">    mov eax, compare_value  <span class="comment">//期望值放入累加器寄存器</span></span><br><span class="line">    LOCK_IF_MP(mp)   <span class="comment">//根据当前cpu是否是多核进行加锁</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中<code>cmpxchg</code>汇编指令的含义是对比累加器(al/ax/eax/rax)和[edx]中的值（<small><em>[edx]表示变量地址，本质上就是一个指针</em></small>），如果值相同就把ecx寄存器的值放入[edx]中，否则就会把[edx]指向的变量值加载到累加器中。</p>
<p><em>备注：AtomicInteger和Unsafe代码来之openJdk8：<a href="https://hg.openjdk.org/jdk8/jdk8/jdk">https://hg.openjdk.org/jdk8/jdk8/jdk</a>。unsafe.cpp代码在openjdk8 hotspot源码中：<a href="https://hg.openjdk.org/jdk8/jdk8/hotspot">https://hg.openjdk.org/jdk8/jdk8/hotspot</a></em></p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>CAS会有ABA的问题，AtomicInteger对于<code>getAndIncrement</code>这种只进行加运算的操作不会存在ABA问题。但如果还有减运算就会存在ABA问题。java也提供了<code>AtomicStampedReference</code>类来解决ABA问题。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://jenkov.com/tutorials/java-concurrency/compare-and-swap.html">Compare and Swap</a><br><a href="https://www.felixcloutier.com/x86/cmpxchg">CMPXCHG — Compare and Exchange</a><br><a href="https://zhuanlan.zhihu.com/p/635463928">从汇编底层全面解析 CAS 的来龙去脉</a><br><a href="https://zhuanlan.zhihu.com/p/60106083">LongAdder解析</a><br><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）</a><br><a href="https://zhuanlan.zhihu.com/p/101430930">并发编程的灵魂：CAS机制详解</a><br><a href="https://zhuanlan.zhihu.com/p/29227508">SynchronousQueue实现原理</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解原理</title>
    <url>/posts/f45b8d80.html</url>
    <content><![CDATA[<p>注解的使用场景可以分为两种：一）编译期间通过注解解析器处理；2）运行期间反射使用；</p>
<h2 id="注解保留策略"><a href="#注解保留策略" class="headerlink" title="注解保留策略"></a>注解保留策略</h2><ul>
<li><code>RetentionPolicy.SOURCE</code> : 编译期可见，但不会写入到.class文件；</li>
<li><code>RetentionPolicy#CLASS</code> : 会写入到.class文件中，但是会被JVM忽略（这是默认策略）；</li>
<li><code>RetentionPolicy#RUNTIME</code> ：注解会被写入到.class文件中，并且JVM运行期间也可见，可以通过反射放射获取到；</li>
</ul>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyClass &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyRuntime1 &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyRuntime2 &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MySource &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译完成后，每个注解都会生成自己的.class文件，看一下MyClass这个注解的.class文件的内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ javap -p -v me/demo/MyClass.class</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Duser.language=en -Dfile.encoding=UTF-8</span><br><span class="line">Classfile /F:/demo/JavaDemo/out/production/JavaDemo/me/demo/MyClass.class</span><br><span class="line">  Last modified Sep 21, 2023; size 472 bytes</span><br><span class="line">  MD5 checksum cb49d6b6a5ed7ab9c2b85d731996fb5f</span><br><span class="line">  Compiled from &quot;MyClass.java&quot;</span><br><span class="line">public interface me.demo.MyClass extends java.lang.annotation.Annotation</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 61</span><br><span class="line">  flags: (0x2601) ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT, ACC_ANNOTATION</span><br><span class="line">  this_class: #1                          // me/demo/MyClass</span><br><span class="line">  super_class: #3                         // java/lang/Object</span><br><span class="line">  interfaces: 1, fields: 0, methods: 1, attributes: 2</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #2             // me/demo/MyClass</span><br><span class="line">   #2 = Utf8               me/demo/MyClass</span><br><span class="line">   #3 = Class              #4             // java/lang/Object</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Class              #6             // java/lang/annotation/Annotation</span><br><span class="line">   #6 = Utf8               java/lang/annotation/Annotation</span><br><span class="line">   #7 = Utf8               name</span><br><span class="line">   #8 = Utf8               ()Ljava/lang/String;</span><br><span class="line">   #9 = Utf8               SourceFile</span><br><span class="line">  #10 = Utf8               MyClass.java</span><br><span class="line">  #11 = Utf8               RuntimeVisibleAnnotations</span><br><span class="line">  #12 = Utf8               Ljava/lang/annotation/Target;</span><br><span class="line">  #13 = Utf8               value</span><br><span class="line">  #14 = Utf8               Ljava/lang/annotation/ElementType;</span><br><span class="line">  #15 = Utf8               TYPE</span><br><span class="line">  #16 = Utf8               METHOD</span><br><span class="line">  #17 = Utf8               FIELD</span><br><span class="line">  #18 = Utf8               CONSTRUCTOR</span><br><span class="line">  #19 = Utf8               PARAMETER</span><br><span class="line">  #20 = Utf8               Ljava/lang/annotation/Retention;</span><br><span class="line">  #21 = Utf8               Ljava/lang/annotation/RetentionPolicy;</span><br><span class="line">  #22 = Utf8               CLASS</span><br><span class="line">&#123;</span><br><span class="line">  public abstract java.lang.String name();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyClass.java&quot;</span><br><span class="line">RuntimeVisibleAnnotations:</span><br><span class="line">  0: #12(#13=[e#14.#15,e#14.#16,e#14.#17,e#14.#18,e#14.#19])</span><br><span class="line">    java.lang.annotation.Target(</span><br><span class="line">      value=[Ljava/lang/annotation/ElementType;.TYPE,Ljava/lang/annotation/ElementType;.METHOD,Ljava/lang/annotation/ElementType;.FIELD,Ljava/lang/annotation/ElementType;.CONSTRUCTOR,Ljava/lang/annotation/ElementType;.PARAMETER]</span><br><span class="line">    )</span><br><span class="line">  1: #20(#13=e#21.#22)</span><br><span class="line">    java.lang.annotation.Retention(</span><br><span class="line">      value=Ljava/lang/annotation/RetentionPolicy;.CLASS</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>从MyClass.class文件第7行代码<code>public interface MyClass extends java.lang.annotation.Annotation</code>可以看出来MyClass实际上是继承自Annotation的接口类。这一点从<code>java.lang.Class#getAnnotation</code>这个方法也可以看出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java/lang/Class.java</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(annotationClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (A) annotationData().annotations.get(annotationClass);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MySource()</span></span><br><span class="line"><span class="meta">@MyClass(name = &quot;my_class&quot;)</span></span><br><span class="line"><span class="meta">@MyRuntime1(id = 16)</span></span><br><span class="line"><span class="meta">@MyRuntime2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyClass(name = &quot;my class constructor&quot;)</span></span><br><span class="line">    <span class="meta">@MyRuntime1(id = 0)</span></span><br><span class="line">    TestAnnotation() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">mDefault</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyClass(name = &quot;my class field&quot;)</span></span><br><span class="line">    <span class="meta">@MyRuntime1(id = 1)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">mValue</span> <span class="operator">=</span> mDefault;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyClass(name = &quot;my class method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyRuntime2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@MyClass(name = &quot;my class param&quot;)</span> String value</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        mValue = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译完成后我们使用javap命令看一下TestAnnotation.class的格式：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ javap -p -v me/demo/TestAnnotation.class</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Duser.language=en -Dfile.encoding=UTF-8</span><br><span class="line">Classfile /F:/demo/JavaDemo/out/production/JavaDemo/me/demo/TestAnnotation.class</span><br><span class="line">  Last modified Sep 21, 2023; size 1062 bytes</span><br><span class="line">  MD5 checksum 8ae94cb155dd4d060085e7c1fef200c5</span><br><span class="line">  Compiled from &quot;TestAnnotation.java&quot;</span><br><span class="line">public class me.demo.TestAnnotation</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 61</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #10                         // me/demo/TestAnnotation</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 2, methods: 3, attributes: 3</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = String             #8             // Hello</span><br><span class="line">   #8 = Utf8               Hello</span><br><span class="line">   #9 = Fieldref           #10.#11        // me/demo/TestAnnotation.mDefault:Ljava/lang/String;</span><br><span class="line">  #10 = Class              #12            // me/demo/TestAnnotation</span><br><span class="line">  #11 = NameAndType        #13:#14        // mDefault:Ljava/lang/String;</span><br><span class="line">  #12 = Utf8               me/demo/TestAnnotation</span><br><span class="line">  #13 = Utf8               mDefault</span><br><span class="line">  #14 = Utf8               Ljava/lang/String;</span><br><span class="line">  #15 = Fieldref           #10.#16        // me/demo/TestAnnotation.mValue:Ljava/lang/String;</span><br><span class="line">  #16 = NameAndType        #17:#14        // mValue:Ljava/lang/String;</span><br><span class="line">  #17 = Utf8               mValue</span><br><span class="line">  #18 = Utf8               ConstantValue</span><br><span class="line">  #19 = Utf8               RuntimeVisibleAnnotations</span><br><span class="line">  #20 = Utf8               Lme/demo/MyRuntime1;</span><br><span class="line">  #21 = Utf8               id</span><br><span class="line">  #22 = Integer            1</span><br><span class="line">  #23 = Utf8               RuntimeInvisibleAnnotations</span><br><span class="line">  #24 = Utf8               Lme/demo/MyClass;</span><br><span class="line">  #25 = Utf8               name</span><br><span class="line">  #26 = Utf8               my class field</span><br><span class="line">  #27 = Utf8               Code</span><br><span class="line">  #28 = Utf8               LineNumberTable</span><br><span class="line">  #29 = Utf8               LocalVariableTable</span><br><span class="line">  #30 = Utf8               this</span><br><span class="line">  #31 = Utf8               Lme/demo/TestAnnotation;</span><br><span class="line">  #32 = Integer            0</span><br><span class="line">  #33 = Utf8               my class constructor</span><br><span class="line">  #34 = Utf8               getValue</span><br><span class="line">  #35 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #36 = Utf8               my class method</span><br><span class="line">  #37 = Utf8               setValue</span><br><span class="line">  #38 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #39 = Utf8               value</span><br><span class="line">  #40 = Utf8               Lme/demo/MyRuntime2;</span><br><span class="line">  #41 = Utf8               RuntimeInvisibleParameterAnnotations</span><br><span class="line">  #42 = Utf8               my class param</span><br><span class="line">  #43 = Utf8               SourceFile</span><br><span class="line">  #44 = Utf8               TestAnnotation.java</span><br><span class="line">  #45 = Integer            16</span><br><span class="line">  #46 = Utf8               my_class</span><br><span class="line">&#123;</span><br><span class="line">  private final java.lang.String mDefault;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: (0x0012) ACC_PRIVATE, ACC_FINAL</span><br><span class="line">    ConstantValue: String Hello</span><br><span class="line"></span><br><span class="line">  private java.lang.String mValue;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: (0x0002) ACC_PRIVATE</span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      0: #20(#21=I#22)</span><br><span class="line">        me.demo.MyRuntime1(</span><br><span class="line">          id=1</span><br><span class="line">        )</span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      0: #24(#25=s#26)</span><br><span class="line">        me.demo.MyClass(</span><br><span class="line">          name=&quot;my class field&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">  me.demo.TestAnnotation();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0000)</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: ldc           #7                  // String Hello</span><br><span class="line">         7: putfield      #9                  // Field mDefault:Ljava/lang/String;</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: ldc           #7                  // String Hello</span><br><span class="line">        13: putfield      #15                 // Field mValue:Ljava/lang/String;</span><br><span class="line">        16: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">        line 14: 4</span><br><span class="line">        line 16: 10</span><br><span class="line">        line 12: 16</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      17     0  this   Lme/demo/TestAnnotation;</span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      0: #20(#21=I#32)</span><br><span class="line">        me.demo.MyRuntime1(</span><br><span class="line">          id=0</span><br><span class="line">        )</span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      0: #24(#25=s#33)</span><br><span class="line">        me.demo.MyClass(</span><br><span class="line">          name=&quot;my class constructor&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">  public java.lang.String getValue();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #15                 // Field mValue:Ljava/lang/String;</span><br><span class="line">         4: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 22: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lme/demo/TestAnnotation;</span><br><span class="line">    RuntimeInvisibleAnnotations:</span><br><span class="line">      0: #24(#25=s#36)</span><br><span class="line">        me.demo.MyClass(</span><br><span class="line">          name=&quot;my class method&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">  public void setValue(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: putfield      #15                 // Field mValue:Ljava/lang/String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 29: 0</span><br><span class="line">        line 30: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Lme/demo/TestAnnotation;</span><br><span class="line">            0       6     1 value   Ljava/lang/String;</span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      0: #40()</span><br><span class="line">        me.demo.MyRuntime2</span><br><span class="line">    RuntimeInvisibleParameterAnnotations:</span><br><span class="line">      parameter 0:</span><br><span class="line">        0: #24(#25=s#42)</span><br><span class="line">          me.demo.MyClass(</span><br><span class="line">            name=&quot;my class param&quot;</span><br><span class="line">          )</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;TestAnnotation.java&quot;</span><br><span class="line">RuntimeVisibleAnnotations:</span><br><span class="line">  0: #20(#21=I#45)</span><br><span class="line">    me.demo.MyRuntime1(</span><br><span class="line">      id=16</span><br><span class="line">    )</span><br><span class="line">  1: #40()</span><br><span class="line">    me.demo.MyRuntime2</span><br><span class="line">RuntimeInvisibleAnnotations:</span><br><span class="line">  0: #24(#25=s#46)</span><br><span class="line">    me.demo.MyClass(</span><br><span class="line">      name=&quot;my_class&quot;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<ul>
<li>保留策略是<code>RetentionPolicy.CLASS</code>的注解会保存在<code>RuntimeInvisibleAnnotations</code>列表中；</li>
<li>保留策略是<code>RetentionPolicy.RUNTIME</code>的注解类会被放在<code>RuntimeVisibleAnnotations</code>列表中；</li>
<li>保留策略是<code>RetentionPolicy.SOURCE</code>的注解不在TestAnnotation.class中；</li>
<li>方法参数的注解则保存在<code>RuntimeInvisibleParameterAnnotations</code>列表中；</li>
</ul>
<h2 id="Runtime时注解类真身"><a href="#Runtime时注解类真身" class="headerlink" title="Runtime时注解类真身"></a>Runtime时注解类真身</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;TestAnnotation&gt; testCls = TestAnnotation.class;</span><br><span class="line">        System.out.println(testCls.getAnnotation(MyRuntime1.class).getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出结果是：<code>class jdk.proxy2.$Proxy1</code>，而不是MyRuntime1。这是为什么呢？实际上，当我们反射获取注解时，虚拟机会通过动态代理的方式生成了一个代理类返回。通过设置虚拟机参数<code>-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true</code>，虚拟机会把生成的代理类保存为文件。</p>
<p>进入.class文件的生成目录，使用如下命令运行main函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true -Dfile.encoding=UTF-8 -classpath ./ Main</span><br></pre></td></tr></table></figure>

<p>执行完上述命令后，在当前目录的<code>./jdk/proxy2/</code>目录下就可以找到<code>$Proxy1.class</code>文件。</p>
<p>另外一种简单的方式就是在java main函数最前面（只要在执行反射获取注解之前就行）添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>IDEA运行后会在工程主目录下的<code>jdk/proxy2/</code>文件夹中保存动态代理类。通过IDEA打开文件后可以看到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy1</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">MyRuntime1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method m4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy1(InvocationHandler var1) &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title function_">annotationType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Class)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m4, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;me.demo.MyRuntime1&quot;</span>).getMethod(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;me.demo.MyRuntime1&quot;</span>).getMethod(<span class="string">&quot;annotationType&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MethodHandles.Lookup <span class="title function_">proxyClassLookup</span><span class="params">(MethodHandles.Lookup var0)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="keyword">if</span> (var0.lookupClass() == Proxy.class &amp;&amp; var0.hasFullPrivilegeAccess()) &#123;</span><br><span class="line">            <span class="keyword">return</span> MethodHandles.lookup();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessException</span>(var0.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解类反射源码分析"><a href="#注解类反射源码分析" class="headerlink" title="注解类反射源码分析"></a>注解类反射源码分析</h2><p>Class/Method/Field都有自己的反射获取注解的接口，如下：<code>java.lang.Class#getAnnotation</code> <code>java.lang.reflect.Method#getAnnotation</code> <code>java.lang.reflect.Field#getAnnotation</code>。注意：当通过<code>java.lang.Class#getAnnotation</code>来获取Class的注解时，只能获取Class本身的注解，而不能获取到Class中方法和成员变量的注解。反射获取注解实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">testCls.getAnnotation(MyRuntime1.class);</span><br><span class="line">testCls.getMethod(<span class="string">&quot;setValue&quot;</span>, String.class).getAnnotation(MyRuntime1.class);</span><br><span class="line">testCls.getField(<span class="string">&quot;mValue&quot;</span>).getAnnotation(MyRuntime1.class);</span><br></pre></td></tr></table></figure>

<p>当调用<code>java.lang.Class#getAnnotation(Class&lt;A&gt; annotationClass)</code>方法反射获取注解类时，会把这个类本身的注解全部进行解析，然后生成对应的动态代理类，注册到map列表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java/lang/Class.java</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(annotationClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (A) annotationData().annotations.get(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AnnotationData <span class="title function_">annotationData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// retry loop</span></span><br><span class="line">            <span class="type">AnnotationData</span> <span class="variable">annotationData</span> <span class="operator">=</span> <span class="built_in">this</span>.annotationData;</span><br><span class="line">            <span class="type">int</span> <span class="variable">classRedefinedCount</span> <span class="operator">=</span> <span class="built_in">this</span>.classRedefinedCount;</span><br><span class="line">            <span class="keyword">if</span> (annotationData != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                annotationData.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">                <span class="keyword">return</span> annotationData;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// null or stale annotationData -&gt; optimistically create new instance</span></span><br><span class="line">            <span class="type">AnnotationData</span> <span class="variable">newAnnotationData</span> <span class="operator">=</span> createAnnotationData(classRedefinedCount);</span><br><span class="line">            <span class="comment">// try to install it</span></span><br><span class="line">            <span class="keyword">if</span> (Atomic.casAnnotationData(<span class="built_in">this</span>, annotationData, newAnnotationData)) &#123;</span><br><span class="line">                <span class="comment">// successfully installed new AnnotationData</span></span><br><span class="line">                <span class="keyword">return</span> newAnnotationData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/yangming1996/p/9295168.html">JAVA 注解的基本原理</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java float和double存储结构</title>
    <url>/posts/2230f1f1.html</url>
    <content><![CDATA[<p><img src="/images/Java%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.drawio.svg" alt="Java浮点数存储结构"></p>
<h2 id="浮点数转换二进制"><a href="#浮点数转换二进制" class="headerlink" title="浮点数转换二进制"></a>浮点数转换二进制</h2><p>以<code>18.725</code>为例进行说明。</p>
<p><strong>整数部分转二进制</strong>：除2取余法。整数部分除以2取余数，商取整继续除以2取余数，直到商为0。</p>
<table>
<thead>
<tr>
<th>整数除法</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody><tr>
<td>$18/2$</td>
<td>9</td>
<td>0</td>
</tr>
<tr>
<td>$9/2$</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>$4/2$</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>$2/2$</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>$1/2$</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>18转换为二进制就是<code>10010</code>，上面表格中余数的倒序。</p>
<p><strong>小数部分转二进制</strong>：乘2取整法。小数部分乘以2，取整数部分，剩下的小数部分继续乘以2取整数部分，直到结果为0。如果永远不为零，则到达期望的精度后终止运算。</p>
<table>
<thead>
<tr>
<th>乘法公式</th>
<th>小数部分</th>
<th>整数部分</th>
</tr>
</thead>
<tbody><tr>
<td>$0.725*2=1.45$</td>
<td>0.45</td>
<td>1</td>
</tr>
<tr>
<td>$0.45*2=0.9$</td>
<td>0.9</td>
<td>0</td>
</tr>
<tr>
<td>$0.9*2=1.8$</td>
<td>0.8</td>
<td>1</td>
</tr>
<tr>
<td>$0.8*2=1.6$</td>
<td>0.6</td>
<td>1</td>
</tr>
<tr>
<td>$0.6*2=1.2$</td>
<td>0.2</td>
<td>1</td>
</tr>
<tr>
<td>$0.2*2=0.4$</td>
<td>0.4</td>
<td>0</td>
</tr>
<tr>
<td>$0.4*2=0.8$</td>
<td>0.8</td>
<td>0</td>
</tr>
<tr>
<td>$0.8*2=1.6$</td>
<td>0.6</td>
<td>1</td>
</tr>
<tr>
<td>$0.6*2=1.2$</td>
<td>0.2</td>
<td>1</td>
</tr>
<tr>
<td>$0.2*2=0.4$</td>
<td>0.4</td>
<td>0</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p>0.725的二进制数是<code>0.1011100110</code>（后面还有无限长，这里忽略）。所以18.725的二级制就是<code>10010.1011100110</code>。按照规定，二进制小数点左边只能有1为且固定为1，所以需要进行右移操作，得出结果是：$1.00101011100110*2^4$</p>
<ul>
<li>符号位：正数，符号位为0；</li>
<li>指数位：实际为4，按照规定要加上127（即指数最高位赋值为1），指数位存储的是131，二级制为<code>10000011</code>，。</li>
<li>底数位：取小数部分，即 <code>0.00101011100110</code>；</li>
</ul>
<p>为什么指数位要加上127呢？这是因为float类型指数位是8位，取值范围位-126~127，为了消除负数带来的实际计算上的影响（比如比较大小，加减法等），可以在实际存储的时候，给指数做一个简单的映射，加上一个偏移量，比如float的指数偏移量为 127，这样就不会有负数出现了。另外double类型是加上1024。</p>
<p>18.725存储的float二进制数据是：<code>0 10000011 00101011100110...</code>。</p>
<p>可以通过下面代码进行验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(Float.floatToRawIntBits(<span class="number">18.725f</span>)));</span><br><span class="line"><span class="comment">//输出结果位：0 10000011 00101011100110011001101（高位0实际上没有输出，这里手动补上了）</span></span><br><span class="line"></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToRawLongBits(<span class="number">18.725</span>)));</span><br><span class="line"><span class="comment">//输出结果：0 10000000011 0010101110011001100110011001100110011001100110011010</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串转浮点数"><a href="#字符串转浮点数" class="headerlink" title="字符串转浮点数"></a>字符串转浮点数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本示例是最基础的转换，比如输入“34.5789”，输出为 34.5789</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">stringToFloat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dotIndex</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dotIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dotIndex = str.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">float</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=dotIndex-<span class="number">1</span>, j=<span class="number">0</span>; i&gt;=<span class="number">0</span>; i--, j++) &#123;</span><br><span class="line">            value += (str.charAt(i)-<span class="string">&#x27;0&#x27;</span>) * Math.pow(<span class="number">10</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=dotIndex+<span class="number">1</span>, j=<span class="number">1</span>; i&lt;str.length(); i++, j++) &#123;</span><br><span class="line">            value += (str.charAt(i)-<span class="string">&#x27;0&#x27;</span>) * Math.pow(<span class="number">10</span>, -j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.shuxuele.com/numbers/scientific-notation.html">科学记数法</a></li>
<li><a href="https://www.sojson.com/hexconvert.html">在线进制转换</a></li>
<li><a href="https://www.cnblogs.com/Java-Script/p/11123897.html">Java语言中：float、double数据类型在内存中是如何存储的</a></li>
<li><a href="https://www.runoob.com/w3cnote/java-the-different-float-double.html">Java 浮点类型 float 和 double 的主要区别</a></li>
<li><a href="https://blog.csdn.net/weixin_47713503/article/details/108699001">IEEE754 浮点数：简读+案例=秒懂</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 公平锁和非公平锁</title>
    <url>/posts/c7038aa0.html</url>
    <content><![CDATA[<p>公平锁：指的是多个线程等待同一个锁时，等待时间最长的线程将会优先获取到锁。但是，这也会导致当线程尝试获取锁时，很大概率会进入阻塞状态，有很高的状态切换成本，因此，会降低吞吐量和执行效率。</p>
<p>非公平锁：不会保证一个特定获取到锁的顺序。当线程尝试获取锁时，会优先通过CAS尝试获取锁，如果失败了才会进入等待队列。非公平锁的执行效率更高，因为线程尝试获取锁的时候，如果能够直接获取到锁，可以节省线程的上下文切换带来的时间和性能上的开销。但是，可能会导致有的线程永远也获取不到锁。</p>
<p>Java中的<code>synchronized</code>是非公平锁，<code>ReentrantLock</code>默认也是非公平锁，并且是可重入的。<code>ReentrantLock</code>则可以通过<code>fair</code>来设置为公平锁。下面是<code>ReentrantLock</code>的类图结构：</p>
<img src="\assert\puml\ef2d08ced09cc20646f852dd172e7965b01321befac79c3aed50b70655315b55.svg"/>

<h2 id="公平锁加锁"><a href="#公平锁加锁" class="headerlink" title="公平锁加锁"></a>公平锁加锁</h2><p>公平锁加锁过程的方法调用：<code>ReentrantLock#lock()</code> &rarr; <code>ReentrantLock.FairSync#lock()</code> &rarr; <code>AbstractQueuedSynchronizer#acquire(1)</code>。下面看下acquire的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【AbstractQueuedSynchronizer.java】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【ReentrantLock.java】</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 只有锁未被锁定、锁重入或者等待队列中没有前辈的情况才会获取成功</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state为0表示当前是未被锁定状态</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//判断等待队列是否有排在自己前面的线程</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//通过CAS设置锁定状态</span></span><br><span class="line">                    setExclusiveOwnerThread(current); <span class="comment">//独占线程设置为自己</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//加锁成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 锁的重入，状态加1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//加锁成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//加锁失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【AbstractQueuedSynchronizer.java】</span></span><br><span class="line"><span class="comment">// addWaiter的作用就是将当前线程添加到等待队列的队尾</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">//循环</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 请求锁的当前线程排在了队首，且获取锁成功</span></span><br><span class="line">                    setHead(node); <span class="comment">//设置为head，所以head是持有锁的线程</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) <span class="comment">//进入blocked状态</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="\assert\puml\56d891a76e8315a3de8cf703bdd3a548a9ea47d47f033be64267488046ab9fb0.svg"/>

<p>有一点需要注意，即使<code>ReentrantLock</code>构造时<code>fair</code>设置为true，使用不带超时的<code>tryLock()</code>加锁时也会使用非公平锁的策略。</p>
<h2 id="非公平锁加锁"><a href="#非公平锁加锁" class="headerlink" title="非公平锁加锁"></a>非公平锁加锁</h2><p>调用链路：<code>ReentrantLock#lock()</code> &rarr; <code>ReentrantLock.NonfairSync#lock()</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【ReentrantLock.java】</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">//直接使用CAS加锁，加锁成功后设置为独占线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【AbstractQueuedSynchronizer.java】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">//调用NonfairSync.tryAcquire()</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//acquireQueued与公平锁流程相同</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 【ReentrantLock.java】</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//当前是未锁定转台</span></span><br><span class="line">                <span class="comment">//直接尝试加锁，不会判断队列中是否有其他线程排队，而公平锁会首先判断队列中是否已经有其他线程在排队</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//锁重入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，公平锁和非公平锁的加锁流程几乎相同，区别是state==0时，非公平锁会直接使用CAS尝试加锁，而公平锁会首先判断等待队列中是否有其他线程在排队，如果没人在排队才会使用CAS加锁。</p>
<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>公平锁和非公平锁释放锁的流程是一样的。调用链路<code>ReentrantLock#unlock()</code> &rarr; <code>AbstractQueuedSynchronizer#release()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【AbstractQueuedSynchronizer.java】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h); <span class="comment">//唤醒队列中下一个等待线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【ReentrantLock.java】</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取state并减一</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="comment">// 加锁和解锁线程如果不同就会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//为0表示锁被释放，否则，表示锁的多次重入</span></span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">//独占线程设置为null</span></span><br><span class="line">            &#125;</span><br><span class="line">            setState(c); <span class="comment">//更新锁状态state</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池源码详解</title>
    <url>/posts/271b6343.html</url>
    <content><![CDATA[<p>线程池具备如下两个方面的优势：</p>
<ol>
<li>当需要创建大量异步任务时会改善应用性能，因为线程池减少了任务的调用开销；</li>
<li>可以更好的管理线程，比如监控线程使用情况、系统调优等；</li>
</ol>
<p>下面是线程池类图结构：</p>
<img src="\assert\puml\d49acc82bbe59d276774983f859c553e0622cd7a02a8bcd8e91e47568cd20920.svg"/>

<p>线程池分了两个大类：ThreadPoolExecutor是普通线程池，ForkJoinPool可用理解为是一个轻量级任务的线程池。</p>
<h2 id="线程池线程数量管理"><a href="#线程池线程数量管理" class="headerlink" title="线程池线程数量管理"></a>线程池线程数量管理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>corePoolSize核心线程数: 当线程池的线程数小于corePoolSize时，会创建一个新的线程来执行新任务，即使有线程处于闲置状态。</li>
<li>maximumPoolSize最大线程数：当线程数已经大于corePoolSize，新任务会被优先添加到队列中等待执行。如果任务队列满了导致添加失败，并且线程数小于maximumPoolSize，就会创建新的线程来执行新任务。大于核心线程数的这些线程算是“借”来的，当借来的这些线程的idle时间超过keepAliveTime，就会被回收。回收逻辑在runWorker函数中。</li>
<li>如果线程队列满了，线程数也已经大于maximumPoolSize，就会回调<code>RejectedExecutionHandler.rejectedExecution</code>让调用中来处理任务。</li>
</ol>
<img src="\assert\puml\7f2b4eee12e7f15823eca073ba89911f1ee4542b4d40202ac0b2f8c1f6604ae3.svg"/>

<p><strong>通过一段代码测试一下上述线程数量的限制：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> server: ExecutorService = ThreadPoolExecutor(</span><br><span class="line">    <span class="number">2</span>, <span class="comment">//corePoolSize</span></span><br><span class="line">    <span class="number">10</span>, <span class="comment">//maximumPoolSize</span></span><br><span class="line">    <span class="number">5</span>, TimeUnit.MINUTES,  <span class="comment">//keepAliveTime</span></span><br><span class="line">    LinkedBlockingDeque(<span class="number">5</span>)) <span class="comment">//任务队列，最大容量是5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.20</span>) &#123;</span><br><span class="line">    server.execute &#123; </span><br><span class="line">        println(<span class="string">&quot;task <span class="variable">$i</span> run&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="built_in">Long</span>.MAX_VALUE)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的输出为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">task 0 run</span><br><span class="line">task 1 run</span><br><span class="line">task 7 run</span><br><span class="line">task 8 run</span><br><span class="line">task 9 run</span><br><span class="line">task 10 run</span><br><span class="line">task 11 run</span><br><span class="line">task 12 run</span><br><span class="line">task 13 run</span><br><span class="line">task 14 run</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task MainKt$$Lambda$16/0x0000017ddf003400@70177ecd rejected from java.util.concurrent.ThreadPoolExecutor@1e80bfe8[Running, pool size = 10, active threads = 10, queued tasks = 5, completed tasks = 0]</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2065)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:833)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1365)</span><br><span class="line">	at MainKt.main(Main.kt:20)</span><br></pre></td></tr></table></figure>

<p>从程序的输出可以看出，0、1是通过核心线程来执行，2&#126;5号任务被添加到了队列中等待执行。因为任务队列满了，所以7~14是通过新建线程来执行（线程数没有超过maximumPoolSize）。0、1、7&#126;14共计10个任务，达到了maximumPoolSize设置的最大线程数，所以当添加15号线程时报出了异常。</p>
<h2 id="提交新任务"><a href="#提交新任务" class="headerlink" title="提交新任务"></a>提交新任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 1. 如果当前线程池线程数小于corePoolSize，就创建一个新的线程来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 线程数已经大于corePoolSize，并且线程池当前是running状态，就把任务添加到队列中等待执行</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 任务队列已满，并且线程数小于maximumPoolSize，则创建新的线程来执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN) &amp;&amp; </span><br><span class="line">            (runStateAtLeast(c, STOP) || firstTask != <span class="literal">null</span> || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//a) 添加核心线程：如果线程数量&gt;=corePoolSize返回失败;</span></span><br><span class="line">            <span class="comment">//b) 队列已满，添加非核心新线程，如果线程数量&gt;=maximumPoolSize返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//线程数+1并返回外层的for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建新线程，Worker构造函数中会创新新的Thread</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><p>线程池中的每个线程对应一个Worker，Worker的首次任务执行完成后，不会立马退出，而是通过getTask()在任务队列中阻塞获取任务，当获取到任务队列中的任务后，就继续执行。如果线程池没有被退出，并且线程数已经超过核心线程数，getTask()中就会以超时的方式阻塞获取任务，超时时间为keepAliveTime，如果发生timeout（keepAliveTime时间后，任务队列中也没有新任务），就会返回null，此时runWorker函数就会走到<code>processWorkerExit</code>的逻辑来回收“借”来的线程，<code>processWorkerExit</code>执行完成后线程就退出了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//反复从队列中获取任务并执行</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 优先执行firstTask，firstTask执行完成后会调用getTask()从队列获取任务来执行</span></span><br><span class="line">            <span class="comment">// 如果getTask()返回null，线程会退出，系统就会回收这个线程</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run(); <span class="comment">//执行任务</span></span><br><span class="line">                        afterExecute(task, <span class="literal">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        afterExecute(task, ex);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">                &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//线程数大于maximumPoolSize或者线程的闲置时间超过了keepAliveTime就返回null退出线程</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从队列中获取任务</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><ul>
<li>RUNNING: 接收新任务，并且处理队列中的任务；</li>
<li>SHUTDOWN: 不接受新任务，但会继续处理队列中的任务；</li>
<li>STOP: 不接受新任务，不处理队列中的任务，并且会终端正在执行的任务；</li>
<li>TIDYING: 所有任务都已经终止，线程数是0，线程转换到TIDYING状态会运行terminated()方法；</li>
<li>TERMINATED: terminated()运行结束；</li>
</ul>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %0 Pages: 1 -->
<svg width="234pt" height="385pt"
 viewBox="0.00 0.00 233.59 384.80" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 380.8)">
<title>%0</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-380.8 229.5947,-380.8 229.5947,4 -4,4"/>
<!-- RUNNING -->
<g id="node1" class="node">
<title>RUNNING</title>
<polygon fill="none" stroke="#000000" points="146.5831,-376.8 84.3969,-376.8 84.3969,-340.8 146.5831,-340.8 146.5831,-376.8"/>
<text text-anchor="middle" x="115.49" y="-355.8" font-family="Times,serif" font-size="10.00" fill="#000000">RUNNING</text>
</g>
<!-- SHUTDOWN -->
<g id="node2" class="node">
<title>SHUTDOWN</title>
<polygon fill="none" stroke="#000000" points="112.1923,-291.6 38.7877,-291.6 38.7877,-255.6 112.1923,-255.6 112.1923,-291.6"/>
<text text-anchor="middle" x="75.49" y="-270.6" font-family="Times,serif" font-size="10.00" fill="#000000">SHUTDOWN</text>
</g>
<!-- RUNNING&#45;&gt;SHUTDOWN -->
<g id="edge1" class="edge">
<title>RUNNING&#45;&gt;SHUTDOWN</title>
<path fill="none" stroke="#000000" d="M106.3249,-340.5449C103.5206,-334.878 100.4542,-328.5979 97.7143,-322.8 94.4105,-315.8089 90.928,-308.2141 87.7251,-301.1307"/>
<polygon fill="#000000" stroke="#000000" points="90.8654,-299.58 83.5738,-291.8934 84.4805,-302.4494 90.8654,-299.58"/>
<text text-anchor="middle" x="119.8778" y="-312.9" font-family="Times,serif" font-size="11.00" fill="#000000">shutdown</text>
</g>
<!-- STOP -->
<g id="node3" class="node">
<title>STOP</title>
<polygon fill="none" stroke="#000000" points="181.49,-206.4 127.49,-206.4 127.49,-170.4 181.49,-170.4 181.49,-206.4"/>
<text text-anchor="middle" x="154.49" y="-185.4" font-family="Times,serif" font-size="10.00" fill="#000000">STOP</text>
</g>
<!-- RUNNING&#45;&gt;STOP -->
<g id="edge2" class="edge">
<title>RUNNING&#45;&gt;STOP</title>
<path fill="none" stroke="#000000" d="M130.6484,-340.7479C134.4778,-335.2934 138.16,-329.0777 140.49,-322.8 153.4614,-287.8508 155.7236,-244.5048 155.5737,-216.6522"/>
<polygon fill="#000000" stroke="#000000" points="159.0697,-216.3766 155.4059,-206.4354 152.0707,-216.4916 159.0697,-216.3766"/>
<text text-anchor="middle" x="186.5687" y="-270.3" font-family="Times,serif" font-size="11.00" fill="#000000">shutdownNow</text>
</g>
<!-- SHUTDOWN&#45;&gt;STOP -->
<g id="edge3" class="edge">
<title>SHUTDOWN&#45;&gt;STOP</title>
<path fill="none" stroke="#000000" d="M71.3705,-255.3975C70.1543,-245.4742 70.4503,-233.4147 76.3325,-224.4 77.0064,-223.3672 97.7904,-213.8169 117.7537,-204.8132"/>
<polygon fill="#000000" stroke="#000000" points="119.4092,-207.9064 127.0936,-200.6126 116.5379,-201.5224 119.4092,-207.9064"/>
<text text-anchor="middle" x="108.5687" y="-227.7" font-family="Times,serif" font-size="11.00" fill="#000000">shutdownNow</text>
</g>
<!-- TIDYING -->
<g id="node4" class="node">
<title>TIDYING</title>
<polygon fill="none" stroke="#000000" points="69.1341,-121.2 11.8459,-121.2 11.8459,-85.2 69.1341,-85.2 69.1341,-121.2"/>
<text text-anchor="middle" x="40.49" y="-100.2" font-family="Times,serif" font-size="10.00" fill="#000000">TIDYING</text>
</g>
<!-- SHUTDOWN&#45;&gt;TIDYING -->
<g id="edge4" class="edge">
<title>SHUTDOWN&#45;&gt;TIDYING</title>
<path fill="none" stroke="#000000" d="M60.4198,-255.5389C50.7464,-242.7186 39.0587,-224.614 33.8758,-206.4 26.8559,-181.7305 29.7309,-152.4555 33.6431,-131.3981"/>
<polygon fill="#000000" stroke="#000000" points="37.0946,-131.9896 35.6722,-121.4907 30.2369,-130.5851 37.0946,-131.9896"/>
<text text-anchor="middle" x="76.7971" y="-191.7" font-family="Times,serif" font-size="11.00" fill="#000000">When both queue </text>
<text text-anchor="middle" x="76.7971" y="-178.5" font-family="Times,serif" font-size="11.00" fill="#000000">and pool are empty</text>
</g>
<!-- STOP&#45;&gt;TIDYING -->
<g id="edge5" class="edge">
<title>STOP&#45;&gt;TIDYING</title>
<path fill="none" stroke="#000000" d="M130.3135,-170.3313C113.5368,-157.7928 91.0052,-140.9534 72.7058,-127.277"/>
<polygon fill="#000000" stroke="#000000" points="74.737,-124.4257 64.6316,-121.2427 70.5465,-130.0328 74.737,-124.4257"/>
<text text-anchor="middle" x="148.9421" y="-142.5" font-family="Times,serif" font-size="11.00" fill="#000000">When pool is empty</text>
</g>
<!-- TERMINATED -->
<g id="node5" class="node">
<title>TERMINATED</title>
<polygon fill="none" stroke="#000000" points="80.97,-36 .01,-36 .01,0 80.97,0 80.97,-36"/>
<text text-anchor="middle" x="40.49" y="-15" font-family="Times,serif" font-size="10.00" fill="#000000">TERMINATED</text>
</g>
<!-- TIDYING&#45;&gt;TERMINATED -->
<g id="edge6" class="edge">
<title>TIDYING&#45;&gt;TERMINATED</title>
<path fill="none" stroke="#000000" d="M40.49,-85.1313C40.49,-73.8354 40.49,-59.0487 40.49,-46.2289"/>
<polygon fill="#000000" stroke="#000000" points="43.9901,-46.0426 40.49,-36.0427 36.9901,-46.0427 43.9901,-46.0426"/>
<text text-anchor="middle" x="133.0424" y="-57.3" font-family="Times,serif" font-size="11.00" fill="#000000">When terminated() method has completed</text>
</g>
</g>
</svg>


<p>线程池状态和线程数使用同一个int变量来保存，一个int变量包含32个bit，高3为用于存放状态。RUNNING=111，SHUTDOWN=000，STOP=001，TIDYING=010，TERMINATED=011。</p>
<h2 id="线程池排队策略"><a href="#线程池排队策略" class="headerlink" title="线程池排队策略"></a>线程池排队策略</h2><p>线程池任务的排队常用的有3中策略。</p>
<p><strong>直接传递</strong>：采用同步队列<code>SynchronousQueue</code>来执行任务排队策略。每次任务入队都要等待另一个线程拿走该任务。当任务要入队时，如果没有线程立马来消费，入队就会失败<small><em>(SynchronousQueue.offer默认超时时间为0)</em></small>，就会新建一个线程来执行任务。直接传递策略通常要求maximumPoolSize设置为无限大来避免任务被拒绝。否则，当线程数达到上限时，新任务将会被拒绝。</p>
<ul>
<li><code>Executors#newCachedThreadPool()</code>就是使用这种策略，核心线程数为0，最大线程数是Integer.MAX_VALUE，线程keepAliveTime是1分钟。</li>
</ul>
<p><strong>无界队列</strong>：比如使用不设置最大容量的<code>LinkedBlockingQueue</code>。当核心线程已满时，新任务会在队列中等待。因此创建的线程数不会超过corePoolSize<small>（任务队列是无限大，maximumPoolSize不会起作用）</small>。如果任务经常会被阻塞，比如IO任务，将会导致耗尽系统内存。</p>
<ul>
<li><code>Executors#newFixedThreadPool(int nThreads)</code>就是使用的这种策略，最大线程数和核心线程数使用相同的值nThreads；</li>
<li><code>Executors#newSingleThreadExecutor()</code>也是这种策略，相当于nThreads=1；</li>
</ul>
<p><strong>有界队列</strong>：比如<code>ArrayBlockingQueue</code>。配合有限制的maximumPoolSize，有界队列可以防止资源耗尽的情况发生。但是队列的容量和maximumPoolSize两者必须做权衡：使用大容量队列和一个小的maximumPoolSize，可以减少对cpu、系统资源、上下文切换等资源的消耗，但是会明显降低吞吐量；使用小队列和大容量线程池，时刻保持cpu的忙碌状态，但是可能会遇到比较大的调度压力，也会降低吞吐量。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.cnblogs.com/zxporz/p/10940251.html">ThreadPoolExecutor线程池的keepAliveTime</a><br><a href="https://www.cnblogs.com/qingquanzi/p/9018627.html">如何优雅的关闭Java线程池</a><br><a href="https://blog.csdn.net/qq_26881739/article/details/80983495">线程池的三种队列区别：SynchronousQueue、LinkedBlockingQueue 和ArrayBlockingQueue</a><br><a href="https://zhuanlan.zhihu.com/p/350067478">太完整了！这是我见过最详细的线程池讲解了</a><br><a href="https://www.gangofcoders.net/solution/why-is-creating-a-thread-said-to-be-expensive/">Why is creating a Thread said to be expensive?</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp详解系列五：连接拦截器 ConnectInterceptor</title>
    <url>/posts/ee27d764.html</url>
    <content><![CDATA[<ul>
<li><a href="/posts/78efaca4.html" title="okhttp详解系列一：开篇">okhttp详解系列一：开篇</a></li>
<li><a href="/posts/8e83ed63.html" title="okhttp详解系列二：重试重定向拦截器">okhttp详解系列二：重试重定向拦截器</a></li>
<li><a href="/posts/6e2b1d41.html" title="okhttp详解系列三：桥拦截器 BridgeInterceptor">okhttp详解系列三：桥拦截器 BridgeInterceptor</a></li>
<li><a href="/posts/37107c2e.html" title="okhttp详解系列四：缓存拦截器">okhttp详解系列四：缓存拦截器</a></li>
<li><a href="/posts/ee27d764.html" title="okhttp详解系列五：连接拦截器 ConnectInterceptor">okhttp详解系列五：连接拦截器 ConnectInterceptor</a></li>
<li><a href="/posts/73cf04e1.html" title="okhttp详解系列六：服务请求拦截器 CallServerInterceptor">okhttp详解系列六：服务请求拦截器 CallServerInterceptor</a>

</li>
</ul>
<p>连接拦截器（ConnectInterceptor）负责与服务器建立网络连接。连接拦截器类中的代码非常少，主要逻辑都在Exchange的初始化中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ConnectInterceptor : Interceptor &#123;</span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="comment">// 1. 初始化Exchange</span></span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line">    <span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line">    <span class="comment">// 2. 交给下一个拦截器进行处理，如果用户注册了网络拦截器，</span></span><br><span class="line">    <span class="comment">//  下一个拦截器就是用户注册的网络拦截器</span></span><br><span class="line">    <span class="keyword">val</span> result = connectedChain.proceed(realChain.request)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接拦截器的主要时序：</p>
<img src="\assert\puml\ed220da452d203a5de22fa696f3d59ab86277252a8e82c524ce1c5d42e101f77.svg"/>

<h2 id="连接池查找可用连接"><a href="#连接池查找可用连接" class="headerlink" title="连接池查找可用连接"></a>连接池查找可用连接</h2><img src="\assert\puml\5196ccecfb28764cb785fa1abf11dff86e94c1f4f7933bdb0360e9e9c30117a0.svg"/>

<h2 id="连接拦截器类图结构"><a href="#连接拦截器类图结构" class="headerlink" title="连接拦截器类图结构"></a>连接拦截器类图结构</h2><img src="\assert\puml\8454aee1e46e6831f08b15ce7793519fbfa1042314c30909d6b065419d53d3c2.svg"/>]]></content>
      <categories>
        <category>okhttp</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux清理Cached内存</title>
    <url>/posts/21595.html</url>
    <content><![CDATA[<p>Kernels 2.6.16 and newer provide a mechanism to have the kernel drop the page cache and/or inode and dentry caches on command, which can help free up a lot of memory. Now you can throw away that script that allocated a ton of memory just to get rid of the cache…</p>
<p>To use /proc/sys/vm/drop_caches, just echo a number to it.</p>
<p>To free pagecache:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
<p>To free dentries and inodes:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
<p>To free pagecache, dentries and inodes:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
<p>This is a non-destructive operation and will only free things that are completely unused. Dirty objects will continue to be in use until written out to disk and are not freeable. If you run “sync” first to flush them out to disk, these drop operations will tend to free more memory.</p>
<p>参考网站：</p>
<ul>
<li><a href="https://linux-mm.org/Drop_Caches">Drop_Caches</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp详解系列六：服务请求拦截器 CallServerInterceptor</title>
    <url>/posts/73cf04e1.html</url>
    <content><![CDATA[<ul>
<li><a href="/posts/78efaca4.html" title="okhttp详解系列一：开篇">okhttp详解系列一：开篇</a></li>
<li><a href="/posts/8e83ed63.html" title="okhttp详解系列二：重试重定向拦截器">okhttp详解系列二：重试重定向拦截器</a></li>
<li><a href="/posts/6e2b1d41.html" title="okhttp详解系列三：桥拦截器 BridgeInterceptor">okhttp详解系列三：桥拦截器 BridgeInterceptor</a></li>
<li><a href="/posts/37107c2e.html" title="okhttp详解系列四：缓存拦截器">okhttp详解系列四：缓存拦截器</a></li>
<li><a href="/posts/ee27d764.html" title="okhttp详解系列五：连接拦截器 ConnectInterceptor">okhttp详解系列五：连接拦截器 ConnectInterceptor</a></li>
<li><a href="/posts/73cf04e1.html" title="okhttp详解系列六：服务请求拦截器 CallServerInterceptor">okhttp详解系列六：服务请求拦截器 CallServerInterceptor</a>

</li>
</ul>
<p>服务请求拦截器会把消息请求头、请求体发送给服务端。并把服务端返回信息转换为Response。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span>) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange!!</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向socket中写入请求头</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> invokeStartEvent = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">      <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">      <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equals(request.header(<span class="string">&quot;Expect&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">true</span>)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123; <span class="comment">// 双工传输，HTTP/2才支持</span></span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">          <span class="comment">// 消息体写入到socket</span></span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection.isMultiplexed) &#123;</span><br><span class="line">          <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">      <span class="comment">// 刷新输出流，会调用socket的flush</span></span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">      <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// Server sent a 100-continue even though we did not request one. Try again to read the actual</span></span><br><span class="line">      <span class="comment">// response status.</span></span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">      <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response = responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equals(response.request.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">&quot;close&quot;</span>.equals(response.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">&quot;HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是最后一个拦截器，从代码可以看到没有调用chain.process。但是服务请求拦截器返回的response并不是最终的response，前置的拦截器还没有完全处理完成。比如服务返回了redirect，在重试和重定向拦截器中会发起重定向，拦截器会被再次执行。</p>
]]></content>
      <categories>
        <category>okhttp</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp详解系列二：重试重定向拦截器</title>
    <url>/posts/8e83ed63.html</url>
    <content><![CDATA[<ul>
<li><a href="/posts/78efaca4.html" title="okhttp详解系列一：开篇">okhttp详解系列一：开篇</a></li>
<li><a href="/posts/8e83ed63.html" title="okhttp详解系列二：重试重定向拦截器">okhttp详解系列二：重试重定向拦截器</a></li>
<li><a href="/posts/6e2b1d41.html" title="okhttp详解系列三：桥拦截器 BridgeInterceptor">okhttp详解系列三：桥拦截器 BridgeInterceptor</a></li>
<li><a href="/posts/37107c2e.html" title="okhttp详解系列四：缓存拦截器">okhttp详解系列四：缓存拦截器</a></li>
<li><a href="/posts/ee27d764.html" title="okhttp详解系列五：连接拦截器 ConnectInterceptor">okhttp详解系列五：连接拦截器 ConnectInterceptor</a></li>
<li><a href="/posts/73cf04e1.html" title="okhttp详解系列六：服务请求拦截器 CallServerInterceptor">okhttp详解系列六：服务请求拦截器 CallServerInterceptor</a>

</li>
</ul>
<p>重试和重定向拦截器主要负责三件事：1) 出错后判断是否重试；2) 处理重定向；3) 处理用户认证（401和407响应码）；</p>
<p>来看下源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">var</span> request = chain.request</span><br><span class="line">  <span class="keyword">val</span> call = realChain.call</span><br><span class="line">  <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;()</span><br><span class="line">  <span class="comment">// 1、重试和重定向的场景依然是在while循环中，不会退出该拦截器</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 2、根据需要创建 ExchangeFinder</span></span><br><span class="line">    call.enterNetworkInterceptorExchange(request, newExchangeFinder)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response: Response</span><br><span class="line">    <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3、realChain指向下一个拦截器，发生重试或者重定向后，</span></span><br><span class="line">        <span class="comment">// 会从下一个拦截器开始执行，前面的应用拦截器和此拦截器都不会被执行了</span></span><br><span class="line">        response = realChain.proceed(request)</span><br><span class="line">        newExchangeFinder = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 4、错误可以恢复，继续while循环</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          recoveredFailures += e</span><br><span class="line">        &#125;</span><br><span class="line">        newExchangeFinder = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 5、错误可以恢复，继续while循环</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">      <span class="comment">// 6、followUpRequest是判断是否重试的主要逻辑，包括重定向、超时重试、用户认证等场景</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          call.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        closeActiveExchange = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用拦截器只会被执行一次的原因"><a href="#应用拦截器只会被执行一次的原因" class="headerlink" title="应用拦截器只会被执行一次的原因"></a>应用拦截器只会被执行一次的原因</h2><p>我们都知道okhttp支持两种类型的用户层拦截器：应用拦截器(Application Interceptors)和网络拦截器(Network Interceptors)。应用拦截器每次发起请求都会被保证执行一次，即使发生了重试和重定向也是被执行一次。而网络拦截器在重试和重定向的场景都会被执行多次，而且缓存的场景可能不会被执行。这种差异是什么原因导致的呢？</p>
<p>RetryAndFollowUpInterceptor拦截器使用了一个while循环，当需要重试或者重定向时，不会退出循环，继续执行<code>chain.proceed()</code>，这个chain就是RealInterceptorChain。在分析RealInterceptorChain的proceed()方法时，我们知道每次执行下一个拦截器时，都会把RealInterceptorChain拷贝一份，chain的index就指向下一个拦截器。所以重试和重定向的情况都会从下一个拦截器开始，而用户注册的程序拦截器在RetryAndFollowUpInterceptor前面，这就是即使发生了重试和重定向程序拦截器也会只被执行一次的根本原因。而网络拦截器排在RetryAndFollowUpInterceptor后面，所以会被执行多次。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">HTTP 身份验证</a></li>
</ol>
]]></content>
      <categories>
        <category>okhttp</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp详解系列一：开篇</title>
    <url>/posts/78efaca4.html</url>
    <content><![CDATA[<ul>
<li><a href="/posts/78efaca4.html" title="okhttp详解系列一：开篇">okhttp详解系列一：开篇</a></li>
<li><a href="/posts/8e83ed63.html" title="okhttp详解系列二：重试重定向拦截器">okhttp详解系列二：重试重定向拦截器</a></li>
<li><a href="/posts/6e2b1d41.html" title="okhttp详解系列三：桥拦截器 BridgeInterceptor">okhttp详解系列三：桥拦截器 BridgeInterceptor</a></li>
<li><a href="/posts/37107c2e.html" title="okhttp详解系列四：缓存拦截器">okhttp详解系列四：缓存拦截器</a></li>
<li><a href="/posts/ee27d764.html" title="okhttp详解系列五：连接拦截器 ConnectInterceptor">okhttp详解系列五：连接拦截器 ConnectInterceptor</a></li>
<li><a href="/posts/73cf04e1.html" title="okhttp详解系列六：服务请求拦截器 CallServerInterceptor">okhttp详解系列六：服务请求拦截器 CallServerInterceptor</a>

</li>
</ul>
<h2 id="okhttp-整体架构"><a href="#okhttp-整体架构" class="headerlink" title="okhttp 整体架构"></a>okhttp 整体架构</h2><img src="\assert\puml\615db738223300b1ef7816a24fc2d59b39f7416e2fbd360b7dce49e2aed64127.svg"/>

<img src="\assert\puml\1dd22576e40fb65627d0988ca5204a296921a64e2c9205eda3d80cad346d2b96.svg"/>

<p>okhttp的拦截器分为<strong>应用拦截器</strong>和<strong>网络拦截器</strong>，拦截器按照顺序执行，看下RealCall.getResponseWithInterceptorChain中拦截器的顺序定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  <span class="comment">//1.添加用户注册的应用拦截器</span></span><br><span class="line">  interceptors += client.interceptors </span><br><span class="line">  <span class="comment">//2.添加重试重定向拦截器</span></span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  <span class="comment">//3.添加桥接拦截器，用于用户数据和网络数据之间的相互转换</span></span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  <span class="comment">//4.添加缓存拦截器</span></span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  <span class="comment">//5.连接拦截器，负责跟服务器建立连接</span></span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    <span class="comment">//6.添加用户自定义网络拦截器</span></span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//7.服务请求连接器</span></span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">    call = <span class="keyword">this</span>,</span><br><span class="line">    interceptors = interceptors,</span><br><span class="line">    index = <span class="number">0</span>,</span><br><span class="line">    exchange = <span class="literal">null</span>,</span><br><span class="line">    request = originalRequest,</span><br><span class="line">    connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">    readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">    writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">//后面代码省略</span></span><br></pre></td></tr></table></figure>

<h2 id="拦截器的处理时序"><a href="#拦截器的处理时序" class="headerlink" title="拦截器的处理时序"></a>拦截器的处理时序</h2><p>这个是简化版的连接器处理时序，连接器调用到下一个都是要经过<code>RealInterceptorChain.proceed</code>，这里面逻辑比较简单，就是找到下一个连接器并执行，这个细节时序图中没有体现。</p>
<img src="\assert\puml\8af54cb3223f3f8eb6f6d800d4f4e4140f51221126eb6b2bd0e961826b9b4d77.svg"/>

<h2 id="同步和异步请求源码解析"><a href="#同步和异步请求源码解析" class="headerlink" title="同步和异步请求源码解析"></a>同步和异步请求源码解析</h2><h3 id="okhttp异步请求调用"><a href="#okhttp异步请求调用" class="headerlink" title="okhttp异步请求调用"></a>okhttp异步请求调用</h3><p>异步请求需要调用enqueue，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">      .url(<span class="string">&quot;http://publicobject.com/helloworld.txt&quot;</span>)</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  client.newCall(request).enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步请求源码解析：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备被执行的请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">// 正在执行的请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 添加到准备执行队列中</span></span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个AsyncCall都维护了一个计数器，这段代码的作用是找到相同host的请求，相同host的请求使用同一个计数器</span></span><br><span class="line">    <span class="comment">// 相同host的请求默认最大是5个，超过5个后，新的请求会等待前面的请求执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">      <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历准备执行的队列</span></span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 默认最大是64个并行请求</span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span></span><br><span class="line">      <span class="comment">// 同一个host默认最多5个并行请求</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span></span><br><span class="line">      <span class="comment">// 从准备执行队列中删除该任务</span></span><br><span class="line">      i.remove()</span><br><span class="line">      <span class="comment">// 任务计数器加一，用于限制相同host的最大并行请求个数</span></span><br><span class="line">      asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      <span class="comment">//添加到正在执行队列中</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把任务添加到线程池中，启动网络请求</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">    <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求结束时会执行该函数</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  call.callsPerHost.decrementAndGet()</span><br><span class="line">  finished(runningAsyncCalls, call)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)</span><br><span class="line">    idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再次执行promoteAndExecute，遍历队列任务并执行新的任务，因为超过最大并行任务限制后，</span></span><br><span class="line">  <span class="comment">// 有些任务正在排队，所以任务结束后需要再次检查执行队列运行新的任务</span></span><br><span class="line">  <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">    idleCallback.run()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步请求源码解析"><a href="#同步请求源码解析" class="headerlink" title="同步请求源码解析"></a>同步请求源码解析</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealCall</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// 直接在当前线程执行网络请求</span></span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dispacher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">  <span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">    finished(runningSyncCalls, call)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Dispatcher可以看出，同步请求单独放在runningSyncCalls队列中（和异步请求独立），因此同步请求的数量是没有限制的。</p>
<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p><strong>OkHttpClient</strong>在整个app中最好采用单例模式，所有的网路请求都使用一个<strong>OkHttpClient</strong>实例。这是因为每个<strong>OkHttpClient</strong>都会创建自己的<em>连接池</em>和<em>线程池</em>。如果每次请求都创建一个OkHttpClient就会浪费系统资源。</p>
<p>当所有请求都使用了同一个OkHttpClient后，如果某次网络请求需要特殊配置可以使用<code>OkHttpClient::newBuilder()</code>，这种方式创建的client会共享连接池、线程池以及全局配置。</p>
<p>参考<a href="https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/">OkHttpClients Should Be Shared</a></p>
<h2 id="编译okhttp-4-x"><a href="#编译okhttp-4-x" class="headerlink" title="编译okhttp 4.x"></a>编译okhttp 4.x</h2><ul>
<li>下载<a href="https://github.com/square/okhttp/tree/okhttp_4.10.x">okhttp-4.10.x源码</a>、<a href="https://www.oracle.com/cn/java/technologies/downloads/#java17">Java jdk17</a>、<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a></li>
<li>使用<strong>IntelliJ IDEA</strong>打开okhttp项目根目录。</li>
<li>Gradle JVM需要设置为jdk17，位置在<strong>IntelliJ IDEA</strong>【File】-&gt;【Settings】-&gt;【Build,Execution,Deployment】-&gt;【Build Tools-&gt;Gradle】。</li>
<li>在IDEA中打开<code>AsynchronousGet.kt</code>文件，然后点击运行main函数即可。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://square.github.io/okhttp/">OkHttp</a><br><strong><a href="https://square.github.io/okhttp/features/interceptors/">Interceptors</a></strong>: 重要<br><a href="https://juejin.cn/post/7043336794099679268">“深入交流“系列：Okhttp（二）拦截器的实现</a><br><a href="https://www.jianshu.com/p/3b8cf45a5be7">OkHttp3 Cache</a><br><a href="https://blog.csdn.net/huwei2003/article/details/70139062">HTTP 304状态码的详细讲解</a><br><a href="https://blog.csdn.net/rui0838/article/details/52727343">Cache-Control no-cache与max-age=0的区别</a><br><a href="https://blog.csdn.net/u012375924/article/details/82806617">浅谈http中的Cache-Control</a><br><a href="https://www.jianshu.com/p/7cb9300c6d71">谈谈OKHttp的几道面试题</a></p>
]]></content>
      <categories>
        <category>okhttp</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp详解系列四：缓存拦截器</title>
    <url>/posts/37107c2e.html</url>
    <content><![CDATA[<ul>
<li><a href="/posts/78efaca4.html" title="okhttp详解系列一：开篇">okhttp详解系列一：开篇</a></li>
<li><a href="/posts/8e83ed63.html" title="okhttp详解系列二：重试重定向拦截器">okhttp详解系列二：重试重定向拦截器</a></li>
<li><a href="/posts/6e2b1d41.html" title="okhttp详解系列三：桥拦截器 BridgeInterceptor">okhttp详解系列三：桥拦截器 BridgeInterceptor</a></li>
<li><a href="/posts/37107c2e.html" title="okhttp详解系列四：缓存拦截器">okhttp详解系列四：缓存拦截器</a></li>
<li><a href="/posts/ee27d764.html" title="okhttp详解系列五：连接拦截器 ConnectInterceptor">okhttp详解系列五：连接拦截器 ConnectInterceptor</a></li>
<li><a href="/posts/73cf04e1.html" title="okhttp详解系列六：服务请求拦截器 CallServerInterceptor">okhttp详解系列六：服务请求拦截器 CallServerInterceptor</a>

</li>
</ul>
<h2 id="缓存使用方法"><a href="#缓存使用方法" class="headerlink" title="缓存使用方法"></a>缓存使用方法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient = OkHttpClient.Builder()</span><br><span class="line">    .cache(Cache(</span><br><span class="line">        directory = File(<span class="string">&quot;/dir/http_cache&quot;</span>),</span><br><span class="line">        maxSize = <span class="number">5L</span> * <span class="number">1024L</span> * <span class="number">1024L</span> <span class="comment">// 5MiB</span></span><br><span class="line">    ))</span><br><span class="line">    .build()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缓存机制只实现了get请求的缓存，不支持其他的请求类型，比如POST。下面的官方的说明：</p>
<blockquote>
<p>Don’t cache non-GET responses. We’re technically allowed to cache HEAD requests and some POST requests, but the complexity of doing so is high and the benefit is low.</p>
</blockquote>
<img src="\assert\puml\a7c0bdd59919f997a0f328cab949b239bbdfea6800e2c566711274a30eb74d38.svg"/>

<p><strong>Cache-Control</strong>请求头是控制缓存策略的关键，server、client端都可以进行设置。<strong>Cache-Control</strong>决定了哪些response可以被缓存，以及缓存的response是否满足当前的request。协议定义可以参考<a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>。</p>
<h2 id="缓存拦截器流程"><a href="#缓存拦截器流程" class="headerlink" title="缓存拦截器流程"></a>缓存拦截器流程</h2><p>缓存拦截器的处理流程如下：</p>
<ol>
<li>首先通过url的md5值去读取本地可用缓存（后面会校验缓存是否可用）；</li>
<li>计算得到CacheStrategy，实际上就是计算得到<strong>networkRequest</strong>和<strong>cacheResponse</strong>，如果两者都为null，就直接报504错误；如果networkRequest是null，表示直接使用缓存。</li>
</ol>
<img src="\assert\puml\cbb3925bc62c9909f231adee2eb732dff565165fb344f8e7583a3abc765351db.svg"/>

<h2 id="CacheStrategy"><a href="#CacheStrategy" class="headerlink" title="CacheStrategy"></a>CacheStrategy</h2><p>CacheStrategy的生成使用的条件比较多，比如request CacheControl、response CacheControl、条件请求等，这块就不详细介绍了。其中要计算响应的年龄和响应的保鲜期，下面详细介绍两者的计算方法。</p>
<h3 id="响应年龄的计算方法"><a href="#响应年龄的计算方法" class="headerlink" title="响应年龄的计算方法"></a>响应年龄的计算方法</h3><p>响应的年龄是自它生成<small>（或者通过源服务器成功验证）</small>之后所经过的时长，计算方法如下：</p>
<ul>
<li>第一步：计算原始响应时长，”接收到响应的时间” 减去 “响应的服务时间”（表示生成该response的时间，响应头中的Date字段，如果没有，则取接收到响应的时间）</small>，得到的时间差与<strong>Age</strong>字段进行比较，取最大值；</li>
<li>第二步：计算响应时长，“接收到响应的时间”减去“发送响应的时间”；</li>
<li>第三步：计算本地年龄<small>（被缓存的response在本地的保存时长）</small>，当前时间减去接收到response的时间；</li>
<li>最后，把上述三者加和就得到了响应的最终年龄；</li>
</ul>
<p>响应头的Age字段有必要解释一下：如果存在Age字段，则表示这个response是基于缓存生成的，来自缓存服务器，而不是来自原始服务器。所以Age表示该次响应到源服务器提供服务的时间差。</p>
<h3 id="响应保鲜期的计算方法"><a href="#响应保鲜期的计算方法" class="headerlink" title="响应保鲜期的计算方法"></a>响应保鲜期的计算方法</h3><p>一个被缓存的response，如果超过了保鲜期，就表示这个被缓存的response必须再次通过源服务器的验证后才能继续使用；还在保鲜期内的response就可以不经过源服务器的验证就能使用。</p>
<ul>
<li>如果response Cache-Control中指定了max-age<small>（<em>单位秒</em>）</small>，保鲜期就取max-age的值。</li>
<li>如果没有max-age，被缓存响应中指定了Expires<small>（<em>时钟时间</em>）</small>，则保鲜期就是Expires减去响应服务时间<small>（响应头中的Date字段，如果没有则取接收到响应的时间）</small>后得到时间差。</li>
<li>如果Expires也没有，被缓存响应中存在Last-Modified响应头，则保鲜期就是服务时间<small>（如果没有就使用请求发送的时间）</small>减去Last-Modified的时间差的**10%**。</li>
<li>如果上述信息都没有就默认是0。</li>
<li>最后，上述计算得到的保鲜期与request Cache-Control的max-age的值进行比较，取小值。</li>
</ul>
<p>Request Cache-Control中还有两个字段会影响保鲜期的时长：</p>
<ol>
<li><strong>max-stale</strong> 是client端额外给保鲜期增加的时长，就像有的人比较节省，买的东西刚过了保鲜期没几天，就认为还可以继续用，再多用几天。</li>
<li><strong>min-fresh</strong> 是client端给保鲜期减掉的时长，就好比有的人比较讲究，买的食品马上就到保质期了（实际还差几天）就不想吃了。</li>
</ol>
<p>所以，最终计算的保鲜期还要加上<strong>max-stale</strong>，再减去<strong>min-fresh</strong>。</p>
<h2 id="写入Cache"><a href="#写入Cache" class="headerlink" title="写入Cache"></a>写入Cache</h2><p>这块逻辑相对比较简单。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(response: <span class="type">Response</span>)</span></span>: CacheRequest? &#123;</span><br><span class="line">  <span class="keyword">val</span> requestMethod = response.request.method</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      remove(response.request)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">      <span class="comment">// The cache cannot be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果不是GET请求，则不缓存</span></span><br><span class="line">  <span class="keyword">if</span> (requestMethod != <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache HEAD requests and some</span></span><br><span class="line">    <span class="comment">// POST requests, but the complexity of doing so is high and the benefit is low.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果Vary响应头中包含*则不缓存</span></span><br><span class="line">  <span class="keyword">if</span> (response.hasVaryAll()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> entry = Entry(response)</span><br><span class="line">  <span class="keyword">var</span> editor: DiskLruCache.Editor? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//使用url的md5作为key获取一个editer</span></span><br><span class="line">    editor = cache.edit(key(response.request.url)) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">//把response写入到缓存，会把发送时间戳和收到响应的时间戳都写到缓存里面，获取的时候会用来校验</span></span><br><span class="line">    entry.writeTo(editor)</span><br><span class="line">    <span class="keyword">return</span> RealCacheRequest(editor)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">    abortQuietly(editor)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>okhttp</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>okhttp详解系列三：桥拦截器 BridgeInterceptor</title>
    <url>/posts/6e2b1d41.html</url>
    <content><![CDATA[<ul>
<li><a href="/posts/78efaca4.html" title="okhttp详解系列一：开篇">okhttp详解系列一：开篇</a></li>
<li><a href="/posts/8e83ed63.html" title="okhttp详解系列二：重试重定向拦截器">okhttp详解系列二：重试重定向拦截器</a></li>
<li><a href="/posts/6e2b1d41.html" title="okhttp详解系列三：桥拦截器 BridgeInterceptor">okhttp详解系列三：桥拦截器 BridgeInterceptor</a></li>
<li><a href="/posts/37107c2e.html" title="okhttp详解系列四：缓存拦截器">okhttp详解系列四：缓存拦截器</a></li>
<li><a href="/posts/ee27d764.html" title="okhttp详解系列五：连接拦截器 ConnectInterceptor">okhttp详解系列五：连接拦截器 ConnectInterceptor</a></li>
<li><a href="/posts/73cf04e1.html" title="okhttp详解系列六：服务请求拦截器 CallServerInterceptor">okhttp详解系列六：服务请求拦截器 CallServerInterceptor</a>

</li>
</ul>
<p>BridgeInterceptor拦截器简要描述一下就是做了如下三件事：</p>
<ol>
<li>首先会把用户的Request进行进一步的处理（处理request header），转换成真正请求网络的Request；</li>
<li>然后继续调用其他拦截器进行网络请求；</li>
<li>最后收到响应结果后保存cookie，并解压缩gzip，最终转换为用户的Response。</li>
</ol>
<h2 id="BridgeInterceptor处理时序"><a href="#BridgeInterceptor处理时序" class="headerlink" title="BridgeInterceptor处理时序"></a>BridgeInterceptor处理时序</h2><img src="\assert\puml\32437250f75aac68862c54a192a5fb365677ab4ca798da7b4b061697580b6eef.svg"/>

<p>从上述流程可以看出BridgeInterceptor拦截器的处理逻辑比较简单。</p>
]]></content>
      <categories>
        <category>okhttp</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell判断文件是否存在</title>
    <url>/posts/25730.html</url>
    <content><![CDATA[<p>Conditional Logic on Files</p>
<ul>
<li>‘-a’ file exists.</li>
<li>‘-b’ file exists and is a block special file.</li>
<li>‘-c’ file exists and is a character special file.</li>
<li>‘-d’ file exists and is a directory.</li>
<li>‘-e’ file exists (just the same as -a).</li>
<li>‘-f’ file exists and is a regular file.</li>
<li>‘-g’ file exists and has its setgid(2) bit set.</li>
<li>‘-G’ file exists and has the same group ID as this process.</li>
<li>‘-k’ file exists and has its sticky bit set.</li>
<li>‘-L’ file exists and is a symbolic link.</li>
<li>‘-n’ string length is not zero.</li>
<li>‘-o’ Named option is set on.</li>
<li>‘-O’ file exists and is owned by the user ID of this process.</li>
<li>‘-p’ file exists and is a first in, first out (FIFO) special file or named pipe.</li>
<li>‘-r’ file exists and is readable by the current process.</li>
<li>‘-s’ file exists and has a size greater than zero.</li>
<li>‘-S’ file exists and is a socket.</li>
<li>‘-t’ file descriptor number fildes is open and associated with a terminal device.</li>
<li>‘-u’ file exists and has its setuid(2) bit set.</li>
<li>‘-w’ file exists and is writable by the current process.</li>
<li>‘-x’ file exists and is executable by the current process.</li>
<li>‘-z’ string length is zero.</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ -f $&#123;mypath&#125; ];then</span><br><span class="line">    echo &quot;file exist&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$&#123;mypath&#125;&quot; != &quot;&quot; ] &amp;&amp; [ -f $&#123;mypath&#125; ];then</span><br><span class="line">    echo &quot;mypath is not empty and file exist&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>参考网站：</p>
<ul>
<li><a href="http://codewiki.wikidot.com/shell-script:if-else">If / Else Statements (Shell Scripting)</a></li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 变量全解</title>
    <url>/posts/36017.html</url>
    <content><![CDATA[<h2 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h2><p>shell变量是一种很“弱”的变量，默认情况下，一个变量保存一个串，shell不关心这个串是什么含义。所以若要进行数学运算，必须使用一些命令例如let、declare、expr、双括号等。</p>
<p>shell变量可分为两类：局部变量和环境变量。局部变量只在创建它们的shell中可用。而环境变量则可以在创建它们的shell及其派生出来的任意子进程中使用。有些变量是用户创建的，其他的则是专用shell变量。</p>
<p>变量名必须以字母或下划线字符开头。其余的字符可以是字母、数字(0~9)或下划线字符。任何其他的字符都标志着变量名的终止。名字是大小写敏感的。</p>
<p>给变量赋值时，等号周围不能有任何空白符。为了给变量赋空值，可以在等号后跟一个换行符。</p>
<p>用set命令可以查看所有的变量，unset var命令可以清除变量var，var相当于没有定义过。readonly var可以把var变为只读变量，定义之后不能对var进行任何更改。</p>
<p>shell变量常见引用方式如下：</p>
<!-- <style>
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid #C0C0C0;
        padding: 0.25em;
        }
</style> -->

<table>
<thead>
<tr>
<th>引用格式</th>
<th>含义介绍</th>
</tr>
</thead>
<tbody><tr>
<td>${var}</td>
<td>变量值。也可以写成$var，但是不推荐。</td>
</tr>
<tr>
<td>${&#35;var}</td>
<td>变量长度。例如var=&quot;HelloWorld&quot;，则${&#35;var}返回值为10。 注意，引号””是界定符号，而不是变量中的字符。</td>
</tr>
<tr>
<td>${var:start_index}</td>
<td>返回从start_index开始一直到字符串结尾。<br/>start_index为0表示从第一个字符开始，<br/>start_index为0-x表示从倒数第x个字符开始。<br/>例如var=&quot;0123456789&quot;。则${var:0}返回&quot;0123456789&quot;，${var:6}返回&quot;6789&quot;，${var:0-3}返回”789”。</td>
</tr>
<tr>
<td>${var:start_index:length}</td>
<td>返回从start_index开始的length个字符，length可以为负数。var=&quot;0123456789&quot;，${var:2:5}返回&quot;23456&quot;，${var:5:-2}返回&quot;567&quot;（-2表示剩余2个字符不要），${var:0-3:-1}返回&quot;78&quot;。</td>
</tr>
<tr>
<td>${var&#35;string}</td>
<td>返回从左边删除string后的字符串，尽量短的去匹配。例如var=&quot;https&#xfeff;://127.0.0.1/index.php&quot;， ${var&#35;*/}返回&quot;/127.0.0.1/index.php&quot;</td>
</tr>
<tr>
<td>${var&#35;&#35;string}</td>
<td>返回从左边删除string后的字符串，尽量长的去匹配。例如var=&quot;https&#xfeff;://127.0.0.1/index.php&quot;，${var&#35;&#35;*/}返回&quot;index.php&quot;</td>
</tr>
<tr>
<td>${var%string}</td>
<td>返回从右边删除string后的字符串，尽量短的去匹配。例如var=&quot;https&#xfeff;://127.0.0.1/index.php&quot;，${var%/*}返回&quot;https&#xfeff;://127.0.0.1&quot;</td>
</tr>
<tr>
<td>${var%string}</td>
<td>返回从右边删除string后的字符串，尽量长的去匹配。例如var=&quot;https&#xfeff;://127.0.0.1/index.php&quot;，${var%/*}返回&quot;https:&quot;</td>
</tr>
<tr>
<td>${var:-newstring}</td>
<td>如果var为空，或者未定义，则返回newstring；否则返回原值。</td>
</tr>
<tr>
<td>${var:=newstring}</td>
<td>如果var为空，或者未定义，则返回newstring，并把newstring赋值给var；否则返回原值。</td>
</tr>
<tr>
<td>${var:+newstring}</td>
<td>如果var不为空，则返回newstring；如果var为空，则返回空值。</td>
</tr>
<tr>
<td>${var:?newstring}</td>
<td>如果var为空或者未定义，则将newstring写入标准错误流，本语句失败；如果var不为空，则返回原值。</td>
</tr>
<tr>
<td>${var/substring/newstring}</td>
<td>返回var中第一个substring被替换成newstring的字符串。例如var=&quot;2345432&quot;, ${var/3/Hello}返回&quot;2Hello45432&quot;</td>
</tr>
<tr>
<td>${var//substring/newstring}</td>
<td>返回var中所有substring被替换成newstring的字符串。例如var=&quot;2345432&quot;, ${var//3/Hello}返回&quot;2Hello454Hello2&quot;</td>
</tr>
<tr>
<td>$(command)</td>
<td>返回command命令执行后的所输出的结果。例如$(date)，返回date命令执行后的输出，同<code>date</code>命令</td>
</tr>
<tr>
<td>$((算数表达式))</td>
<td>返回双括号中算数运算的结果。例如$((20+5*6))，返回50</td>
</tr>
</tbody></table>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量的定义方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export var=value</span><br></pre></td></tr></table></figure>

<p>shell在初始化的时候会在执行profile等初始化脚本，脚本中定义了一些环境变量，这些变量会在创建子进程时传递给子进程。<br>用env命令可以查看当前的环境变量。常用的系统环境变量如下：</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>_</td>
<td>上一条命令的最后一个参数 <code>$_</code></td>
</tr>
<tr>
<td>BASH</td>
<td>展开为调用bash实例时使用的全路径名</td>
</tr>
<tr>
<td>CDPATH</td>
<td>cd命令的搜索路径。它是以冒号分隔的目录列表，shell通过它来搜索cd命令指定的目标目录。例如.:~:/usr</td>
</tr>
<tr>
<td>EDITOR</td>
<td>内置编辑器emacs、gmacs或vi的路径名</td>
</tr>
<tr>
<td>ENV</td>
<td>每一个新的bash shell(包括脚本)启动时执行的环境文件。通常赋予这个变量的文件名是.bashrc。</td>
</tr>
<tr>
<td>EUID</td>
<td>展开为在shell启动时被初始化的当前用户的有效ID</td>
</tr>
<tr>
<td>GROUPS</td>
<td>当前用户所属的组</td>
</tr>
<tr>
<td>HISTFILE</td>
<td>指定保存命令行历史的文件。默认值是~/.bash_history。如果被复位，交互式shell退出时将不保存命令行历史</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>记录在命令行历史文件中的命令数。默认是500</td>
</tr>
<tr>
<td>HOME</td>
<td>主目录。未指定目录时，cd命令将转向该目录</td>
</tr>
<tr>
<td>IFS</td>
<td>内部字段分隔符，一般是空格符、制表符和换行符，用于由命令替换，循环结构中的表和读取的输入产生的词的字段划分</td>
</tr>
<tr>
<td>LANG</td>
<td>用来为没有以LC_开头的变量明确选取的种类确定locale类</td>
</tr>
<tr>
<td>OLDPWD</td>
<td>前一个工作目录</td>
</tr>
<tr>
<td>PATH</td>
<td>命令搜索路径。一个由冒号分隔的目录列表，shell用它来搜索命令，一个普通值为 /usr/gnu/bin:/usr/local/bin:/usr/ucb:/usr/bin</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程的进程ID</td>
</tr>
<tr>
<td>PS1</td>
<td>主提示符串，默认值是$</td>
</tr>
<tr>
<td>PS2</td>
<td>次提示符串，默认值是&gt;</td>
</tr>
<tr>
<td>PS3</td>
<td>与select命令一起使用的选择提示符串，默认值是&#35;?</td>
</tr>
<tr>
<td>PS4</td>
<td>当开启追踪时使用的调试提示符串，默认值是+。追踪可以用set –x开启</td>
</tr>
<tr>
<td>PWD</td>
<td>当前工作目录。由cd设置</td>
</tr>
<tr>
<td>RANDOM</td>
<td>每次引用该变量，就产生一个随机整数。随机数序列可以通过给RANDOM赋值来初始化。如果RANDOM被复位，即使随后再设置，它也将失去特定的属性</td>
</tr>
<tr>
<td>REPLY</td>
<td>当没有给read提供参数时设置</td>
</tr>
<tr>
<td>SHELL</td>
<td>当调用shell时，它扫描环境变量以寻找该名字。shell给PATH、PS1、PS2、MAILCHECK和IFS设置默认值。HOME和MAIL由login(1)设置</td>
</tr>
<tr>
<td>SHELLOPTS</td>
<td>包含一列开启的shell选项，比如braceexpand、hashall、monitor等</td>
</tr>
<tr>
<td>UID</td>
<td>展开为当前用户的用户ID，在shell启动时初始化</td>
</tr>
</tbody></table>
<p>可以为某个命令单独设置环境变量，而不会影响后续的命令执行，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH=./lib:$LD_LIBRARY_PATH ./make_ext4fs</span><br></pre></td></tr></table></figure>

<h2 id="数值变量"><a href="#数值变量" class="headerlink" title="数值变量"></a>数值变量</h2><p>shell中默认把变量值当作字符串，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">age=22</span><br><span class="line">age=<span class="variable">$&#123;age&#125;</span>+1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age&#125;</span> </span><br></pre></td></tr></table></figure>

<p>输出结果为22+1，而不是23，因为shell将其解释为字符串，而不是数学运算。</p>
<p>可以用let命令使其进行数学运算，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">let age=$&#123;age&#125;+1</span><br></pre></td></tr></table></figure>

<p>也可以用typeset或者declare把变量定义为整型。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">typeset</span> -i age=22     </span><br><span class="line">age=<span class="variable">$&#123;age&#125;</span>+1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age&#125;</span></span><br></pre></td></tr></table></figure>

<p>typeset的 -i 选项把age定义为整型的了。此后每次运算，都把age的右值识别为算术表达式或数字。最终的输出结果是23</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在shell中可以使用数组，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array[0]=0</span><br><span class="line">array[1]=1</span><br><span class="line">array[2]=2</span><br></pre></td></tr></table></figure>

<p>则array就是一个数组，也可以这样给数组初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(0 1 2) // 元素之间以空格分隔</span><br></pre></td></tr></table></figure>

<h3 id="数组变量操作"><a href="#数组变量操作" class="headerlink" title="数组变量操作"></a>数组变量操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>&#36;{array[$*]}</td>
<td>访问array中某个元素</td>
</tr>
<tr>
<td>&#36;{&#35;array[*]}</td>
<td>返回数组元素个数</td>
</tr>
<tr>
<td>&#36;{array[*]} <br> &#36;{array[@]}</td>
<td>的返回值即数组的所有元素组成的串</td>
</tr>
<tr>
<td>&#36;{array[*]:0:2}</td>
<td>返回第一个和第二个元素组成的串。0表示开始的位置，2表示要返回的元素个数，开始位置可以为0-2(0减去2)之类的，表示从倒数第二个元素开始。</td>
</tr>
<tr>
<td>&#36;array[&#36;{&#35;array[*]}]=value</td>
<td>追加数组元素</td>
</tr>
<tr>
<td>unset array[$i]</td>
<td>删除某个数组元素</td>
</tr>
<tr>
<td>unset array</td>
<td>删除整个数据</td>
</tr>
</tbody></table>
<p>下面写个稍微复杂点的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    array[<span class="variable">$i</span>]=<span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;array[$i]&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串转化为数组"><a href="#字符串转化为数组" class="headerlink" title="字符串转化为数组"></a>字符串转化为数组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&quot;one two three four&quot;</span></span><br><span class="line">arr=(<span class="variable">$str</span>)</span><br></pre></td></tr></table></figure>

<p><strong>如果字符串分隔符不是空格，则采用下面方法分割成数组：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">str=<span class="string">&quot;one,two,three,four&quot;</span></span><br><span class="line">OLD_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">IFS=<span class="string">&quot;,&quot;</span></span><br><span class="line">arr=(<span class="variable">$str</span>)</span><br><span class="line">IFS=<span class="string">&quot;<span class="variable">$OLD_IFS</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>OLD_IFS用于保存原分隔符，用于后续恢复。</p>
<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td><strong>n</strong>是正整数。<code>$0</code>当前脚本名称，<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，等等</td>
</tr>
<tr>
<td>$#</td>
<td>传入脚本的参数的个数</td>
</tr>
<tr>
<td>$*</td>
<td>所有的位置参数(作为单个字符串)</td>
</tr>
<tr>
<td>$@</td>
<td>所有的位置参数(每个都作为独立的字符串)。</td>
</tr>
<tr>
<td>$?</td>
<td>当前shell进程中，上一个命令的返回值，如果上一个命令成功执行则$?的值为0，否则为其他非零值，常用做if语句条件</td>
</tr>
<tr>
<td>$$</td>
<td>当前shell进程的pid</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的pid</td>
</tr>
<tr>
<td>$-</td>
<td>显示shell使用的当前选项</td>
</tr>
<tr>
<td>$_</td>
<td>之前命令的最后一个参数</td>
</tr>
</tbody></table>
<p><code>$*</code>和<code>$@</code>都表示传给脚本或者函数的参数列表，当使用双引号包裹时，<code>&quot;$*&quot;</code>是一个字符串，而<code>&quot;$@&quot;</code>则像一个数组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in &quot;$*&quot;;do</span><br><span class="line">    echo $var</span><br><span class="line">done</span><br><span class="line">echo &quot;-------------&quot;</span><br><span class="line">for var in &quot;$@&quot;;do</span><br><span class="line">    echo $var</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>上述代码输入结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./test.sh xxx yyy zzz</span><br><span class="line">xxx yyy zzz</span><br><span class="line">-------------</span><br><span class="line">xxx</span><br><span class="line">yyy</span><br><span class="line">zzz</span><br></pre></td></tr></table></figure>

<h2 id="指定变量类型：typeset-与-declare"><a href="#指定变量类型：typeset-与-declare" class="headerlink" title="指定变量类型：typeset 与 declare"></a>指定变量类型：typeset 与 declare</h2><p>declare和typeset是bash的内建命令，它们是完全相同的，可以用来限定变量的属性，如整型、大小写、宽度、左右对齐等。这是在某些编程语言中使用的定义类型不严格的方式。<br>当用typeset或declare改变一个变量的属性时,这种改变是永久的。<br>命令declare是bash版本2之后才有的，命令typeset也可以在ksh脚本中运行。</p>
<p>常用命令参数：</p>
<ul>
<li>-r 设置变量为只读</li>
<li>-i 设置变量为整数</li>
<li>-a 设置变量为数组array</li>
<li>-f 如果后面没有参数的话会列出之前脚本定义的所有函数，如果有参数的话列出以参数命名的函数</li>
<li>-x 设置变量在脚本外也可以访问到</li>
<li>-u 将一个变量的字符变成大写</li>
<li>-l 将一个变量的字符变成小写</li>
</ul>
<h2 id="变量应用举例"><a href="#变量应用举例" class="headerlink" title="变量应用举例"></a>变量应用举例</h2><h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">local</span> var=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">local</span> len=<span class="variable">$&#123;&amp;#35;var&#125;</span></span><br><span class="line"><span class="built_in">local</span> i=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -lt <span class="variable">$len</span> ];<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;var:$i:1&#125;</span></span><br><span class="line">    <span class="built_in">typeset</span> i=$((i+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://mywiki.wooledge.org/BashFAQ/054">How can I tell whether a variable contains a valid number?</a></li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>sed命令使用说明</title>
    <url>/posts/63761.html</url>
    <content><![CDATA[<h2 id="内容替换"><a href="#内容替换" class="headerlink" title="内容替换"></a>内容替换</h2><h3 id="普通字符替换"><a href="#普通字符替换" class="headerlink" title="普通字符替换"></a>普通字符替换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">param_name=ro.build.id</span><br><span class="line">sed -i &quot;s/$&#123;param_name&#125;=.*/$&#123;param_name&#125;=new_value/g&quot; build.prop</span><br></pre></td></tr></table></figure>
<p>本例用于修改build.prop文件中的ro.build.id参数的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s/oldstring/newstring/g&quot; `grep oldstring -rl yourdir`</span><br></pre></td></tr></table></figure>
<p>批量替换</p>
<h3 id="二进制内容替换"><a href="#二进制内容替换" class="headerlink" title="二进制内容替换"></a>二进制内容替换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\x00/\x0a/g&#x27; %s      #本例是把&#x27;\0&#x27;替换为&#x27;\n&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><h3 id="删除文件中的某一行"><a href="#删除文件中的某一行" class="headerlink" title="删除文件中的某一行"></a>删除文件中的某一行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i \&#x27;1d\&#x27; %s   #删除第一行的文字</span><br></pre></td></tr></table></figure>

<h3 id="按行截取文本文件内容"><a href="#按行截取文本文件内容" class="headerlink" title="按行截取文本文件内容"></a>按行截取文本文件内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;起始行号,结束行号p&#x27; 原始文件 &gt; 另存为的文件</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>awk命令使用说明</title>
    <url>/posts/61132.html</url>
    <content><![CDATA[<p><strong>查找</strong><br>查找以<code>ro.build.id=</code>开头的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/^ro.build.id=/ &#123;print $1&#125;&#x27;</span> build.prop   <span class="comment">#在build.prop文件中查找</span></span><br></pre></td></tr></table></figure>
<p>下面的例子实现了同样的效果，但是采用了变量的形式，用起来会更加灵活</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prop_name=ro.build.id</span><br><span class="line">awk -v identifier=<span class="string">&quot;<span class="variable">$&#123;prop_name&#125;</span>=&quot;</span> <span class="string">&#x27;$0 ~ &quot;^&quot; identifier &#123;print $1&#125;&#x27;</span> build.prop</span><br></pre></td></tr></table></figure>

<p><strong>分割字符</strong><br>默认以空格为分隔符，比如：<code>input | awk &#39;&#123;print \$1&#125;&#39;</code><br>可以通过-F参数指定分隔符，比如： <code>input | awk -F &quot;-&gt;&quot; &#39;&#123;print $2&#125;&#39;</code></p>
<p><strong>字符串替换</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123; FS=&quot;SYSTEM/&quot; &#125; sub(/SYSTEM/,&quot;system&quot;) &#123;print $$2&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zipinfo -1 target-V100R001C02B013SP06.zip | awk <span class="string">&#x27;BEGIN &#123; FS=&quot;SYSTEM/&quot; &#125; sub(/SYSTEM/,&quot;system&quot;) &#123;print $$2&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>查找SYSTEM/开头的字符串，并把SYSTEM替换为system后输出<br>或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zipinfo -1 /target-V100R001C02B013SP06.zip | awk <span class="string">&#x27;/^SYSTEM\// &#123;print&#125;&#x27;</span> | awk <span class="string">&#x27;sub(/SYSTEM/,&quot;system&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也能实现相同的效果</p>
<p><strong>只输出最后一行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%H\ | awk &#x27;NF&#123;a=<span class="variable">$0</span>&#125; END&#123;print a&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell管道</title>
    <url>/posts/669.html</url>
    <content><![CDATA[<h2 id="通过管道执行命令，获取各个命令的返回值"><a href="#通过管道执行命令，获取各个命令的返回值" class="headerlink" title="通过管道执行命令，获取各个命令的返回值"></a>通过管道执行命令，获取各个命令的返回值</h2><p>比如执行命令：cmd1 | cmd2 | cmd3  。 如果命令执行完后，通过”$?”获取的是cmd3的返回值。如何获取cmd1和cmd2的返回值呢？</p>
<p>在bash环境下，命令的返回值保存在”PIPESTATUS”数组中:</p>
<ul>
<li>${PIPESTATUS[0]} 是cmd1的返回值；</li>
<li>${PIPESTATUS[1]} 是cmd2的返回值；</li>
<li>${PIPESTATUS[2]} 是cmd3的返回值；</li>
<li>$? 始终等于 ${PIPESTATUS:-1}。</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://unix.derkeiler.com/Newsgroups/comp.unix.shell/2003-09/0909.html">comp.unix.shell FAQ - Answers to Frequently Asked Questions</a></li>
</ul>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 中文乱码问题</title>
    <url>/posts/2892.html</url>
    <content><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.worldhello.net/gotgit/08-git-misc/020-git-charset.html">Git字符集问题</a></p>
]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令</title>
    <url>/posts/3223.html</url>
    <content><![CDATA[<h2 id="常用全局配置"><a href="#常用全局配置" class="headerlink" title="常用全局配置"></a>常用全局配置</h2><p>git配置使用<a href="https://git-scm.com/docs/git-config">git config</a>来完成。</p>
<h3 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h3><p>要配置成自己的真实用户名（姓名全拼）和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;johndoe@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>比如<a href="https://git-scm.com/docs/git-checkout">git checkout</a>通过配置别名，可以使用git co来达到<a href="https://git-scm.com/docs/git-checkout">git checkout</a>的效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>

<h3 id="配置编辑器vim"><a href="#配置编辑器vim" class="headerlink" title="配置编辑器vim"></a>配置编辑器vim</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure>

<h3 id="配置代码合并工具"><a href="#配置代码合并工具" class="headerlink" title="配置代码合并工具"></a>配置代码合并工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure>

<h3 id="配置高亮显示"><a href="#配置高亮显示" class="headerlink" title="配置高亮显示"></a>配置高亮显示</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">true</span></span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.branch auto</span><br></pre></td></tr></table></figure>

<h3 id="查看所有配置"><a href="#查看所有配置" class="headerlink" title="查看所有配置"></a>查看所有配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 -b &lt;branch name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="下载单个分支"><a href="#下载单个分支" class="headerlink" title="下载单个分支"></a>下载单个分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 -b master --single-branch</span><br></pre></td></tr></table></figure>

<p>查看工程下的.git/config文件可以看到下面一句“fetch = +refs/heads/dev:refs/remotes/origin/master”，表示只拉取一个分支。</p>
<p>如果还想在工程中拉取其他分支，比如develop，则可以执行命令<code>git remote set-branches --add origin develop</code><br>参考链接：<a href="https://git-scm.com/book/en/v2/Git-Internals-The-Refspec">Git Internals - The Refspec</a></p>
<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>创建一个名为new_branch的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch new_branch  </span><br></pre></td></tr></table></figure>

<p>创建本地branch_name分支，并且跟踪远端仓库的同名分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -t remote/branch_name</span><br></pre></td></tr></table></figure>

<p>删除本地分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D branch_name</span><br></pre></td></tr></table></figure>
<p>删除远端remote仓库的名为branch_name的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote :branch_name</span><br></pre></td></tr></table></figure>
<p>从一个分支切到另一个分支，注意此分支必须是已经有的分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout branch</span><br></pre></td></tr></table></figure>

<h2 id="查看代码历史"><a href="#查看代码历史" class="headerlink" title="查看代码历史"></a>查看代码历史</h2><h3 id="查看本地未提交的commit"><a href="#查看本地未提交的commit" class="headerlink" title="查看本地未提交的commit"></a>查看本地未提交的commit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> @&#123;u&#125;..</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> origin/master..HEAD</span><br></pre></td></tr></table></figure>

<h3 id="查看某次commit后的提交"><a href="#查看某次commit后的提交" class="headerlink" title="查看某次commit后的提交"></a>查看某次commit后的提交</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log 4341b6229727799a90305c0f3e909470c527351f..HEAD</span><br></pre></td></tr></table></figure>

<h2 id="修改代码并提交"><a href="#修改代码并提交" class="headerlink" title="修改代码并提交"></a>修改代码并提交</h2><ol>
<li><p>代码修改后，可以通过如下命令将修改的代码标记为track状态（可根据实际情况选择其中一条或者多条命令)。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;files...&gt;</span><br><span class="line">git <span class="built_in">mv</span> &lt;old&gt; &lt;new&gt;</span><br><span class="line">git <span class="built_in">rm</span> &lt;files...&gt;</span><br><span class="line">git <span class="built_in">rm</span> -r &lt;<span class="built_in">dirs</span>...&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将标记为track状态的文件提交</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p> 提交修改，该命令会调用编辑器用于书写log信息。也可使使用<code>git commit     -m &quot;commit messages&quot;</code></p>
</li>
<li><p>提交代码到远程仓库<br> 如果本地分支已经配置为跟踪远端分支（比如：git co -t origin/develop)，可以直接使用<code>git push</code>。如果还没有设置跟踪远端分支，则需要使用下面命令：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote branch</span><br></pre></td></tr></table></figure>

<p> remote 表示远程仓库名称，branch表示分支名称。此命令只适用于本地仓库与远程仓库同名的情况。当分支名称不同是，需要同时指定本地分支和远端分支。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push remote local_branch:remote_branch</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="回退代码"><a href="#回退代码" class="headerlink" title="回退代码"></a>回退代码</h2><p>回退代码会用到git的reset和checkout两个指令：</p>
<ul>
<li><p><a href="https://git-scm.com/docs/git-reset">git reset</a> 是把本地代码回退掉，要切到最新，则需要通过<a href="https://git-scm.com/docs/git-pull">git pull</a>拉取服务器上的最新代码；一般只有在需要永远放弃某些修改的情况下，才使用<a href="https://git-scm.com/docs/git-reset">git reset</a>命令。</p>
</li>
<li><p><a href="https://git-scm.com/docs/git-checkout">git checkout</a> 是切到过去的时间点，还可以切换来。相当于切到了一个新的分支，还可以切换原来分支。</p>
</li>
<li><p>*注意**，本节的示例中的所有<a href="https://git-scm.com/docs/git-reset">git reset</a>都可以可以换成<a href="https://git-scm.com/docs/git-checkout">git checkout</a>。</p>
</li>
<li><p>将代码回退到三天前</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --before=<span class="string">&quot;3 days&quot;</span> -1 --pretty=format:<span class="string">&quot;%H&quot;</span></span><br><span class="line">619ee7a53952d4c94270aa39e9ecdf9ac3aca473</span><br><span class="line">$ git reset --hard 619ee7a53952d4c94270aa39e9ecdf9ac3aca473</span><br></pre></td></tr></table></figure>

<p>也可以合起来用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --before=<span class="string">&quot;3 days&quot;</span> -1 --pretty=format:<span class="string">&quot;%H&quot;</span> | xargs git reset --hard</span><br></pre></td></tr></table></figure>

<ul>
<li><p>回退代码到某一天</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --before=<span class="string">&quot;2013-10-10&quot;</span> -1 --pretty=format:<span class="string">&quot;%H&quot;</span> | xargs git reset --hard</span><br></pre></td></tr></table></figure>
</li>
<li><p>回退代码到某一天的某个时间点</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --before=<span class="string">&quot;2013-10-10 09:15:00 +0800&quot;</span> -1 --pretty=format:<span class="string">&quot;%H&quot;</span> | xargs git    checkout</span><br></pre></td></tr></table></figure>

<p>  其中 +0800 表示东八区时间</p>
</li>
<li><p>查看某个时间段的日志</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2013-10-10 09:15:00 +0800&quot;</span> --before=<span class="string">&quot;2013-10-10 23:59:00 +0800&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将服务器代码回退到某个点并提交到某个分支（服务器回退不可恢复，确保准确后回退，做好备份）</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br><span class="line">git push --force sunniwell base</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>合并分支前提是需要相同SDK中的不同分支。</p>
<ul>
<li><p>把另外一个分支的所有修改快速合并。并提交到一个分支上</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure>
</li>
<li><p>把另外一个分支的单个commit 合并到当前分支，并提交单个分支，有冲突查看“HEAD”关键字</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commit&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>合并分支时难免会产生冲突。冲突发生后分为如下两种情况进行处理：</p>
<ul>
<li><strong>文本文件冲突</strong> 可以通过git mergetool命令编辑冲突文件；</li>
<li><strong>二进制文件冲突</strong> 时就无法合并了，要么使用被合并分支的该文件，要么就采用当前分支的该文件。<br>比如仓库下面的“path/lib_file.so”冲突了。则可以通过如下命令选择采用哪个分支的文件：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show branch_name:path/lib_file.so &gt; path/lib_file.so</span><br></pre></td></tr></table></figure>
  命令中的第一个path/lib_file.so必须是对应的git仓库根目录的路径，第二个path/lib_file.so则是当前目录的相对路径。<h2 id="查看本地分支跟踪的远程分支"><a href="#查看本地分支跟踪的远程分支" class="headerlink" title="查看本地分支跟踪的远程分支"></a>查看本地分支跟踪的远程分支</h2></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rev-parse --abbrev-ref --symbolic-full-name @&#123;upstream&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/questions/171550/find-out-which-remote-branch-a-local-branch-is-tracking">Find out which remote branch a local branch is tracking</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git book</a></li>
</ul>
]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
